# 逆向笔记

### dex魔数信息

```
64 65 78 0A 30 33 35 00
```



### 类加载器

Android系统中ClassLoader：

```
ClassLoader为抽象类；
BootClassLoader预加载常用类，单例模式。与Java中的BootClassLoader不同，它并不是由C/C++代码实现，而是由Java实现的；
BaseDexClassLoader是PathClassLoader、DexClassLoader、InMemoryDexClassLoader的父类，类加载的主要逻辑都是在BaseDexClassLoader完成的。
SecureClassLoader继承了抽象类ClassLoader，拓展了ClassLoader类加入了权限方面的功能，加强了安全性，其子类URLClassLoader是用URL路径从jar文件中加载类和资源。

PathClassLoader是Android默认使用的类加载器，一个apk中的Activity等类便是在其中加载。
DexClassLoader可以加载任意目录下的dex/jar/apk/zip文件，比PathClassLoader更灵活，是实现插件化、热修复以及dex加壳的重点。
Android8.0新引入InMemoryDexClassLoader，从名字便可看出是用于直接从内存中加载dex。
```

DexClassLoader方法参数：

```
dexPath:目标所在的apk或者jar文件的路径，装载器将从路径中寻找指定的目标类。
dexOutputDir:由于dex 文件在APK或者 jar文件中，所以在装载前面前先要从里面解压出dex文件，这个路径就是dex文件存放的路径，在 android系统中，一个应用程序对应一个linux用户id ,应用程序只对自己的数据目录有写的权限，所以我们存放在这个路径中。(odex存放路径)
libPath :目标类中使用的C/C++库。(so路径)
最后一个参数是该装载器的父装载器，一般为当前执行类的装载器。
```



### 加载插件dex并运行方法

```java
// testDexClassLoader(getApplicationContext(),"/sdcard/3.dex");
public void testDexClassLoader(Context context,String dexfilepath){
    // dex文件存放的路径
    File optfile=context.getDir("opt_dex",0);
    // 目标类中使用的C/C++库。
    File libfile=context.getDir("lib_path",0);
    DexClassLoader dexClassLoader=new DexClassLoader(dexfilepath, optfile.getAbsolutePath(), libfile.getAbsolutePath(), MainActivity.class.getClassLoader());
    Class<?> clazz=null;
    try {
        clazz = dexClassLoader.loadClass("com.cq.test.TestClass");
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
    if(clazz!=null){
        try {
            Method testFuncMethod=clazz.getDeclaredMethod("testFunc");
            Object obj=clazz.newInstance();
            testFuncMethod.invoke(obj);
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
    }
}
```



### 加壳应用的运行流程

```
App启动

(自定义application中的attachBaseContext方法实现)
解密源程序
初始化自定义类加载器
反射设置loadedApk中加载器对象为自定义类加载器

(自定义application中的onCreate方法实现)
获取源程序中的Application名称
反射生成正确的application对象
反射设置ActivityThread中的application信息

Activity加载流程源程序正常运行
```





### 加载dex插件中的Activity

**注：插件中的activity需要在app的Androidmanifest中注册**



**为什么不能直接用DexClassLoader加载后跳转?**

因为组件中是由LoadedApk中的classLoader加载，直接用会出现类找不到的问题



原理：(Android 8.0分析)

```java
class ActivityThread{
    // ActivityThread为单例模式
    private static volatile ActivityThread sCurrentActivityThread;
    // 反射获取
	final ArrayMap<String, WeakReference<LoadedApk>> mPackages = new ArrayMap<>();
}
```

```java
class LoadedApk {
    // 替换 ClassLoader
	private ClassLoader mClassLoader;
}
```



**如何解决?**

两种解决方案:

1.反射替换

替换系统组件类加载器为我们的DexClassLoader，同时设置DexClassLoader的parent为系统组件类加载器；

2.反射插入

打破原有的双亲关系，在系统组件类加载器和BootClassLoader的中间插入我们自己的DexClassLoader即可；



1.

```java
public void startTestActivityFirstMethod(Context context,String dexfilepath){
    File optfile=context.getDir("opt_dex",0);
    File libfile=context.getDir("lib_path",0);
    DexClassLoader dexClassLoader=new DexClassLoader(dexfilepath,optfile.getAbsolutePath(),libfile.getAbsolutePath(),MainActivity.class.getClassLoader());

    replaceClassloader(dexClassLoader);

    Class<?> clazz=null;
    try {
        clazz = dexClassLoader.loadClass("com.cq.test02.TestActivity");
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
    context.startActivity(new Intent(context,clazz));
}

public void replaceClassloader(ClassLoader classloader){
    try {
        Class<?> ActivityThreadClazz=classloader.loadClass("android.app.ActivityThread");
        Method currentActivityThreadMethod= ActivityThreadClazz.getDeclaredMethod("currentActivityThread");
        currentActivityThreadMethod.setAccessible(true);
        Object activityThreadObj=currentActivityThreadMethod.invoke(null);
        //final ArrayMap<String, WeakReference<LoadedApk>> mPackages = new ArrayMap<>();
        Field mPackagesField=ActivityThreadClazz.getDeclaredField("mPackages");
        mPackagesField.setAccessible(true);
        ArrayMap mPackagesObj= (ArrayMap) mPackagesField.get(activityThreadObj);
        WeakReference wr= (WeakReference) mPackagesObj.get(this.getPackageName());
        Object loadedApkObj=wr.get();

        Class LoadedApkClazz=classloader.loadClass("android.app.LoadedApk");
        //private ClassLoader mClassLoader;
        Field mClassLoaderField=LoadedApkClazz.getDeclaredField("mClassLoader");
        mClassLoaderField.setAccessible(true);
        mClassLoaderField.set(loadedApkObj,classloader);
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } catch (NoSuchMethodException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (InvocationTargetException e) {
        e.printStackTrace();
    } catch (NoSuchFieldException e) {
        e.printStackTrace();
    }
}
```



2.

```java
public void startTestActivitySecondMethod(Context context,String dexfilepath){
    File optfile=context.getDir("opt_dex",0);
    File libfile=context.getDir("lib_path",0);
    
	ClassLoader pathClassloader=MainActivity.class.getClassLoader();
	ClassLoader bootClassloader=MainActivity.class.getClassLoader().getParent();
    
    DexClassLoader dexClassLoader=new DexClassLoader(dexfilepath, optfile.getAbsolutePath(), libfile.getAbsolutePath(), bootClassloader);
    try {
        Field parentField=ClassLoader.class.getDeclaredField("parent");
        parentField.setAccessible(true);
        parentField.set(pathClassloader, dexClassLoader);
    } catch (NoSuchFieldException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    }

    Class<?> clazz=null;
    try {
        clazz = dexClassLoader.loadClass("com.cq.test02.TestActivity");
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
    context.startActivity(new Intent(context,clazz));
}
```





### 壳技术分类

第一代壳:Dex加密

1.Dex字符串加密

2.资源加密

3.对抗反编译

4.反调试

5.自定义DexClassLoader

缺点：在内存中的映射是连续的



第二代壳：Dex抽取与So加固

1.对抗第一代壳常见的脱壳法

2.Dex Method代码抽取到外部(通常企业版)

3.Dex动态加密

4.so加密

缺点：遍历Dex中的所有类去加载和初始化，这样在内存中就是完整的



第三代壳：Dex动态解密与So混淆

1.Dex Method代码动态解密

2.So代码膨胀混淆

3.对抗之前出现的所有脱壳法



第四代壳：arm vmp(未来)

vmp壳识别



**总结:**

dex的加固技术发展

1、dex整体加固：文件加载和内存加载

通用方案：dex打开和优化的流程以及产出的odex、dex2oat编译的流程和生成的oat文件等等

2、函数抽取：在函数粒度完成代码的保护

(1)类加载和函数执行前的流程解密

(2)函数执行中动态自解密

方案：关注被抽取的函数的执行流程是关键，定位被抽取的函数的恢复时机即可

3、VMP和Dex2C：JAVA函数Native化

vmp：定位解释器是关键，找到映射关系便可恢复

dex2c：基础是编译原理，进行了等价语义转换，彻底还原难度巨大

通用解决方案：关注JNI相关的api调用是关键，也是分析vmp和dex2c保护的函数的逻辑的关键





so的加固种类

1、基于init、init_array以及JNI_Onload函数的加壳

2、基于自定义linker的加壳





函数抽取：获取到保护的dex后，函数体的内容是无效的，注意这里说的是无效，而不是无意义，有的app加壳后函数依然是有意义的，但不是我们想要的；



VMP：获取到保护的dex后，函数的属性由java属性变为Native，典型的有数字的onCreate函数Native化；

ADVMP：https://github.com/chago/ADVMP



dex2c：获取到保护的dex后，和VMP一样，被保护函数的属性由java属性变为Native，如开源的DCC (Dex-to-C Compiler)



混合型壳：多种加固技术混合使用，比如先将原有smali指令流使用VMP或dex2c保护，然后再经过函数抽取进一步保护





如何区分VMP和Dex2c？

vmp： 对于vmp保护都有一个共享解释器，注册地址是一样的

dex2c：对每个java函数进行语义分析，生成各自不同的C/C++代码，编译为相应的so,每一个dex2c保护的函数逻辑不一样，注册地址也就不一样



注：这里的注册地址指的是注册到JNI里的函数地址





### Dalvik下DexClassLoader加载dex源码流程分析(4.4)

[BaseDexClassLoader.java](http://androidxref.com/4.4.4_r1/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java)

```java
public BaseDexClassLoader(ByteBuffer[] dexFiles, ClassLoader parent) {
     super(parent);
     this.pathList = new DexPathList(this, dexFiles);
}
```

[DexPathList.java](http://androidxref.com/4.4.4_r1/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java)

```java
public DexPathList(ClassLoader definingContext, String dexPath, String librarySearchPath, File optimizedDirectory) {
	this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions, definingContext);
}

private static Element[] makeDexElements(List<File> files, File optimizedDirectory, List<IOException> suppressedExceptions, ClassLoader loader) {
	 DexFile dex = loadDexFile(file, optimizedDirectory, loader, elements);
}

private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader, Element[] elements){
	return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements);
}
```

[DexFile.java](http://androidxref.com/4.4.4_r1/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java)

```java
static DexFile loadDex(String sourcePathName, String outputPathName, int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException {
	return new DexFile(sourcePathName, outputPathName, flags, loader, elements);   
}

private DexFile(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException {
	mCookie = openDexFile(sourceName, outputName, flags, loader, elements);
}


private static Object openDexFile(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException {
	return openDexFileNative(new File(sourceName).getAbsolutePath(), (outputName == null) ? null : new File(outputName).getAbsolutePath(), flags, loader, elements);
}
```

[dalvik_system_DexFile.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/native/dalvik_system_DexFile.cpp)

```c++
static void Dalvik_dalvik_system_DexFile_openDexFileNative(const u4* args, JValue* pResult) {
	 if (hasDexExtension(sourceName) && dvmRawDexFileOpen(sourceName, outputName, &pRawDexFile, false) == 0) {
     }
}
```

[RawDexFile.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/RawDexFile.cpp)

```cpp
int dvmRawDexFileOpen(const char* fileName, const char* odexOutputName,  RawDexFile** ppRawDexFile, bool isBootstrap)
{
    // 打开dex文件
    dexFd = open(fileName, O_RDONLY);
    // 对dex文件魔术校验
    if (verifyMagicAndGetAdler32(dexFd, &adler32) < 0) {
        ALOGE("Error with header for %s", fileName);
        goto bail;
    }
    // 生成odex文件
    if (odexOutputName == NULL) {
        cachedName = dexOptGenerateCacheFileName(fileName, NULL);
        if (cachedName == NULL)
            goto bail;
    } else {
        cachedName = strdup(odexOutputName);
    }
	
    // dex优化流程
    if (result) {
        result = dvmOptimizeDexFile(optFd, dexOffset, fileSize,
            fileName, modTime, adler32, isBootstrap);
    }
    
}
```

[DexPrepare.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/analysis/DexPrepare.cpp)

```cpp
// fd 打开文件id ， dexLength文件大小
bool dvmOptimizeDexFile(int fd, off_t dexOffset, long dexLength, const char* fileName, u4 modWhen, u4 crc, bool isBootstrap)
{
    // 新建子进程对当前dex文件进行优化
    pid = fork();
    if (pid == 0) {
        static const char* kDexOptBin = "/bin/dexopt";
    }
}
```

[OptMain.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/dexopt/OptMain.cpp)

```cpp
// 主入口
int main(int argc, char* const argv[])
{
    if (strcmp(argv[1], "--dex") == 0)
    	return fromDex(argc, argv);
}


static int fromDex(int argc, char* const argv[])
{
    // 环境准备阶段
	if (dvmPrepForDexOpt(bootClassPath, dexOptMode, verifyMode, flags) != 0) {
        ALOGE("VM init failed");
        goto bail;
    }   
    
    // 优化
    if (!dvmContinueOptimization(fd, offset, length, debugFileName, modWhen, crc, (flags & DEXOPT_IS_BOOTSTRAP) != 0))
    {
        ALOGE("Optimization failed");
        goto bail;
    }
}
```

[DexPrepare.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/analysis/DexPrepare.cpp)

```cpp
bool dvmContinueOptimization(int fd, off_t dexOffset, long dexLength, const char* fileName, u4 modWhen, u4 crc, bool isBootstrap)
{
    // 对dex当前内容进行内存映射
	mapAddr = mmap(NULL, dexOffset + dexLength, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);    
    // hook
    
    // 对dex进行重写
    success = rewriteDex(((u1*) mapAddr) + dexOffset, dexLength, doVerify, doOpt, &pClassLookup, NULL);
}

// addr 加载到内存的起始地址， len 字节数
static bool rewriteDex(u1* addr, int len, bool doVerify, bool doOpt, DexClassLookup** ppClassLookup, DvmDex** ppDvmDex)
{
    // hook
    if (dvmDexFileOpenPartial(addr, len, &pDvmDex) != 0) {
        ALOGE("Unable to create DexFile");
        goto bail;
    }
}
```

[DvmDex.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/DvmDex.cpp)

```cpp
int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex)
{
    // hook
    pDexFile = dexFileParse((u1*)addr, len, parseFlags);
}
```





#### 修改脱壳：

[DvmDex.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/DvmDex.cpp)

```cpp
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex)
{
    // 保存路径
	char dexfilepath[100]={0};
    // 进程号
	int pid=getpid();
    // 文件路径拼接
	sprintf(dexfilepath,"/sdcard/%d_%d_dvmDexFileOpenPartial.dex",len,pid);
    // 很多壳为了对抗内存dump,会将标准fopen等函数hook掉，所以避免使用标准文件读写函数导致内存dump不下来的问题
	int fd=open(dexfilepath, O_CREAT|O_RDWR, 0666);
	if(fd > 0)
	{
		write(fd,addr,len);
		close(fd);
	}

	// ...
	
    return result;
}

```

[DexFile.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/libdex/DexFile.cpp)

```cpp
DexFile* dexFileParse(const u1* data, size_t length, int flags)
{
	char dexfilepath[100]={0};
	int pid=getpid();
	sprintf(dexfilepath,"/sdcard/%d_%d_dexFileParse.dex",length,pid);
	int fd=open(dexfilepath,O_CREAT|O_RDWR,0666);
	if(fd > 0)
	{
		write(fd,addr,len);
		close(fd);
	}
}
```



[DexPrepare.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/analysis/DexPrepare.cpp)

```cpp
// so需要修正,删除前面的数据
bool dvmContinueOptimization(int fd, off_t dexOffset, long dexLength,
    const char* fileName, u4 modWhen, u4 crc, bool isBootstrap)
{
	mapAddr = mmap(NULL, dexOffset + dexLength, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);

	char dexfilepath[100]={0};
	int pid=getpid();
	sprintf(dexfilepath,"/sdcard/%ld_%d_dvmContinueOptimization.dex",dexLength,pid);
	int fd=open(dexfilepath,O_CREAT|O_RDWR,0666);
	if(fd > 0)
	{
		write(fd, mapAddr, dexOffset + dexLength);
		close(fd);
	}
}


static bool rewriteDex(u1* addr, int len, bool doVerify, bool doOpt, DexClassLookup** ppClassLookup, DvmDex** ppDvmDex)
{
	char dexfilepath[100]={0};
	int pid=getpid();
	sprintf(dexfilepath,"/sdcard/%d_%d_rewriteDex.dex",len,pid);
	int fd=open(dexfilepath,O_CREAT|O_RDWR,0666);
	if(fd>0)
	{
		write(fd, addr, len);
		close(fd);
	}
}
```

DexSwapVerify

```cpp
int dexSwapAndVerify(u1* addr, int len)
{
	char dexfilepath[100]={0};
    int pid=getpid();
    sprintf(dexfilepath,"/sdcard/%d_%d_dexSwapAndVerify.dex",len,pid);
    int fd=open(dexfilepath,O_CREAT|O_RDWR,0666);
    if(fd>0)
    {
		write(fd,addr,len);
		close(fd);
	}
}
```



### ART下一代壳通用解决方案(8.0)

#### InMemoryDexClassLoader流程分析

[InMemoryDexClassLoader.java](http://androidxref.com/8.0.0_r4/xref/libcore/dalvik/src/main/java/dalvik/system/InMemoryDexClassLoader.java)

```java
public InMemoryDexClassLoader(ByteBuffer[] dexBuffers, ClassLoader parent) {
	super(dexBuffers, parent);
}
```

[BaseDexClassLoader.java](http://androidxref.com/8.0.0_r4/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java)

```
public BaseDexClassLoader(ByteBuffer[] dexFiles, ClassLoader parent) {
	super(parent);
	this.pathList = new DexPathList(this, dexFiles);
}
```

[DexPathList.java](http://androidxref.com/8.0.0_r4/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java)

```java
public DexPathList(ClassLoader definingContext, ByteBuffer[] dexFiles) {
	this.dexElements = makeInMemoryDexElements(dexFiles, suppressedExceptions);
}

private static Element[] makeInMemoryDexElements(ByteBuffer[] dexFiles, List<IOException> suppressedExceptions) {
    Element[] elements = new Element[dexFiles.length];
    int elementPos = 0;
    for (ByteBuffer buf : dexFiles) {
        try {
            DexFile dex = new DexFile(buf);
            elements[elementPos++] = new Element(dex);
        } catch (IOException suppressed) {
            System.logE("Unable to load dex file: " + buf, suppressed);
            suppressedExceptions.add(suppressed);
        }
    }
	return elements;
}
```

[DexFile.java](http://androidxref.com/8.0.0_r4/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java)

```java
DexFile(ByteBuffer buf) throws IOException {
	mCookie = openInMemoryDexFile(buf);
	mInternalCookie = mCookie;
	mFileName = null;
}

private static Object openInMemoryDexFile(ByteBuffer buf) throws IOException {
    if (buf.isDirect()) {
        return createCookieWithDirectBuffer(buf, buf.position(), buf.limit());
    } else {
        return createCookieWithArray(buf.array(), buf.position(), buf.limit());
    }
}

```

[dalvik_system_DexFile.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/native/dalvik_system_DexFile.cc)

```cpp
static jobject DexFile_createCookieWithDirectBuffer(JNIEnv* env, jclass, jobject buffer, jint start, jint end) {
	// ...
	memcpy(dex_mem_map->Begin(), base_address, length);
	return CreateSingleDexFileCookie(env, std::move(dex_mem_map));
}

static jobject DexFile_createCookieWithArray(JNIEnv* env, jclass, jbyteArray buffer, jint start, jint end) {
	// ...
	return CreateSingleDexFileCookie(env, std::move(dex_mem_map));
}

static jobject CreateSingleDexFileCookie(JNIEnv* env, std::unique_ptr<MemMap> data) {
  std::unique_ptr<const DexFile> dex_file(CreateDexFile(env, std::move(data)));
  std::vector<std::unique_ptr<const DexFile>> dex_files;
  dex_files.push_back(std::move(dex_file));
  return ConvertDexFilesToJavaArray(env, nullptr, dex_files);
}


static const DexFile* CreateDexFile(JNIEnv* env, std::unique_ptr<MemMap> dex_mem_map) {
  std::string location = StringPrintf("Anonymous-DexFile@%p-%p", dex_mem_map->Begin(), dex_mem_map->End());
  std::unique_ptr<const DexFile> dex_file(DexFile::Open(location, 0, std::move(dex_mem_map), 
                                                        /* verify */ true, /* verify_location */ true, &error_message));

  return dex_file.release();
}
```



[dex_file.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/dex_file.cc)

```cpp
std::unique_ptr<const DexFile> DexFile::Open(const std::string& location,
                                             uint32_t location_checksum,
                                             std::unique_ptr<MemMap> map,
                                             bool verify,
                                             bool verify_checksum,
                                             std::string* error_msg) {


  std::unique_ptr<DexFile> dex_file = OpenCommon(map->Begin(),
                                                 map->Size(),
                                                 location,
                                                 location_checksum,
                                                 kNoOatDexFile,
                                                 verify,
                                                 verify_checksum,
                                                 error_msg);
  
  return dex_file;
}


std::unique_ptr<DexFile> DexFile::OpenCommon(const uint8_t* base, size_t size, const std::string& location,
                                             uint32_t location_checksum, const OatDexFile* oat_dex_file,
                                             bool verify, bool verify_checksum, std::string* error_msg,
                                             VerifyResult* verify_result) {

  std::unique_ptr<DexFile> dex_file(new DexFile(base,
                                                size,
                                                location,
                                                location_checksum,
                                                oat_dex_file));
 
  return dex_file;
}


DexFile::DexFile(const uint8_t* base,
                 size_t size,
                 const std::string& location,
                 uint32_t location_checksum,
                 const OatDexFile* oat_dex_file)
    : begin_(base),
      size_(size),
      location_(location),
      location_checksum_(location_checksum),
      header_(reinterpret_cast<const Header*>(base)),
      string_ids_(reinterpret_cast<const StringId*>(base + header_->string_ids_off_)),
      type_ids_(reinterpret_cast<const TypeId*>(base + header_->type_ids_off_)),
      field_ids_(reinterpret_cast<const FieldId*>(base + header_->field_ids_off_)),
      method_ids_(reinterpret_cast<const MethodId*>(base + header_->method_ids_off_)),
      proto_ids_(reinterpret_cast<const ProtoId*>(base + header_->proto_ids_off_)),
      class_defs_(reinterpret_cast<const ClassDef*>(base + header_->class_defs_off_)),
      method_handles_(nullptr),
      num_method_handles_(0),
      call_site_ids_(nullptr),
      num_call_site_ids_(0),
      oat_dex_file_(oat_dex_file) {
  CHECK(begin_ != nullptr) << GetLocation();
  CHECK_GT(size_, 0U) << GetLocation();
  // Check base (=header) alignment.
  // Must be 4-byte aligned to avoid undefined behavior when accessing
  // any of the sections via a pointer.
  CHECK_ALIGNED(begin_, alignof(Header));

  InitializeSectionsFromMapList();
}
```



InMemoryDexClassLoader没有对内存中dex编译生成oat文件



#### DexClassLoader流程分析

前面步骤和davilk一样

[dalvik_system_DexFile.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/native/dalvik_system_DexFile.cc)

```cpp
static jobject DexFile_openDexFileNative(JNIEnv* env,
                                         jclass,
                                         jstring javaSourceName,
                                         jstring javaOutputName ATTRIBUTE_UNUSED,
                                         jint flags ATTRIBUTE_UNUSED,
                                         jobject class_loader,
                                         jobjectArray dex_elements) {


  Runtime* const runtime = Runtime::Current();
  ClassLinker* linker = runtime->GetClassLinker();
  std::vector<std::unique_ptr<const DexFile>> dex_files;
  std::vector<std::string> error_msgs;
  const OatFile* oat_file = nullptr;

  dex_files = runtime->GetOatFileManager().OpenDexFilesFromOat(sourceName.c_str(),
                                                               class_loader,
                                                               dex_elements,
                                                               /*out*/ &oat_file,
                                                               /*out*/ &error_msgs);

  if (!dex_files.empty()) {
    jlongArray array = ConvertDexFilesToJavaArray(env, oat_file, dex_files);
    if (array == nullptr) {
      ScopedObjectAccess soa(env);
      for (auto& dex_file : dex_files) {
        if (linker->IsDexFileRegistered(soa.Self(), *dex_file)) {
          dex_file.release();
        }
      }
    }
    return array;
  } else {
    ScopedObjectAccess soa(env);
    CHECK(!error_msgs.empty());
    // The most important message is at the end. So set up nesting by going forward, which will
    // wrap the existing exception as a cause for the following one.
    auto it = error_msgs.begin();
    auto itEnd = error_msgs.end();
    for ( ; it != itEnd; ++it) {
      ThrowWrappedIOException("%s", it->c_str());
    }

    return nullptr;
  }
}
```



[oat_file_manager.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/oat_file_manager.cc)

```cpp
std::vector<std::unique_ptr<const DexFile>> OatFileManager::OpenDexFilesFromOat(
    const char* dex_location,
    jobject class_loader,
    jobjectArray dex_elements,
    const OatFile** out_oat_file,
    std::vector<std::string>* error_msgs) {

  Thread* const self = Thread::Current();
  Locks::mutator_lock_->AssertNotHeld(self);
  Runtime* const runtime = Runtime::Current();

  // 新建oat对象
  OatFileAssistant oat_file_assistant(dex_location,
                                      kRuntimeISA,
                                      !runtime->IsAotCompiler());

  const OatFile* source_oat_file = nullptr;
  
  if (!oat_file_assistant.IsUpToDate()) {
    switch (oat_file_assistant.MakeUpToDate(/*profile_changed*/false, /*out*/ &error_msg)) {
      case OatFileAssistant::kUpdateFailed:
        LOG(WARNING) << error_msg;
        break;

      case OatFileAssistant::kUpdateNotAttempted:
        VLOG(oat) << error_msg;
        break;
      case OatFileAssistant::kUpdateSucceeded:
        break;
    }
  }

  // ...
  if (dex_files.empty()) {
    // 如果阻断了dex2oat流程,就会执行到这里尝试加载dex
    if (oat_file_assistant.HasOriginalDexFiles()) {
      if (Runtime::Current()->IsDexFileFallbackEnabled()) {
        static constexpr bool kVerifyChecksum = true;
        if (!DexFile::Open(
            dex_location, dex_location, kVerifyChecksum, /*out*/ &error_msg, &dex_files)) {
        }
      }
    }
  }
  return dex_files;
}
```

[oat_file_assistant.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/oat_file_assistant.cc)

```cpp
OatFileAssistant::MakeUpToDate(bool profile_changed, std::string* error_msg) {
  CompilerFilter::Filter target;
  OatFileInfo& info = GetBestInfo();
  switch (info.GetDexOptNeeded(target, profile_changed)) {
    case kNoDexOptNeeded:
      return kUpdateSucceeded;

    case kDex2OatFromScratch:
    case kDex2OatForBootImage:
    case kDex2OatForRelocation:
    case kDex2OatForFilter:
      return GenerateOatFileNoChecks(info, target, error_msg);
  }
  UNREACHABLE();
}


OatFileAssistant::ResultOfAttemptToUpdate OatFileAssistant::GenerateOatFileNoChecks(
      OatFileAssistant::OatFileInfo& info, CompilerFilter::Filter filter, std::string* error_msg) {
  CHECK(error_msg != nullptr);

  Runtime* runtime = Runtime::Current();
  if (!runtime->IsDex2OatEnabled()) {
    *error_msg = "Generation of oat file for dex location " + dex_location_
      + " not attempted because dex2oat is disabled.";
    return kUpdateNotAttempted;
  }


  if (!Dex2Oat(args, error_msg)) {
    vdex_file->Erase();
    unlink(vdex_file_name.c_str());
    oat_file->Erase();
    unlink(oat_file_name.c_str());
    return kUpdateFailed;
  }
    
  info.Reset();
  return kUpdateSucceeded;
}


bool OatFileAssistant::Dex2Oat(const std::vector<std::string>& args,
                               std::string* error_msg) {
  // ...
  return Exec(argv, error_msg);
}
```

[exec_utils.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/exec_utils.cc)

```cpp
bool Exec(std::vector<std::string>& arg_vector, std::string* error_msg) {
  int status = ExecAndReturnCode(arg_vector, error_msg);
  if (status != 0) {
    const std::string command_line(android::base::Join(arg_vector, ' '));
    *error_msg = StringPrintf("Failed execv(%s) because non-0 exit status",
                              command_line.c_str());
    return false;
  }
  return true;
}

int ExecAndReturnCode(std::vector<std::string>& arg_vector, std::string* error_msg) {
  const std::string command_line(android::base::Join(arg_vector, ' '));
  CHECK_GE(arg_vector.size(), 1U) << command_line;

  // Convert the args to char pointers.
  const char* program = arg_vector[0].c_str();
  std::vector<char*> args;
  for (size_t i = 0; i < arg_vector.size(); ++i) {
    const std::string& arg = arg_vector[i];
    char* arg_str = const_cast<char*>(arg.c_str());
    CHECK(arg_str != nullptr) << i;
    args.push_back(arg_str);
  }
  args.push_back(nullptr);

  // fork and exec
  pid_t pid = fork();
  if (pid == 0) {
    setpgid(0, 0);

    char** envp = (Runtime::Current() == nullptr) ? nullptr : Runtime::Current()->GetEnvSnapshot();
    if (envp == nullptr) {
      execv(program, &args[0]);
    } else {
      // 通过这个函数执行dex2oat 编译过程
      execve(program, &args[0], envp);
    }
  } 
}

```

对这些函数hook会导致dex2oat流程结束。

强制结束dex2oat流程对ClassLoader第一次加载dex非常快速。

要想实现ART下的函数抽取技术也是需要阻断dex2oat流程。

dalvik是不存在dex2oat的流程，这也是和dalvik的区别。





dex2oat阻断后调用流程:

[dex_file.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/dex_file.cc)

```c++
bool DexFile::Open(const char* filename,
                   const std::string& location,
                   bool verify_checksum,
                   std::string* error_msg,
                   std::vector<std::unique_ptr<const DexFile>>* dex_files) {
  uint32_t magic;
  // hook
  File fd = OpenAndReadMagic(filename, &magic, error_msg);
  if (fd.Fd() == -1) {
    DCHECK(!error_msg->empty());
    return false;
  }
  if (IsZipMagic(magic)) {
    return DexFile::OpenZip(fd.Release(), location, verify_checksum, error_msg, dex_files);
  }
  if (IsDexMagic(magic)) {
    std::unique_ptr<const DexFile> dex_file(DexFile::OpenFile(fd.Release(),
                                                              location,
                                                              /* verify */ true,
                                                              verify_checksum,
                                                              error_msg));
    if (dex_file.get() != nullptr) {
      dex_files->push_back(std::move(dex_file));
      return true;
    } else {
      return false;
    }
  }
  return false;
}



std::unique_ptr<const DexFile> DexFile::OpenFile(int fd,
                                                 const std::string& location,
                                                 bool verify,
                                                 bool verify_checksum,
                                                 std::string* error_msg) {

  std::unique_ptr<MemMap> map;
  {
    File delayed_close(fd, /* check_usage */ false);
    struct stat sbuf;
    memset(&sbuf, 0, sizeof(sbuf));
    size_t length = sbuf.st_size;
    map.reset(MemMap::MapFile(length,
                              PROT_READ,
                              MAP_PRIVATE,
                              fd,
                              0,
                              /*low_4gb*/false,
                              location.c_str(),
                              error_msg));
  }

  const Header* dex_header = reinterpret_cast<const Header*>(map->Begin());

  std::unique_ptr<DexFile> dex_file = OpenCommon(map->Begin(),
                                                 map->Size(),
                                                 location,
                                                 dex_header->checksum_,
                                                 kNoOatDexFile,
                                                 verify,
                                                 verify_checksum,
                                                 error_msg);
  if (dex_file != nullptr) {
    dex_file->mem_map_.reset(map.release());
  }

  return dex_file;
}


// 此处就和InMemoryDexClassLoader分析的流程重合了
std::unique_ptr<DexFile> DexFile::OpenCommon(const uint8_t* base,
                                             size_t size,
                                             const std::string& location,
                                             uint32_t location_checksum,
                                             const OatDexFile* oat_dex_file,
                                             bool verify,
                                             bool verify_checksum,
                                             std::string* error_msg,
                                             VerifyResult* verify_result) {
  // hook
  std::unique_ptr<DexFile> dex_file(new DexFile(base,
                                                size,
                                                location,
                                                location_checksum,
                                                oat_dex_file));
  
  return dex_file;
}
```





#### 推荐脱壳点

[dex_file.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/dex_file.cc)

```cpp
std::unique_ptr<DexFile> DexFile::OpenCommon(const uint8_t* base,
                                             size_t size,
                                             const std::string& location,
                                             uint32_t location_checksum,
                                             const OatDexFile* oat_dex_file,
                                             bool verify,
                                             bool verify_checksum,
                                             std::string* error_msg,
                                             VerifyResult* verify_result) {
  if (verify_result != nullptr) {
    *verify_result = VerifyResult::kVerifyNotAttempted;
  }

  int pid=getpid();
  char dexfilepath[100]={0};
  sprintf(dexfilepath,"/sdcard/%d_%d_OpenCommon.dex",(int)size,pid);
  
  int fd=open(dexfilepath,O_CREAT|O_RDWR,666);
  if (fd>0){
	  int number=write(fd,base,size);
	  if(number>0) {
          
      }
	  close(fd);
  }  
  
  
  
  std::unique_ptr<DexFile> dex_file(new DexFile(base,
                                                size,
                                                location,
                                                location_checksum,
                                                oat_dex_file));
}



DexFile::DexFile(const uint8_t* base,
                 size_t size,
                 const std::string& location,
                 uint32_t location_checksum,
                 const OatDexFile* oat_dex_file)
    : begin_(base),
      size_(size),
      location_(location),
      location_checksum_(location_checksum),
      header_(reinterpret_cast<const Header*>(base)),
      string_ids_(reinterpret_cast<const StringId*>(base + header_->string_ids_off_)),
      type_ids_(reinterpret_cast<const TypeId*>(base + header_->type_ids_off_)),
      field_ids_(reinterpret_cast<const FieldId*>(base + header_->field_ids_off_)),
      method_ids_(reinterpret_cast<const MethodId*>(base + header_->method_ids_off_)),
      proto_ids_(reinterpret_cast<const ProtoId*>(base + header_->proto_ids_off_)),
      class_defs_(reinterpret_cast<const ClassDef*>(base + header_->class_defs_off_)),
      method_handles_(nullptr),
      num_method_handles_(0),
      call_site_ids_(nullptr),
      num_call_site_ids_(0),
      oat_dex_file_(oat_dex_file) {
  CHECK(begin_ != nullptr) << GetLocation();
  CHECK_GT(size_, 0U) << GetLocation();
  CHECK_ALIGNED(begin_, alignof(Header));
          
  int pid=getpid();
  char dexfilepath[100]={0};
  sprintf(dexfilepath,"/sdcard/%d_%d_DexFile.dex",(int)size,pid);
  
  int fd=open(dexfilepath,O_CREAT|O_RDWR,666);
  if (fd>0){
	  int number=write(fd,base,size);
	  if(number>0) {
	  }
	  close(fd);
  } 
  InitializeSectionsFromMapList();
}
```





#### dex2oat流程分析:

[dex2oat.cc](http://androidxref.com/8.0.0_r4/xref/art/dex2oat/dex2oat.cc)

```cpp
int main(int argc, char** argv) {
  int result = static_cast<int>(art::Dex2oat(argc, argv));
  if (!art::kIsDebugBuild && (RUNNING_ON_MEMORY_TOOL == 0)) {
    _exit(result);
  }
  return result;
}


static dex2oat::ReturnCode Dex2oat(int argc, char** argv) {
  b13564922();

  TimingLogger timings("compiler", false, false);

  // Allocate `dex2oat` on the heap instead of on the stack, as Clang
  // might produce a stack frame too large for this function or for
  // functions inlining it (such as main), that would not fit the
  // requirements of the `-Wframe-larger-than` option.
  std::unique_ptr<Dex2Oat> dex2oat = MakeUnique<Dex2Oat>(&timings);

  // Parse arguments. Argument mistakes will lead to exit(EXIT_FAILURE) in UsageError.
  dex2oat->ParseArgs(argc, argv);

  // If needed, process profile information for profile guided compilation.
  // This operation involves I/O.
  if (dex2oat->UseProfile()) {
    if (!dex2oat->LoadProfile()) {
      LOG(ERROR) << "Failed to process profile file";
      return dex2oat::ReturnCode::kOther;
    }
  }

  art::MemMap::Init();  // For ZipEntry::ExtractToMemMap, and vdex.

  // Check early that the result of compilation can be written
  if (!dex2oat->OpenFile()) {
    return dex2oat::ReturnCode::kOther;
  }

  // Print the complete line when any of the following is true:
  //   1) Debug build
  //   2) Compiling an image
  //   3) Compiling with --host
  //   4) Compiling on the host (not a target build)
  // Otherwise, print a stripped command line.
  if (kIsDebugBuild || dex2oat->IsBootImage() || dex2oat->IsHost() || !kIsTargetBuild) {
    LOG(INFO) << CommandLine();
  } else {
    LOG(INFO) << StrippedCommandLine();
  }

  dex2oat::ReturnCode setup_code = dex2oat->Setup();
  if (setup_code != dex2oat::ReturnCode::kNoFailure) {
    dex2oat->EraseOutputFiles();
    return setup_code;
  }

  // Helps debugging on device. Can be used to determine which dalvikvm instance invoked a dex2oat
  // instance. Used by tools/bisection_search/bisection_search.py.
  VLOG(compiler) << "Running dex2oat (parent PID = " << getppid() << ")";

  dex2oat::ReturnCode result;
  if (dex2oat->IsImage()) {
    result = CompileImage(*dex2oat);
  } else {
    result = CompileApp(*dex2oat);
  }

  dex2oat->Shutdown();
  return result;
}
```



```cpp
  dex2oat::ReturnCode Setup() {
    if (!PrepareImageClasses() || !PrepareCompiledClasses() || !PrepareCompiledMethods()) {
      return dex2oat::ReturnCode::kOther;
    }

    verification_results_.reset(new VerificationResults(compiler_options_.get()));
    callbacks_.reset(new QuickCompilerCallbacks(
        verification_results_.get(),
        IsBootImage() ?
            CompilerCallbacks::CallbackMode::kCompileBootImage :
            CompilerCallbacks::CallbackMode::kCompileApp));

    RuntimeArgumentMap runtime_options;
    if (!PrepareRuntimeOptions(&runtime_options)) {
      return dex2oat::ReturnCode::kOther;
    }

    CreateOatWriters();
    if (!AddDexFileSources()) {
      return dex2oat::ReturnCode::kOther;
    }

    if (IsBootImage() && image_filenames_.size() > 1) {
      // If we're compiling the boot image, store the boot classpath into the Key-Value store.
      // We need this for the multi-image case.
      key_value_store_->Put(OatHeader::kBootClassPathKey,
                            gc::space::ImageSpace::GetMultiImageBootClassPath(dex_locations_,
                                                                              oat_filenames_,
                                                                              image_filenames_));
    }

    if (!IsBootImage()) {
      // When compiling an app, create the runtime early to retrieve
      // the image location key needed for the oat header.
      if (!CreateRuntime(std::move(runtime_options))) {
        return dex2oat::ReturnCode::kCreateRuntime;
      }

      if (CompilerFilter::DependsOnImageChecksum(compiler_options_->GetCompilerFilter())) {
        TimingLogger::ScopedTiming t3("Loading image checksum", timings_);
        std::vector<gc::space::ImageSpace*> image_spaces =
            Runtime::Current()->GetHeap()->GetBootImageSpaces();
        image_file_location_oat_checksum_ = image_spaces[0]->GetImageHeader().GetOatChecksum();
        image_file_location_oat_data_begin_ =
            reinterpret_cast<uintptr_t>(image_spaces[0]->GetImageHeader().GetOatDataBegin());
        image_patch_delta_ = image_spaces[0]->GetImageHeader().GetPatchDelta();
        // Store the boot image filename(s).
        std::vector<std::string> image_filenames;
        for (const gc::space::ImageSpace* image_space : image_spaces) {
          image_filenames.push_back(image_space->GetImageFilename());
        }
        std::string image_file_location = android::base::Join(image_filenames, ':');
        if (!image_file_location.empty()) {
          key_value_store_->Put(OatHeader::kImageLocationKey, image_file_location);
        }
      } else {
        image_file_location_oat_checksum_ = 0u;
        image_file_location_oat_data_begin_ = 0u;
        image_patch_delta_ = 0;
      }

      // Open dex files for class path.
      std::vector<std::string> class_path_locations =
          GetClassPathLocations(runtime_->GetClassPathString());
      OpenClassPathFiles(class_path_locations,
                         &class_path_files_,
                         &opened_oat_files_,
                         runtime_->GetInstructionSet(),
                         classpath_dir_);

      // Store the classpath we have right now.
      std::vector<const DexFile*> class_path_files = MakeNonOwningPointerVector(class_path_files_);
      std::string encoded_class_path;
      if (class_path_locations.size() == 1 &&
          class_path_locations[0] == OatFile::kSpecialSharedLibrary) {
        // When passing the special shared library as the classpath, it is the only path.
        encoded_class_path = OatFile::kSpecialSharedLibrary;
      } else {
        encoded_class_path = OatFile::EncodeDexFileDependencies(class_path_files, classpath_dir_);
      }
      key_value_store_->Put(OatHeader::kClassPathKey, encoded_class_path);
    }

    // Now that we have finalized key_value_store_, start writing the oat file.
    {
      TimingLogger::ScopedTiming t_dex("Writing and opening dex files", timings_);
      rodata_.reserve(oat_writers_.size());
      for (size_t i = 0, size = oat_writers_.size(); i != size; ++i) {
        rodata_.push_back(elf_writers_[i]->StartRoData());
        // Unzip or copy dex files straight to the oat file.
        std::unique_ptr<MemMap> opened_dex_files_map;
        std::vector<std::unique_ptr<const DexFile>> opened_dex_files;
        // No need to verify the dex file for:
        // 1) Dexlayout since it does the verification. It also may not pass the verification since
        // we don't update the dex checksum.
        // 2) when we have a vdex file, which means it was already verified.
        const bool verify = !DoDexLayoutOptimizations() && (input_vdex_file_ == nullptr);
        if (!oat_writers_[i]->WriteAndOpenDexFiles(
            kIsVdexEnabled ? vdex_files_[i].get() : oat_files_[i].get(),
            rodata_.back(),
            instruction_set_,
            instruction_set_features_.get(),
            key_value_store_.get(),
            verify,
            update_input_vdex_,
            &opened_dex_files_map,
            &opened_dex_files)) {
          return dex2oat::ReturnCode::kOther;
        }
        dex_files_per_oat_file_.push_back(MakeNonOwningPointerVector(opened_dex_files));
        if (opened_dex_files_map != nullptr) {
          opened_dex_files_maps_.push_back(std::move(opened_dex_files_map));
          for (std::unique_ptr<const DexFile>& dex_file : opened_dex_files) {
            dex_file_oat_index_map_.emplace(dex_file.get(), i);
            opened_dex_files_.push_back(std::move(dex_file));
          }
        } else {
          DCHECK(opened_dex_files.empty());
        }
      }
    }

    dex_files_ = MakeNonOwningPointerVector(opened_dex_files_);

    // We had to postpone the swap decision till now, as this is the point when we actually
    // know about the dex files we're going to use.

    // Make sure that we didn't create the driver, yet.
    CHECK(driver_ == nullptr);
    // If we use a swap file, ensure we are above the threshold to make it necessary.
    if (swap_fd_ != -1) {
      if (!UseSwap(IsBootImage(), dex_files_)) {
        close(swap_fd_);
        swap_fd_ = -1;
        VLOG(compiler) << "Decided to run without swap.";
      } else {
        LOG(INFO) << "Large app, accepted running with swap.";
      }
    }
    // Note that dex2oat won't close the swap_fd_. The compiler driver's swap space will do that.

    // If we need to downgrade the compiler-filter for size reasons, do that check now.
    if (!IsBootImage() && IsVeryLarge(dex_files_)) {
      if (!CompilerFilter::IsAsGoodAs(CompilerFilter::kExtract,
                                      compiler_options_->GetCompilerFilter())) {
        LOG(INFO) << "Very large app, downgrading to extract.";
        // Note: this change won't be reflected in the key-value store, as that had to be
        //       finalized before loading the dex files. This setup is currently required
        //       to get the size from the DexFile objects.
        // TODO: refactor. b/29790079
        compiler_options_->SetCompilerFilter(CompilerFilter::kExtract);
      }
    }

    if (IsBootImage()) {
      // For boot image, pass opened dex files to the Runtime::Create().
      // Note: Runtime acquires ownership of these dex files.
      runtime_options.Set(RuntimeArgumentMap::BootClassPathDexList, &opened_dex_files_);
      if (!CreateRuntime(std::move(runtime_options))) {
        return dex2oat::ReturnCode::kOther;
      }
    }

    // If we're doing the image, override the compiler filter to force full compilation. Must be
    // done ahead of WellKnownClasses::Init that causes verification.  Note: doesn't force
    // compilation of class initializers.
    // Whilst we're in native take the opportunity to initialize well known classes.
    Thread* self = Thread::Current();
    WellKnownClasses::Init(self->GetJniEnv());

    ClassLinker* const class_linker = Runtime::Current()->GetClassLinker();
    if (!IsBootImage()) {
      constexpr bool kSaveDexInput = false;
      if (kSaveDexInput) {
        SaveDexInput();
      }

      // Handle and ClassLoader creation needs to come after Runtime::Create.
      ScopedObjectAccess soa(self);

      // Classpath: first the class-path given.
      std::vector<const DexFile*> class_path_files = MakeNonOwningPointerVector(class_path_files_);

      // Then the dex files we'll compile. Thus we'll resolve the class-path first.
      class_path_files.insert(class_path_files.end(), dex_files_.begin(), dex_files_.end());

      class_loader_ = class_linker->CreatePathClassLoader(self, class_path_files);
    }

    // Ensure opened dex files are writable for dex-to-dex transformations.
    for (const std::unique_ptr<MemMap>& map : opened_dex_files_maps_) {
      if (!map->Protect(PROT_READ | PROT_WRITE)) {
        PLOG(ERROR) << "Failed to make .dex files writeable.";
        return dex2oat::ReturnCode::kOther;
      }
    }


    // 对dex文件进行遍历(脱壳点)
    for (const auto& dex_file : dex_files_) {
      ScopedObjectAccess soa(self);
      dex_caches_.push_back(soa.AddLocalReference<jobject>(
          class_linker->RegisterDexFile(*dex_file,
                                        soa.Decode<mirror::ClassLoader>(class_loader_).Ptr())));
      if (dex_caches_.back() == nullptr) {
        soa.Self()->AssertPendingException();
        soa.Self()->ClearException();
        PLOG(ERROR) << "Failed to register dex file.";
        return dex2oat::ReturnCode::kOther;
      }
      // Pre-register dex files so that we can access verification results without locks during
      // compilation and verification.
      verification_results_->AddDexFile(dex_file);
    }

    return dex2oat::ReturnCode::kNoFailure;
  }

```

