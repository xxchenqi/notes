# 逆向笔记

### dex魔数信息

```
64 65 78 0A 30 33 35 00
```



### 类加载器

Android系统中ClassLoader：

```
ClassLoader为抽象类；
BootClassLoader预加载常用类，单例模式。与Java中的BootClassLoader不同，它并不是由C/C++代码实现，而是由Java实现的；
BaseDexClassLoader是PathClassLoader、DexClassLoader、InMemoryDexClassLoader的父类，类加载的主要逻辑都是在BaseDexClassLoader完成的。
SecureClassLoader继承了抽象类ClassLoader，拓展了ClassLoader类加入了权限方面的功能，加强了安全性，其子类URLClassLoader是用URL路径从jar文件中加载类和资源。

PathClassLoader是Android默认使用的类加载器，一个apk中的Activity等类便是在其中加载。
DexClassLoader可以加载任意目录下的dex/jar/apk/zip文件，比PathClassLoader更灵活，是实现插件化、热修复以及dex加壳的重点。
Android8.0新引入InMemoryDexClassLoader，从名字便可看出是用于直接从内存中加载dex。
```

DexClassLoader方法参数：

```
dexPath:目标所在的apk或者jar文件的路径，装载器将从路径中寻找指定的目标类。
dexOutputDir:由于dex 文件在APK或者 jar文件中，所以在装载前面前先要从里面解压出dex文件，这个路径就是dex文件存放的路径，在 android系统中，一个应用程序对应一个linux用户id ,应用程序只对自己的数据目录有写的权限，所以我们存放在这个路径中。(odex存放路径)
libPath :目标类中使用的C/C++库。(so路径)
最后一个参数是该装载器的父装载器，一般为当前执行类的装载器。
```



### 加载插件dex并运行方法

```java
// testDexClassLoader(getApplicationContext(),"/sdcard/3.dex");
public void testDexClassLoader(Context context,String dexfilepath){
    // dex文件存放的路径
    File optfile=context.getDir("opt_dex",0);
    // 目标类中使用的C/C++库。
    File libfile=context.getDir("lib_path",0);
    DexClassLoader dexClassLoader=new DexClassLoader(dexfilepath, optfile.getAbsolutePath(), libfile.getAbsolutePath(), MainActivity.class.getClassLoader());
    Class<?> clazz=null;
    try {
        clazz = dexClassLoader.loadClass("com.cq.test.TestClass");
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
    if(clazz!=null){
        try {
            Method testFuncMethod=clazz.getDeclaredMethod("testFunc");
            Object obj=clazz.newInstance();
            testFuncMethod.invoke(obj);
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
    }
}
```



### 加载插件dex中的Activity

**注：插件中的activity需要在app的Androidmanifest中注册**



**为什么不能直接用DexClassLoader加载后跳转?**

动态加载的dex不具有生命周期特征，APP中的Activity、Service等组件无法正常工作，只能完成一般函数的调用;
需要对ClassLoader进行修正，APP才能够正常运行。



**两种解决方案**:

**1.反射替换**

替换系统组件类加载器为我们的DexClassLoader，同时设置DexClassLoader的parent为系统组件类加载器；



因为组件中是由LoadedApk中的classLoader加载，直接用会出现类找不到的问题

原理：(Android 8.0分析)

```java
class ActivityThread{
    // ActivityThread为单例模式
    private static volatile ActivityThread sCurrentActivityThread;
    // 反射获取
	final ArrayMap<String, WeakReference<LoadedApk>> mPackages = new ArrayMap<>();
}
```

```java
class LoadedApk {
    // 替换 ClassLoader
	private ClassLoader mClassLoader;
}
```



```java
public void startTestActivityFirstMethod(Context context,String dexfilepath){
    File optfile=context.getDir("opt_dex",0);
    File libfile=context.getDir("lib_path",0);
    DexClassLoader dexClassLoader=new DexClassLoader(dexfilepath,optfile.getAbsolutePath(),libfile.getAbsolutePath(),MainActivity.class.getClassLoader());

    replaceClassloader(dexClassLoader);

    Class<?> clazz=null;
    try {
        clazz = dexClassLoader.loadClass("com.cq.test02.TestActivity");
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
    context.startActivity(new Intent(context,clazz));
}

public void replaceClassloader(ClassLoader classloader){
    try {
        Class<?> ActivityThreadClazz=classloader.loadClass("android.app.ActivityThread");
        Method currentActivityThreadMethod= ActivityThreadClazz.getDeclaredMethod("currentActivityThread");
        currentActivityThreadMethod.setAccessible(true);
        Object activityThreadObj=currentActivityThreadMethod.invoke(null);
        //final ArrayMap<String, WeakReference<LoadedApk>> mPackages = new ArrayMap<>();
        Field mPackagesField=ActivityThreadClazz.getDeclaredField("mPackages");
        mPackagesField.setAccessible(true);
        ArrayMap mPackagesObj= (ArrayMap) mPackagesField.get(activityThreadObj);
        WeakReference wr= (WeakReference) mPackagesObj.get(this.getPackageName());
        Object loadedApkObj=wr.get();

        Class LoadedApkClazz=classloader.loadClass("android.app.LoadedApk");
        //private ClassLoader mClassLoader;
        Field mClassLoaderField=LoadedApkClazz.getDeclaredField("mClassLoader");
        mClassLoaderField.setAccessible(true);
        mClassLoaderField.set(loadedApkObj,classloader);
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } catch (NoSuchMethodException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (InvocationTargetException e) {
        e.printStackTrace();
    } catch (NoSuchFieldException e) {
        e.printStackTrace();
    }
}
```



**2.反射插入**

打破原有的双亲关系，在系统组件类加载器和BootClassLoader的中间插入我们自己的DexClassLoader即可；

```java
public void startTestActivitySecondMethod(Context context,String dexfilepath){
    File optfile=context.getDir("opt_dex",0);
    File libfile=context.getDir("lib_path",0);
    
	ClassLoader pathClassloader=MainActivity.class.getClassLoader();
	ClassLoader bootClassloader=MainActivity.class.getClassLoader().getParent();
    
    DexClassLoader dexClassLoader=new DexClassLoader(dexfilepath, optfile.getAbsolutePath(), libfile.getAbsolutePath(), bootClassloader);
    try {
        Field parentField=ClassLoader.class.getDeclaredField("parent");
        parentField.setAccessible(true);
        parentField.set(pathClassloader, dexClassLoader);
    } catch (NoSuchFieldException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    }

    Class<?> clazz=null;
    try {
        clazz = dexClassLoader.loadClass("com.cq.test02.TestActivity");
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
    context.startActivity(new Intent(context,clazz));
}
```



### 加壳应用的运行流程

```
App启动

(自定义application中的attachBaseContext方法实现)
解密源程序
初始化自定义类加载器
反射设置loadedApk中加载器对象为自定义类加载器

(自定义application中的onCreate方法实现)
获取源程序中的Application名称
反射生成正确的application对象
反射设置ActivityThread中的application信息

Activity加载流程源程序正常运行
```



### 壳技术分类

#### 壳史

**第一代壳:Dex加密**

1.Dex字符串加密

2.资源加密

3.对抗反编译

4.反调试

5.自定义DexClassLoader

缺点：在内存中的映射是连续的



**第二代壳：Dex抽取与So加固**

1.对抗第一代壳常见的脱壳法

2.Dex Method代码抽取到外部(通常企业版)

3.Dex动态加密

4.so加密

缺点：遍历Dex中的所有类去加载和初始化，这样在内存中就是完整的



**第三代壳：Dex动态解密与So混淆**

1.Dex Method代码动态解密

2.So代码膨胀混淆

3.对抗之前出现的所有脱壳法



**第四代壳：arm vmp(未来)**

vmp壳识别



**加固厂商特征:**
娜迦：libchaosvmp.so libddog.so libfdog.so

爱加密：libexec.so libexecmain.so

梆梆：libsecexe.so libsecmain.so libDexHelper.so

360：libprotectClass.so libiiagu.so

通付盾：libegis.so

网泰：libngshield.so

百度：libbaiduprotect.so



#### dex的加固技术发展

1、dex整体加固：文件加载和内存加载

通用方案：dex打开和优化的流程以及产出的odex、dex2oat编译的流程和生成的oat文件等等

2、函数抽取：在函数粒度完成代码的保护

(1)类加载和函数执行前的流程解密

(2)函数执行中动态自解密

方案：关注被抽取的函数的执行流程是关键，定位被抽取的函数的恢复时机即可

3、VMP和Dex2C：JAVA函数Native化

vmp：定位解释器是关键，找到映射关系便可恢复

dex2c：基础是编译原理，进行了等价语义转换，彻底还原难度巨大

通用解决方案：关注JNI相关的api调用是关键，也是分析vmp和dex2c保护的函数的逻辑的关键



#### so的加固种类

1、基于init、init_array以及JNI_Onload函数的加壳

2、基于自定义linker的加壳



#### 加固技术特征

- 函数抽取：获取到保护的dex后，函数体的内容是无效的，注意这里说的是无效，而不是无意义，有的app加壳后函数依然是有意义的，但不是我们想要的；

- VMP：获取到保护的dex后，函数的属性由java属性变为Native，典型的有数字的onCreate函数Native化；

  - ADVMP：https://github.com/chago/ADVMP

- dex2c：获取到保护的dex后，和VMP一样，被保护函数的属性由java属性变为Native，如开源的DCC (Dex-to-C Compiler)

- 混合型壳：多种加固技术混合使用，比如先将原有smali指令流使用VMP或dex2c保护，然后再经过函数抽取进一步保护




**如何区分VMP和Dex2c？**

vmp： 对于vmp保护都有一个共享解释器，注册地址是一样的

dex2c：对每个java函数进行语义分析，生成各自不同的C/C++代码，编译为相应的so,每一个dex2c保护的函数逻辑不一样，注册地址也就不一样

注：这里的注册地址指的是注册到JNI里的函数地址



### dex2oat基本概念

什么是dex2oat?

Dex2oat (dalvik excutable file to optimized art file) ，是一个对 dex 文件进行编译优化的程序，在我们的 Android 手机中的位置是 /system/bin/dex2oat，对应的源码路径为 android/art/dex2oat/dex2oat.cc，通过编译优化，可以提升用户日常的使用体验（包含安装速度、启动速度、应用使用过程中的流畅度等），是 Android Art Runtime 中的一个重要的模块



为什么要进行dex2oat转换？

众所周知， Android 虚拟机可以识别的是dex文件，应用使用过程中如果每次将dex文件加载进行内存，解释性执行字节码，效率会很低， 严重影响用户体验。通过dex2oat 优化后， 可以在系统运行之前利用合适的时机将dex文件字节码提前转化为虚拟机可以执行运行的机器码，后续直接从效率更高的机器码中运行，则运行阶段更加流畅，优化用户体验。



### Dalvik下DexClassLoader加载dex源码流程分析(4.4)

[BaseDexClassLoader.java](http://androidxref.com/4.4.4_r1/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java)

```java
public BaseDexClassLoader(ByteBuffer[] dexFiles, ClassLoader parent) {
     super(parent);
     this.pathList = new DexPathList(this, dexFiles);
}
```

[DexPathList.java](http://androidxref.com/4.4.4_r1/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java)

```java
public DexPathList(ClassLoader definingContext, String dexPath, String librarySearchPath, File optimizedDirectory) {
	this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions, definingContext);
}

private static Element[] makeDexElements(List<File> files, File optimizedDirectory, List<IOException> suppressedExceptions, ClassLoader loader) {
	 DexFile dex = loadDexFile(file, optimizedDirectory, loader, elements);
}

private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader, Element[] elements){
	return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements);
}
```

[DexFile.java](http://androidxref.com/4.4.4_r1/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java)

```java
static DexFile loadDex(String sourcePathName, String outputPathName, int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException {
	return new DexFile(sourcePathName, outputPathName, flags, loader, elements);   
}

private DexFile(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException {
	mCookie = openDexFile(sourceName, outputName, flags, loader, elements);
}


private static Object openDexFile(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException {
	return openDexFileNative(new File(sourceName).getAbsolutePath(), (outputName == null) ? null : new File(outputName).getAbsolutePath(), flags, loader, elements);
}
```

[dalvik_system_DexFile.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/native/dalvik_system_DexFile.cpp)

```c++
static void Dalvik_dalvik_system_DexFile_openDexFileNative(const u4* args, JValue* pResult) {
	 if (hasDexExtension(sourceName) && dvmRawDexFileOpen(sourceName, outputName, &pRawDexFile, false) == 0) 
     {
     }
}
```

[RawDexFile.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/RawDexFile.cpp)

```cpp
int dvmRawDexFileOpen(const char* fileName, const char* odexOutputName,  RawDexFile** ppRawDexFile, bool isBootstrap)
{
    // 打开dex文件
    dexFd = open(fileName, O_RDONLY);
    // 对dex文件魔术校验
    if (verifyMagicAndGetAdler32(dexFd, &adler32) < 0) {
        ALOGE("Error with header for %s", fileName);
        goto bail;
    }
    // 生成odex文件
    if (odexOutputName == NULL) {
        cachedName = dexOptGenerateCacheFileName(fileName, NULL);
        if (cachedName == NULL)
            goto bail;
    } else {
        cachedName = strdup(odexOutputName);
    }
	
    // dex优化流程
    if (result) {
        result = dvmOptimizeDexFile(optFd, dexOffset, fileSize,
            fileName, modTime, adler32, isBootstrap);
    }
    
}
```

[DexPrepare.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/analysis/DexPrepare.cpp)

```cpp
// fd 打开文件id ， dexLength文件大小
bool dvmOptimizeDexFile(int fd, off_t dexOffset, long dexLength, const char* fileName, u4 modWhen, u4 crc, bool isBootstrap)
{
    // 新建子进程对当前dex文件进行优化
    pid = fork();
    if (pid == 0) {
        static const char* kDexOptBin = "/bin/dexopt";
    }
}
```

[OptMain.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/dexopt/OptMain.cpp)

```cpp
// 主入口
int main(int argc, char* const argv[])
{
    if (strcmp(argv[1], "--dex") == 0)
    	return fromDex(argc, argv);
}


static int fromDex(int argc, char* const argv[])
{
    // 环境准备阶段
	if (dvmPrepForDexOpt(bootClassPath, dexOptMode, verifyMode, flags) != 0) {
        ALOGE("VM init failed");
        goto bail;
    }   
    
    // 优化
    if (!dvmContinueOptimization(fd, offset, length, debugFileName, modWhen, crc, (flags & DEXOPT_IS_BOOTSTRAP) != 0))
    {
        ALOGE("Optimization failed");
        goto bail;
    }
}
```

[DexPrepare.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/analysis/DexPrepare.cpp)

```cpp
bool dvmContinueOptimization(int fd, off_t dexOffset, long dexLength, const char* fileName, u4 modWhen, u4 crc, bool isBootstrap)
{
    // 对dex当前内容进行内存映射
	mapAddr = mmap(NULL, dexOffset + dexLength, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);    
    // hook
    
    // 对dex进行重写
    success = rewriteDex(((u1*) mapAddr) + dexOffset, dexLength, doVerify, doOpt, &pClassLookup, NULL);
}

// addr 加载到内存的起始地址， len 字节数
static bool rewriteDex(u1* addr, int len, bool doVerify, bool doOpt, DexClassLookup** ppClassLookup, DvmDex** ppDvmDex)
{
    // hook
    if (dvmDexFileOpenPartial(addr, len, &pDvmDex) != 0) {
        ALOGE("Unable to create DexFile");
        goto bail;
    }
}
```

[DvmDex.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/DvmDex.cpp)

```cpp
int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex)
{
    // hook
    pDexFile = dexFileParse((u1*)addr, len, parseFlags);
}
```





#### 修改脱壳：

[DvmDex.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/DvmDex.cpp)

```cpp
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex)
{
    // 保存路径
	char dexfilepath[100]={0};
    // 进程号
	int pid=getpid();
    // 文件路径拼接
	sprintf(dexfilepath,"/sdcard/%d_%d_dvmDexFileOpenPartial.dex",len,pid);
    // 很多壳为了对抗内存dump,会将标准fopen等函数hook掉，所以避免使用标准文件读写函数导致内存dump不下来的问题
	int fd=open(dexfilepath, O_CREAT|O_RDWR, 0666);
	if(fd > 0)
	{
		write(fd,addr,len);
		close(fd);
	}

	// ...
	
    return result;
}

```

[DexFile.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/libdex/DexFile.cpp)

```cpp
DexFile* dexFileParse(const u1* data, size_t length, int flags)
{
	char dexfilepath[100]={0};
	int pid=getpid();
	sprintf(dexfilepath,"/sdcard/%d_%d_dexFileParse.dex",length,pid);
	int fd=open(dexfilepath,O_CREAT|O_RDWR,0666);
	if(fd > 0)
	{
		write(fd,addr,len);
		close(fd);
	}
}
```



[DexPrepare.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/analysis/DexPrepare.cpp)

```cpp
// so需要修正,删除前面的数据
bool dvmContinueOptimization(int fd, off_t dexOffset, long dexLength,
    const char* fileName, u4 modWhen, u4 crc, bool isBootstrap)
{
	mapAddr = mmap(NULL, dexOffset + dexLength, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);

	char dexfilepath[100]={0};
	int pid=getpid();
	sprintf(dexfilepath,"/sdcard/%ld_%d_dvmContinueOptimization.dex",dexLength,pid);
	int fd=open(dexfilepath,O_CREAT|O_RDWR,0666);
	if(fd > 0)
	{
		write(fd, mapAddr, dexOffset + dexLength);
		close(fd);
	}
}


static bool rewriteDex(u1* addr, int len, bool doVerify, bool doOpt, DexClassLookup** ppClassLookup, DvmDex** ppDvmDex)
{
	char dexfilepath[100]={0};
	int pid=getpid();
	sprintf(dexfilepath,"/sdcard/%d_%d_rewriteDex.dex",len,pid);
	int fd=open(dexfilepath,O_CREAT|O_RDWR,0666);
	if(fd>0)
	{
		write(fd, addr, len);
		close(fd);
	}
}
```

DexSwapVerify

```cpp
int dexSwapAndVerify(u1* addr, int len)
{
	char dexfilepath[100]={0};
    int pid=getpid();
    sprintf(dexfilepath,"/sdcard/%d_%d_dexSwapAndVerify.dex",len,pid);
    int fd=open(dexfilepath,O_CREAT|O_RDWR,0666);
    if(fd>0)
    {
		write(fd,addr,len);
		close(fd);
	}
}
```



#### 通用脱壳点：

dexFileParse、dvmDexFileOpenPartial脱壳点验证





### ART下一代壳通用解决方案(8.0)

#### InMemoryDexClassLoader流程分析

[InMemoryDexClassLoader.java](http://androidxref.com/8.0.0_r4/xref/libcore/dalvik/src/main/java/dalvik/system/InMemoryDexClassLoader.java)

```java
public InMemoryDexClassLoader(ByteBuffer[] dexBuffers, ClassLoader parent) {
	super(dexBuffers, parent);
}
```

[BaseDexClassLoader.java](http://androidxref.com/8.0.0_r4/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java)

```
public BaseDexClassLoader(ByteBuffer[] dexFiles, ClassLoader parent) {
	super(parent);
	this.pathList = new DexPathList(this, dexFiles);
}
```

[DexPathList.java](http://androidxref.com/8.0.0_r4/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java)

```java
public DexPathList(ClassLoader definingContext, ByteBuffer[] dexFiles) {
	this.dexElements = makeInMemoryDexElements(dexFiles, suppressedExceptions);
}

private static Element[] makeInMemoryDexElements(ByteBuffer[] dexFiles, List<IOException> suppressedExceptions) {
    Element[] elements = new Element[dexFiles.length];
    int elementPos = 0;
    for (ByteBuffer buf : dexFiles) {
        try {
            DexFile dex = new DexFile(buf);
            elements[elementPos++] = new Element(dex);
        } catch (IOException suppressed) {
            System.logE("Unable to load dex file: " + buf, suppressed);
            suppressedExceptions.add(suppressed);
        }
    }
	return elements;
}
```

[DexFile.java](http://androidxref.com/8.0.0_r4/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java)

```java
DexFile(ByteBuffer buf) throws IOException {
	mCookie = openInMemoryDexFile(buf);
	mInternalCookie = mCookie;
	mFileName = null;
}

private static Object openInMemoryDexFile(ByteBuffer buf) throws IOException {
    if (buf.isDirect()) {
        return createCookieWithDirectBuffer(buf, buf.position(), buf.limit());
    } else {
        return createCookieWithArray(buf.array(), buf.position(), buf.limit());
    }
}

```

[dalvik_system_DexFile.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/native/dalvik_system_DexFile.cc)

```cpp
static jobject DexFile_createCookieWithDirectBuffer(JNIEnv* env, jclass, jobject buffer, jint start, jint end) {
	// ...
	memcpy(dex_mem_map->Begin(), base_address, length);
	return CreateSingleDexFileCookie(env, std::move(dex_mem_map));
}

static jobject DexFile_createCookieWithArray(JNIEnv* env, jclass, jbyteArray buffer, jint start, jint end) {
	// ...
	return CreateSingleDexFileCookie(env, std::move(dex_mem_map));
}

static jobject CreateSingleDexFileCookie(JNIEnv* env, std::unique_ptr<MemMap> data) {
  std::unique_ptr<const DexFile> dex_file(CreateDexFile(env, std::move(data)));
  std::vector<std::unique_ptr<const DexFile>> dex_files;
  dex_files.push_back(std::move(dex_file));
  return ConvertDexFilesToJavaArray(env, nullptr, dex_files);
}


static const DexFile* CreateDexFile(JNIEnv* env, std::unique_ptr<MemMap> dex_mem_map) {
  std::string location = StringPrintf("Anonymous-DexFile@%p-%p", dex_mem_map->Begin(), dex_mem_map->End());
  std::unique_ptr<const DexFile> dex_file(DexFile::Open(location, 0, std::move(dex_mem_map), 
                                                        /* verify */ true, /* verify_location */ true, &error_message));

  return dex_file.release();
}
```



[dex_file.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/dex_file.cc)

```cpp
std::unique_ptr<const DexFile> DexFile::Open(const std::string& location,
                                             uint32_t location_checksum,
                                             std::unique_ptr<MemMap> map,
                                             bool verify,
                                             bool verify_checksum,
                                             std::string* error_msg) {


  std::unique_ptr<DexFile> dex_file = OpenCommon(map->Begin(),
                                                 map->Size(),
                                                 location,
                                                 location_checksum,
                                                 kNoOatDexFile,
                                                 verify,
                                                 verify_checksum,
                                                 error_msg);
  
  return dex_file;
}


std::unique_ptr<DexFile> DexFile::OpenCommon(const uint8_t* base, size_t size, const std::string& location,
                                             uint32_t location_checksum, const OatDexFile* oat_dex_file,
                                             bool verify, bool verify_checksum, std::string* error_msg,
                                             VerifyResult* verify_result) {

  std::unique_ptr<DexFile> dex_file(new DexFile(base,
                                                size,
                                                location,
                                                location_checksum,
                                                oat_dex_file));
 
  return dex_file;
}


DexFile::DexFile(const uint8_t* base,
                 size_t size,
                 const std::string& location,
                 uint32_t location_checksum,
                 const OatDexFile* oat_dex_file)
    : begin_(base),
      size_(size),
      location_(location),
      location_checksum_(location_checksum),
      header_(reinterpret_cast<const Header*>(base)),
      string_ids_(reinterpret_cast<const StringId*>(base + header_->string_ids_off_)),
      type_ids_(reinterpret_cast<const TypeId*>(base + header_->type_ids_off_)),
      field_ids_(reinterpret_cast<const FieldId*>(base + header_->field_ids_off_)),
      method_ids_(reinterpret_cast<const MethodId*>(base + header_->method_ids_off_)),
      proto_ids_(reinterpret_cast<const ProtoId*>(base + header_->proto_ids_off_)),
      class_defs_(reinterpret_cast<const ClassDef*>(base + header_->class_defs_off_)),
      method_handles_(nullptr),
      num_method_handles_(0),
      call_site_ids_(nullptr),
      num_call_site_ids_(0),
      oat_dex_file_(oat_dex_file) {
  CHECK(begin_ != nullptr) << GetLocation();
  CHECK_GT(size_, 0U) << GetLocation();
  // Check base (=header) alignment.
  // Must be 4-byte aligned to avoid undefined behavior when accessing
  // any of the sections via a pointer.
  CHECK_ALIGNED(begin_, alignof(Header));

  InitializeSectionsFromMapList();
}
```



InMemoryDexClassLoader没有对内存中dex编译生成oat文件



#### DexClassLoader流程分析

前面步骤和davilk一样

[dalvik_system_DexFile.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/native/dalvik_system_DexFile.cc)

```cpp
static jobject DexFile_openDexFileNative(JNIEnv* env,
                                         jclass,
                                         jstring javaSourceName,
                                         jstring javaOutputName ATTRIBUTE_UNUSED,
                                         jint flags ATTRIBUTE_UNUSED,
                                         jobject class_loader,
                                         jobjectArray dex_elements) {


  Runtime* const runtime = Runtime::Current();
  ClassLinker* linker = runtime->GetClassLinker();
  std::vector<std::unique_ptr<const DexFile>> dex_files;
  std::vector<std::string> error_msgs;
  const OatFile* oat_file = nullptr;

  dex_files = runtime->GetOatFileManager().OpenDexFilesFromOat(sourceName.c_str(),
                                                               class_loader,
                                                               dex_elements,
                                                               /*out*/ &oat_file,
                                                               /*out*/ &error_msgs);

  if (!dex_files.empty()) {
    jlongArray array = ConvertDexFilesToJavaArray(env, oat_file, dex_files);
    if (array == nullptr) {
      ScopedObjectAccess soa(env);
      for (auto& dex_file : dex_files) {
        if (linker->IsDexFileRegistered(soa.Self(), *dex_file)) {
          dex_file.release();
        }
      }
    }
    return array;
  } else {
    ScopedObjectAccess soa(env);
    CHECK(!error_msgs.empty());
    // The most important message is at the end. So set up nesting by going forward, which will
    // wrap the existing exception as a cause for the following one.
    auto it = error_msgs.begin();
    auto itEnd = error_msgs.end();
    for ( ; it != itEnd; ++it) {
      ThrowWrappedIOException("%s", it->c_str());
    }

    return nullptr;
  }
}
```



[oat_file_manager.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/oat_file_manager.cc)

```cpp
std::vector<std::unique_ptr<const DexFile>> OatFileManager::OpenDexFilesFromOat(
    const char* dex_location,
    jobject class_loader,
    jobjectArray dex_elements,
    const OatFile** out_oat_file,
    std::vector<std::string>* error_msgs) {

  Thread* const self = Thread::Current();
  Locks::mutator_lock_->AssertNotHeld(self);
  Runtime* const runtime = Runtime::Current();

  // 新建oat对象
  OatFileAssistant oat_file_assistant(dex_location,
                                      kRuntimeISA,
                                      !runtime->IsAotCompiler());

  const OatFile* source_oat_file = nullptr;
  
  if (!oat_file_assistant.IsUpToDate()) {
      // oat流程
    switch (oat_file_assistant.MakeUpToDate(/*profile_changed*/false, /*out*/ &error_msg)) {
      case OatFileAssistant::kUpdateFailed:
        LOG(WARNING) << error_msg;
        break;

      case OatFileAssistant::kUpdateNotAttempted:
        VLOG(oat) << error_msg;
        break;
      case OatFileAssistant::kUpdateSucceeded:
        break;
    }
  }

  // ...
  if (dex_files.empty()) {
    // 如果阻断了dex2oat流程,就会执行到这里尝试加载dex
    if (oat_file_assistant.HasOriginalDexFiles()) {
      if (Runtime::Current()->IsDexFileFallbackEnabled()) {
        static constexpr bool kVerifyChecksum = true;
        if (!DexFile::Open(
            dex_location, dex_location, kVerifyChecksum, /*out*/ &error_msg, &dex_files)) {
        }
      }
    }
  }
  return dex_files;
}
```

[oat_file_assistant.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/oat_file_assistant.cc)

```cpp
OatFileAssistant::MakeUpToDate(bool profile_changed, std::string* error_msg) {
  CompilerFilter::Filter target;
  OatFileInfo& info = GetBestInfo();
  switch (info.GetDexOptNeeded(target, profile_changed)) {
    case kNoDexOptNeeded:
      return kUpdateSucceeded;

    case kDex2OatFromScratch:
    case kDex2OatForBootImage:
    case kDex2OatForRelocation:
    case kDex2OatForFilter:
      return GenerateOatFileNoChecks(info, target, error_msg);
  }
  UNREACHABLE();
}


OatFileAssistant::ResultOfAttemptToUpdate OatFileAssistant::GenerateOatFileNoChecks(
      OatFileAssistant::OatFileInfo& info, CompilerFilter::Filter filter, std::string* error_msg) {
  CHECK(error_msg != nullptr);

  Runtime* runtime = Runtime::Current();
  if (!runtime->IsDex2OatEnabled()) {
    *error_msg = "Generation of oat file for dex location " + dex_location_
      + " not attempted because dex2oat is disabled.";
    return kUpdateNotAttempted;
  }


  if (!Dex2Oat(args, error_msg)) {
    vdex_file->Erase();
    unlink(vdex_file_name.c_str());
    oat_file->Erase();
    unlink(oat_file_name.c_str());
    return kUpdateFailed;
  }
    
  info.Reset();
  return kUpdateSucceeded;
}


bool OatFileAssistant::Dex2Oat(const std::vector<std::string>& args,
                               std::string* error_msg) {
  // ...
  return Exec(argv, error_msg);
}
```

[exec_utils.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/exec_utils.cc)

```cpp
bool Exec(std::vector<std::string>& arg_vector, std::string* error_msg) {
  int status = ExecAndReturnCode(arg_vector, error_msg);
  if (status != 0) {
    const std::string command_line(android::base::Join(arg_vector, ' '));
    *error_msg = StringPrintf("Failed execv(%s) because non-0 exit status",
                              command_line.c_str());
    return false;
  }
  return true;
}

int ExecAndReturnCode(std::vector<std::string>& arg_vector, std::string* error_msg) {
  const std::string command_line(android::base::Join(arg_vector, ' '));
  CHECK_GE(arg_vector.size(), 1U) << command_line;

  // Convert the args to char pointers.
  const char* program = arg_vector[0].c_str();
  std::vector<char*> args;
  for (size_t i = 0; i < arg_vector.size(); ++i) {
    const std::string& arg = arg_vector[i];
    char* arg_str = const_cast<char*>(arg.c_str());
    CHECK(arg_str != nullptr) << i;
    args.push_back(arg_str);
  }
  args.push_back(nullptr);

  // fork and exec
  pid_t pid = fork();
  if (pid == 0) {
    setpgid(0, 0);

    char** envp = (Runtime::Current() == nullptr) ? nullptr : Runtime::Current()->GetEnvSnapshot();
    if (envp == nullptr) {
      execv(program, &args[0]);
    } else {
      // 通过这个函数执行dex2oat 编译过程
      execve(program, &args[0], envp);
    }
  } 
}

```

对这些函数hook会导致dex2oat流程结束。

强制结束dex2oat流程对ClassLoader第一次加载dex非常快速。

要想实现ART下的函数抽取技术也是需要阻断dex2oat流程。

dalvik是不存在dex2oat的流程，这也是和dalvik的区别。





#### dex2oat阻断后调用流程

[oat_file_manager.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/oat_file_manager.cc)

```cpp
std::vector<std::unique_ptr<const DexFile>> OatFileManager::OpenDexFilesFromOat(
    const char* dex_location,
    jobject class_loader,
    jobjectArray dex_elements,
    const OatFile** out_oat_file,
    std::vector<std::string>* error_msgs) {

  Thread* const self = Thread::Current();
  Locks::mutator_lock_->AssertNotHeld(self);
  Runtime* const runtime = Runtime::Current();

  // 新建oat对象
  OatFileAssistant oat_file_assistant(dex_location,
                                      kRuntimeISA,
                                      !runtime->IsAotCompiler());

  const OatFile* source_oat_file = nullptr;
  
  if (!oat_file_assistant.IsUpToDate()) {
      // oat流程
    switch (oat_file_assistant.MakeUpToDate(/*profile_changed*/false, /*out*/ &error_msg)) {
      case OatFileAssistant::kUpdateFailed:
        LOG(WARNING) << error_msg;
        break;

      case OatFileAssistant::kUpdateNotAttempted:
        VLOG(oat) << error_msg;
        break;
      case OatFileAssistant::kUpdateSucceeded:
        break;
    }
  }

  // ...
  if (dex_files.empty()) {
    // 如果阻断了dex2oat流程,就会执行到这里尝试加载dex
    if (oat_file_assistant.HasOriginalDexFiles()) {
      if (Runtime::Current()->IsDexFileFallbackEnabled()) {
        static constexpr bool kVerifyChecksum = true;
        if (!DexFile::Open(
            dex_location, dex_location, kVerifyChecksum, /*out*/ &error_msg, &dex_files)) {
        }
      }
    }
  }
  return dex_files;
}
```



[dex_file.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/dex_file.cc)

```c++
bool DexFile::Open(const char* filename,
                   const std::string& location,
                   bool verify_checksum,
                   std::string* error_msg,
                   std::vector<std::unique_ptr<const DexFile>>* dex_files) {
  uint32_t magic;
  // hook
  File fd = OpenAndReadMagic(filename, &magic, error_msg);
  if (fd.Fd() == -1) {
    DCHECK(!error_msg->empty());
    return false;
  }
  if (IsZipMagic(magic)) {
    return DexFile::OpenZip(fd.Release(), location, verify_checksum, error_msg, dex_files);
  }
  if (IsDexMagic(magic)) {
    std::unique_ptr<const DexFile> dex_file(DexFile::OpenFile(fd.Release(),
                                                              location,
                                                              /* verify */ true,
                                                              verify_checksum,
                                                              error_msg));
    if (dex_file.get() != nullptr) {
      dex_files->push_back(std::move(dex_file));
      return true;
    } else {
      return false;
    }
  }
  return false;
}



std::unique_ptr<const DexFile> DexFile::OpenFile(int fd,
                                                 const std::string& location,
                                                 bool verify,
                                                 bool verify_checksum,
                                                 std::string* error_msg) {

  std::unique_ptr<MemMap> map;
  {
    File delayed_close(fd, /* check_usage */ false);
    struct stat sbuf;
    memset(&sbuf, 0, sizeof(sbuf));
    size_t length = sbuf.st_size;
    map.reset(MemMap::MapFile(length,
                              PROT_READ,
                              MAP_PRIVATE,
                              fd,
                              0,
                              /*low_4gb*/false,
                              location.c_str(),
                              error_msg));
  }

  const Header* dex_header = reinterpret_cast<const Header*>(map->Begin());

  std::unique_ptr<DexFile> dex_file = OpenCommon(map->Begin(),
                                                 map->Size(),
                                                 location,
                                                 dex_header->checksum_,
                                                 kNoOatDexFile,
                                                 verify,
                                                 verify_checksum,
                                                 error_msg);
  if (dex_file != nullptr) {
    dex_file->mem_map_.reset(map.release());
  }

  return dex_file;
}


// 此处就和InMemoryDexClassLoader分析的流程重合了
std::unique_ptr<DexFile> DexFile::OpenCommon(const uint8_t* base,
                                             size_t size,
                                             const std::string& location,
                                             uint32_t location_checksum,
                                             const OatDexFile* oat_dex_file,
                                             bool verify,
                                             bool verify_checksum,
                                             std::string* error_msg,
                                             VerifyResult* verify_result) {
  // hook
  std::unique_ptr<DexFile> dex_file(new DexFile(base,
                                                size,
                                                location,
                                                location_checksum,
                                                oat_dex_file));
  
  return dex_file;
}
```





#### 推荐脱壳点

[dex_file.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/dex_file.cc)

```cpp
std::unique_ptr<DexFile> DexFile::OpenCommon(const uint8_t* base,
                                             size_t size,
                                             const std::string& location,
                                             uint32_t location_checksum,
                                             const OatDexFile* oat_dex_file,
                                             bool verify,
                                             bool verify_checksum,
                                             std::string* error_msg,
                                             VerifyResult* verify_result) {
  if (verify_result != nullptr) {
    *verify_result = VerifyResult::kVerifyNotAttempted;
  }

  int pid=getpid();
  char dexfilepath[100]={0};
  sprintf(dexfilepath,"/sdcard/%d_%d_OpenCommon.dex",(int)size,pid);
  
  int fd=open(dexfilepath,O_CREAT|O_RDWR,666);
  if (fd>0){
	  int number=write(fd,base,size);
	  if(number>0) {
          
      }
	  close(fd);
  }  
  
  
  
  std::unique_ptr<DexFile> dex_file(new DexFile(base,
                                                size,
                                                location,
                                                location_checksum,
                                                oat_dex_file));
}



DexFile::DexFile(const uint8_t* base,
                 size_t size,
                 const std::string& location,
                 uint32_t location_checksum,
                 const OatDexFile* oat_dex_file)
    : begin_(base),
      size_(size),
      location_(location),
      location_checksum_(location_checksum),
      header_(reinterpret_cast<const Header*>(base)),
      string_ids_(reinterpret_cast<const StringId*>(base + header_->string_ids_off_)),
      type_ids_(reinterpret_cast<const TypeId*>(base + header_->type_ids_off_)),
      field_ids_(reinterpret_cast<const FieldId*>(base + header_->field_ids_off_)),
      method_ids_(reinterpret_cast<const MethodId*>(base + header_->method_ids_off_)),
      proto_ids_(reinterpret_cast<const ProtoId*>(base + header_->proto_ids_off_)),
      class_defs_(reinterpret_cast<const ClassDef*>(base + header_->class_defs_off_)),
      method_handles_(nullptr),
      num_method_handles_(0),
      call_site_ids_(nullptr),
      num_call_site_ids_(0),
      oat_dex_file_(oat_dex_file) {
  CHECK(begin_ != nullptr) << GetLocation();
  CHECK_GT(size_, 0U) << GetLocation();
  CHECK_ALIGNED(begin_, alignof(Header));
          
  int pid=getpid();
  char dexfilepath[100]={0};
  sprintf(dexfilepath,"/sdcard/%d_%d_DexFile.dex",(int)size,pid);
  
  int fd=open(dexfilepath,O_CREAT|O_RDWR,666);
  if (fd>0){
	  int number=write(fd,base,size);
	  if(number>0) {
	  }
	  close(fd);
  } 
  InitializeSectionsFromMapList();
}
```



#### dex2oat流程分析

[dex2oat.cc](http://androidxref.com/8.0.0_r4/xref/art/dex2oat/dex2oat.cc)

```cpp
int main(int argc, char** argv) {
  int result = static_cast<int>(art::Dex2oat(argc, argv));
  if (!art::kIsDebugBuild && (RUNNING_ON_MEMORY_TOOL == 0)) {
    _exit(result);
  }
  return result;
}


static dex2oat::ReturnCode Dex2oat(int argc, char** argv) {
  b13564922();

  TimingLogger timings("compiler", false, false);

  // Allocate `dex2oat` on the heap instead of on the stack, as Clang
  // might produce a stack frame too large for this function or for
  // functions inlining it (such as main), that would not fit the
  // requirements of the `-Wframe-larger-than` option.
  std::unique_ptr<Dex2Oat> dex2oat = MakeUnique<Dex2Oat>(&timings);

  // Parse arguments. Argument mistakes will lead to exit(EXIT_FAILURE) in UsageError.
  dex2oat->ParseArgs(argc, argv);

  // If needed, process profile information for profile guided compilation.
  // This operation involves I/O.
  if (dex2oat->UseProfile()) {
    if (!dex2oat->LoadProfile()) {
      LOG(ERROR) << "Failed to process profile file";
      return dex2oat::ReturnCode::kOther;
    }
  }

  art::MemMap::Init();  // For ZipEntry::ExtractToMemMap, and vdex.

  // Check early that the result of compilation can be written
  if (!dex2oat->OpenFile()) {
    return dex2oat::ReturnCode::kOther;
  }

  // Print the complete line when any of the following is true:
  //   1) Debug build
  //   2) Compiling an image
  //   3) Compiling with --host
  //   4) Compiling on the host (not a target build)
  // Otherwise, print a stripped command line.
  if (kIsDebugBuild || dex2oat->IsBootImage() || dex2oat->IsHost() || !kIsTargetBuild) {
    LOG(INFO) << CommandLine();
  } else {
    LOG(INFO) << StrippedCommandLine();
  }

  dex2oat::ReturnCode setup_code = dex2oat->Setup();
  if (setup_code != dex2oat::ReturnCode::kNoFailure) {
    dex2oat->EraseOutputFiles();
    return setup_code;
  }

  // Helps debugging on device. Can be used to determine which dalvikvm instance invoked a dex2oat
  // instance. Used by tools/bisection_search/bisection_search.py.
  VLOG(compiler) << "Running dex2oat (parent PID = " << getppid() << ")";

  dex2oat::ReturnCode result;
  if (dex2oat->IsImage()) {
    result = CompileImage(*dex2oat);
  } else {
    result = CompileApp(*dex2oat);
  }

  dex2oat->Shutdown();
  return result;
}
```



```cpp
  dex2oat::ReturnCode Setup() {
    if (!PrepareImageClasses() || !PrepareCompiledClasses() || !PrepareCompiledMethods()) {
      return dex2oat::ReturnCode::kOther;
    }

    verification_results_.reset(new VerificationResults(compiler_options_.get()));
    callbacks_.reset(new QuickCompilerCallbacks(
        verification_results_.get(),
        IsBootImage() ?
            CompilerCallbacks::CallbackMode::kCompileBootImage :
            CompilerCallbacks::CallbackMode::kCompileApp));

    RuntimeArgumentMap runtime_options;
    if (!PrepareRuntimeOptions(&runtime_options)) {
      return dex2oat::ReturnCode::kOther;
    }

    CreateOatWriters();
    if (!AddDexFileSources()) {
      return dex2oat::ReturnCode::kOther;
    }

    if (IsBootImage() && image_filenames_.size() > 1) {
      // If we're compiling the boot image, store the boot classpath into the Key-Value store.
      // We need this for the multi-image case.
      key_value_store_->Put(OatHeader::kBootClassPathKey,
                            gc::space::ImageSpace::GetMultiImageBootClassPath(dex_locations_,
                                                                              oat_filenames_,
                                                                              image_filenames_));
    }

    if (!IsBootImage()) {
      // When compiling an app, create the runtime early to retrieve
      // the image location key needed for the oat header.
      if (!CreateRuntime(std::move(runtime_options))) {
        return dex2oat::ReturnCode::kCreateRuntime;
      }

      if (CompilerFilter::DependsOnImageChecksum(compiler_options_->GetCompilerFilter())) {
        TimingLogger::ScopedTiming t3("Loading image checksum", timings_);
        std::vector<gc::space::ImageSpace*> image_spaces =
            Runtime::Current()->GetHeap()->GetBootImageSpaces();
        image_file_location_oat_checksum_ = image_spaces[0]->GetImageHeader().GetOatChecksum();
        image_file_location_oat_data_begin_ =
            reinterpret_cast<uintptr_t>(image_spaces[0]->GetImageHeader().GetOatDataBegin());
        image_patch_delta_ = image_spaces[0]->GetImageHeader().GetPatchDelta();
        // Store the boot image filename(s).
        std::vector<std::string> image_filenames;
        for (const gc::space::ImageSpace* image_space : image_spaces) {
          image_filenames.push_back(image_space->GetImageFilename());
        }
        std::string image_file_location = android::base::Join(image_filenames, ':');
        if (!image_file_location.empty()) {
          key_value_store_->Put(OatHeader::kImageLocationKey, image_file_location);
        }
      } else {
        image_file_location_oat_checksum_ = 0u;
        image_file_location_oat_data_begin_ = 0u;
        image_patch_delta_ = 0;
      }

      // Open dex files for class path.
      std::vector<std::string> class_path_locations =
          GetClassPathLocations(runtime_->GetClassPathString());
      OpenClassPathFiles(class_path_locations,
                         &class_path_files_,
                         &opened_oat_files_,
                         runtime_->GetInstructionSet(),
                         classpath_dir_);

      // Store the classpath we have right now.
      std::vector<const DexFile*> class_path_files = MakeNonOwningPointerVector(class_path_files_);
      std::string encoded_class_path;
      if (class_path_locations.size() == 1 &&
          class_path_locations[0] == OatFile::kSpecialSharedLibrary) {
        // When passing the special shared library as the classpath, it is the only path.
        encoded_class_path = OatFile::kSpecialSharedLibrary;
      } else {
        encoded_class_path = OatFile::EncodeDexFileDependencies(class_path_files, classpath_dir_);
      }
      key_value_store_->Put(OatHeader::kClassPathKey, encoded_class_path);
    }

    // Now that we have finalized key_value_store_, start writing the oat file.
    {
      TimingLogger::ScopedTiming t_dex("Writing and opening dex files", timings_);
      rodata_.reserve(oat_writers_.size());
      for (size_t i = 0, size = oat_writers_.size(); i != size; ++i) {
        rodata_.push_back(elf_writers_[i]->StartRoData());
        // Unzip or copy dex files straight to the oat file.
        std::unique_ptr<MemMap> opened_dex_files_map;
        std::vector<std::unique_ptr<const DexFile>> opened_dex_files;
        // No need to verify the dex file for:
        // 1) Dexlayout since it does the verification. It also may not pass the verification since
        // we don't update the dex checksum.
        // 2) when we have a vdex file, which means it was already verified.
        const bool verify = !DoDexLayoutOptimizations() && (input_vdex_file_ == nullptr);
        if (!oat_writers_[i]->WriteAndOpenDexFiles(
            kIsVdexEnabled ? vdex_files_[i].get() : oat_files_[i].get(),
            rodata_.back(),
            instruction_set_,
            instruction_set_features_.get(),
            key_value_store_.get(),
            verify,
            update_input_vdex_,
            &opened_dex_files_map,
            &opened_dex_files)) {
          return dex2oat::ReturnCode::kOther;
        }
        dex_files_per_oat_file_.push_back(MakeNonOwningPointerVector(opened_dex_files));
        if (opened_dex_files_map != nullptr) {
          opened_dex_files_maps_.push_back(std::move(opened_dex_files_map));
          for (std::unique_ptr<const DexFile>& dex_file : opened_dex_files) {
            dex_file_oat_index_map_.emplace(dex_file.get(), i);
            opened_dex_files_.push_back(std::move(dex_file));
          }
        } else {
          DCHECK(opened_dex_files.empty());
        }
      }
    }

    dex_files_ = MakeNonOwningPointerVector(opened_dex_files_);

    // We had to postpone the swap decision till now, as this is the point when we actually
    // know about the dex files we're going to use.

    // Make sure that we didn't create the driver, yet.
    CHECK(driver_ == nullptr);
    // If we use a swap file, ensure we are above the threshold to make it necessary.
    if (swap_fd_ != -1) {
      if (!UseSwap(IsBootImage(), dex_files_)) {
        close(swap_fd_);
        swap_fd_ = -1;
        VLOG(compiler) << "Decided to run without swap.";
      } else {
        LOG(INFO) << "Large app, accepted running with swap.";
      }
    }
    // Note that dex2oat won't close the swap_fd_. The compiler driver's swap space will do that.

    // If we need to downgrade the compiler-filter for size reasons, do that check now.
    if (!IsBootImage() && IsVeryLarge(dex_files_)) {
      if (!CompilerFilter::IsAsGoodAs(CompilerFilter::kExtract,
                                      compiler_options_->GetCompilerFilter())) {
        LOG(INFO) << "Very large app, downgrading to extract.";
        // Note: this change won't be reflected in the key-value store, as that had to be
        //       finalized before loading the dex files. This setup is currently required
        //       to get the size from the DexFile objects.
        // TODO: refactor. b/29790079
        compiler_options_->SetCompilerFilter(CompilerFilter::kExtract);
      }
    }

    if (IsBootImage()) {
      // For boot image, pass opened dex files to the Runtime::Create().
      // Note: Runtime acquires ownership of these dex files.
      runtime_options.Set(RuntimeArgumentMap::BootClassPathDexList, &opened_dex_files_);
      if (!CreateRuntime(std::move(runtime_options))) {
        return dex2oat::ReturnCode::kOther;
      }
    }

    // If we're doing the image, override the compiler filter to force full compilation. Must be
    // done ahead of WellKnownClasses::Init that causes verification.  Note: doesn't force
    // compilation of class initializers.
    // Whilst we're in native take the opportunity to initialize well known classes.
    Thread* self = Thread::Current();
    WellKnownClasses::Init(self->GetJniEnv());

    ClassLinker* const class_linker = Runtime::Current()->GetClassLinker();
    if (!IsBootImage()) {
      constexpr bool kSaveDexInput = false;
      if (kSaveDexInput) {
        SaveDexInput();
      }

      // Handle and ClassLoader creation needs to come after Runtime::Create.
      ScopedObjectAccess soa(self);

      // Classpath: first the class-path given.
      std::vector<const DexFile*> class_path_files = MakeNonOwningPointerVector(class_path_files_);

      // Then the dex files we'll compile. Thus we'll resolve the class-path first.
      class_path_files.insert(class_path_files.end(), dex_files_.begin(), dex_files_.end());

      class_loader_ = class_linker->CreatePathClassLoader(self, class_path_files);
    }

    // Ensure opened dex files are writable for dex-to-dex transformations.
    for (const std::unique_ptr<MemMap>& map : opened_dex_files_maps_) {
      if (!map->Protect(PROT_READ | PROT_WRITE)) {
        PLOG(ERROR) << "Failed to make .dex files writeable.";
        return dex2oat::ReturnCode::kOther;
      }
    }


    // 对dex文件进行遍历(脱壳点)
    for (const auto& dex_file : dex_files_) {
      ScopedObjectAccess soa(self);
      dex_caches_.push_back(soa.AddLocalReference<jobject>(
          class_linker->RegisterDexFile(*dex_file,
                                        soa.Decode<mirror::ClassLoader>(class_loader_).Ptr())));
      if (dex_caches_.back() == nullptr) {
        soa.Self()->AssertPendingException();
        soa.Self()->ClearException();
        PLOG(ERROR) << "Failed to register dex file.";
        return dex2oat::ReturnCode::kOther;
      }
      // Pre-register dex files so that we can access verification results without locks during
      // compilation and verification.
      verification_results_->AddDexFile(dex_file);
    }

    return dex2oat::ReturnCode::kNoFailure;
  }

```



### Dalvik函数抽取和还原

参考文章:http://www.520monkey.com/archives/1118

#### 指令还原

在native层hook系统函数dexFindClass，然后进行类的方法名过滤，获取指定方法的代码结构体，修改指令内存块为可读属性，然后把指令还原即可



**为什么选择dexFindClass函数hook?**

hook类被加载的时机，来实现指令还原，dexFindClass早于函数执行的时机，保证app正常运行



**流程分析**

[DexFile](http://androidxref.com/4.4.4_r1/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java)

```JAVA
public Class loadClass(String name, ClassLoader loader) {
    String slashName = name.replace('.', '/');
    return loadClassBinaryName(slashName, loader, null);
}

public Class loadClassBinaryName(String name, ClassLoader loader, List<Throwable> suppressed) {
    return defineClass(name, loader, mCookie, suppressed);
}

private static Class defineClass(String name, ClassLoader loader, int cookie,
                                 List<Throwable> suppressed) {
    Class result = null;
    try {
        result = defineClassNative(name, loader, cookie);
    } catch (NoClassDefFoundError e) {
        if (suppressed != null) {
            suppressed.add(e);
        }
    } catch (ClassNotFoundException e) {
        if (suppressed != null) {
            suppressed.add(e);
        }
    }
    return result;
}

private static native Class defineClassNative(String name, ClassLoader loader, int cookie)  throws ClassNotFoundException, NoClassDefFoundError;
```

[dalvik_system_DexFile.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/native/dalvik_system_DexFile.cpp)

```cpp
static void Dalvik_dalvik_system_DexFile_defineClassNative(const u4* args, JValue* pResult) {
	if (pDexOrJar->isDex)
		pDvmDex = dvmGetRawDexFileDex(pDexOrJar->pRawDexFile);
    clazz = dvmDefineClass(pDvmDex, descriptor, loader);
}
```

[Class.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/oo/Class.cpp)

```cpp
ClassObject* dvmDefineClass(DvmDex* pDvmDex, const char* descriptor,
    Object* classLoader)
{
    assert(pDvmDex != NULL);
    return findClassNoInit(descriptor, classLoader, pDvmDex);
}

static ClassObject* findClassNoInit(const char* descriptor, Object* loader,
    DvmDex* pDvmDex)
{
    clazz = dvmLookupClass(descriptor, loader, true);
    if (clazz == NULL) {
        // hook
        pClassDef = dexFindClass(pDvmDex->pDexFile, descriptor);
    } 
    return clazz;
}
```



### ART函数抽取和还原

#### 填充指令生效方案

1.禁用dex2oat或直接使用InMemoryDexClassLoader

2.还原时机早于dex2oat



**为什么要禁用dex2oat流程**

如果dex2oat对抽取的dex进行编译生成了oat文件，那么我们动态修改的dex中的smali指令流就不会生效!



#### 禁用dex2oat流程分析(8.0):

[oat_file_assistant.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/oat_file_assistant.cc)

```cpp
OatFileAssistant::ResultOfAttemptToUpdate OatFileAssistant::GenerateOatFileNoChecks(
      OatFileAssistant::OatFileInfo& info, CompilerFilter::Filter filter, std::string* error_msg) {
  CHECK(error_msg != nullptr);

  Runtime* runtime = Runtime::Current();
  if (!runtime->IsDex2OatEnabled()) {
    *error_msg = "Generation of oat file for dex location " + dex_location_
      + " not attempted because dex2oat is disabled.";
    return kUpdateNotAttempted;
  }


  if (!Dex2Oat(args, error_msg)) {
    vdex_file->Erase();
    unlink(vdex_file_name.c_str());
    oat_file->Erase();
    unlink(oat_file_name.c_str());
    return kUpdateFailed;
  }
    
  info.Reset();
  return kUpdateSucceeded;
}


bool OatFileAssistant::Dex2Oat(const std::vector<std::string>& args,
                               std::string* error_msg) {
  // ...
  return Exec(argv, error_msg);
}
```



[exec_utils.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/exec_utils.cc)

```cpp
bool Exec(std::vector<std::string>& arg_vector, std::string* error_msg) {
  int status = ExecAndReturnCode(arg_vector, error_msg);
  if (status != 0) {
    const std::string command_line(android::base::Join(arg_vector, ' '));
    *error_msg = StringPrintf("Failed execv(%s) because non-0 exit status",
                              command_line.c_str());
    return false;
  }
  return true;
}

int ExecAndReturnCode(std::vector<std::string>& arg_vector, std::string* error_msg) {
  const std::string command_line(android::base::Join(arg_vector, ' '));
  CHECK_GE(arg_vector.size(), 1U) << command_line;

  // Convert the args to char pointers.
  const char* program = arg_vector[0].c_str();
  std::vector<char*> args;
  for (size_t i = 0; i < arg_vector.size(); ++i) {
    const std::string& arg = arg_vector[i];
    char* arg_str = const_cast<char*>(arg.c_str());
    CHECK(arg_str != nullptr) << i;
    args.push_back(arg_str);
  }
  args.push_back(nullptr);

  // fork and exec
  pid_t pid = fork();
  if (pid == 0) {
    setpgid(0, 0);

    char** envp = (Runtime::Current() == nullptr) ? nullptr : Runtime::Current()->GetEnvSnapshot();
    if (envp == nullptr) {
      execv(program, &args[0]);
    } else {
      // 通过这个函数执行dex2oat 编译过程 
      // 通过hook execv这个函数来阻止dex2oat流程
      execve(program, &args[0], envp);
    }
  } 
}
```



参考文献:

https://github.com/asLody/TurboDex



**参考示例**

hook libc.so下的execve函数

```cpp
void hooklibc() {
    LOGD("go into hooklibc");
    // Android 7.0以后有 命名空间限制,所以用到了dlopen_compat
    void *libc_addr = dlopen_compat("libc.so", RTLD_NOW);
    // 获取libc.so中execve的函数地址
    void *execve_addr = dlsym_compat(libc_addr, "execve");
    if (execve_addr != NULL) {
        // 参数1：hook函数的地址；参数2：替换掉的函数地址；参数3：原来函数地址
        if (ELE7EN_OK == registerInlineHook((uint32_t) execve_addr, (uint32_t) myexecve,
                                            (uint32_t **) &oriexecve)) {
            if (ELE7EN_OK == inlineHook((uint32_t) execve_addr)) {
                LOGD("inlineHook execve success");
            } else {
                LOGD("inlineHook execve failure");
            }
        }
    }
}

// 函数原型可以在这里找到:http://androidxref.com/8.0.0_r4/xref/bionic/libc/include/unistd.h
void* *(*oriexecve)(const char *__file, char *const *__argv, char *const *__envp);

// 参数1：运行文件的路径；
void* *myexecve(const char *__file, char *const *__argv, char *const *__envp) {
    LOGD("process:%d,enter execve:%s", getpid(), __file);
    // 判断路径名是dex2oat,就直接返回null
    if (strstr(__file, "dex2oat")) {
        return NULL;
    } else {
        // 其他路径就返回原始的，因为不要影响其他的调用
        return oriexecve(__file, __argv, __envp);
    }
}
```



#### 函数抽空和还原

##### 对dex进行函数抽空

**1.寻找code_item**

通过010Editor对dex进行解析，

(1)定位类

在struct class_def_item_list dex_class_defs里找到类的序号

(2)定位函数中的code_item

在struct class_data_item class_data 中的 struct encoded_method_list virtual_methods找到具体函数，

在找到struct encoded_method method 中的 struct code_item code



**2.对指令进行抽空 **

dex中的code_item解析(可以直接使用GDA):

前16个字节是固定，后16(会变动?)个字节是指令部分

将指令部分全部改成00



**3.修改校验合**

修改完成后dex还是不合法的，因为在dexheader中会有校验的

修改校验合部分：struct header_item dex_header中uint checksum

**如何计算校验合？**

通过此脚本(python2)运行计算出校验合

```python
#! /usr/bin/python
# -*- coding: utf8 -*-
import binascii  #删除缩进(Tab)

def CalculationVar(srcByte,vara,varb):#删除缩进(Tab)
    varA = vara
    varB = varb
    icount = 0
    listAB = []

    while icount < len(srcByte):
        varA = (varA + srcByte[icount]) % 65521
        varB = (varB + varA) % 65521
        icount += 1

    listAB.append(varA)
    listAB.append(varB)

    return listAB

def getCheckSum(varA,varB): #删除缩进(Tab)
    Output = (varB << 16) + varA
    return Output

if __name__ == '__main__':
    filename = 'x.dex'
    f = open(filename, 'rb', True)
    f.seek(0x0c)
    VarA = 1
    VarB = 0
    flag = 0
    CheckSum = 0
    while True:
        srcBytes = []
        for i in range(1024):               #一次只读1024个字节，防止内存占用过大
            ch = f.read(1)
            if not ch:                      #如果读取到末尾，设置标识符，然后退出读取循环
                flag = 1
                break
            else:
                ch = binascii.b2a_hex(ch)              #将字节转为int类型，然后添加到数组中
                ch = str(ch)
                ch = int(ch,16)
                srcBytes.append(ch)
        varList = CalculationVar(srcBytes,VarA,VarB)
        VarA = varList[0]
        VarB = varList[1]
        if flag == 1:
            CheckSum = getCheckSum(VarA,VarB)
            break
    print('[*] DEX FILENAME: '+filename)
    print('[+] CheckSum = '+hex(CheckSum))
```



注意：dex文件使用小端字节顺序（Little Endian）

例如:计算的校验合结果为12 34 56 78，那么在010Editor中修改为 78 56 34 12



##### 对dex进行函数填充

参考文章:https://bbs.kanxue.com/thread-254028.htm

**原理分析**

当ART在调用函数前需要对函数所属的类完成加载链接，并最终准备好类中的每一个函数对应的ArtMethod对象以供接下来类的初始化以及函数的调用。整个流程可以简单概括为LoadClass->LoadClassMembers->LinkCode。

LoadClassMembers函数负责准备接下来类函数执行过程中所需要的变量和函数。该函数首先是遍历内存中dex的相关field并初始化为ArtField对象；遍历类中所有的函数，并初始化函数对应的ArtMethod对象。

```cpp
void ClassLinker::LoadClassMembers(Thread* self, const DexFile& dex_file,
                                   const uint8_t* class_data,
                                   Handle<mirror::Class> klass,
                                   const OatFile::OatClass* oat_class) {
  {
    // Note: We cannot have thread suspension until the field and method arrays are setup or else
    // Class::VisitFieldRoots may miss some fields or methods.
    ScopedAssertNoThreadSuspension nts(self, __FUNCTION__);
    // Load static fields.
   //遍历dex中的相关field
    ClassDataItemIterator it(dex_file, class_data);
    const size_t num_sfields = it.NumStaticFields();
    ArtField* sfields = num_sfields != 0 ? AllocArtFieldArray(self, num_sfields) : nullptr;
    for (size_t i = 0; it.HasNextStaticField(); i++, it.Next()) {
      CHECK_LT(i, num_sfields);
      LoadField(it, klass, &sfields[i]);
    }
    klass->SetSFields(sfields);
    klass->SetNumStaticFields(num_sfields);
    DCHECK_EQ(klass->NumStaticFields(), num_sfields);
    // Load instance fields.
    const size_t num_ifields = it.NumInstanceFields();
    ArtField* ifields = num_ifields != 0 ? AllocArtFieldArray(self, num_ifields) : nullptr;
    for (size_t i = 0; it.HasNextInstanceField(); i++, it.Next()) {
      CHECK_LT(i, num_ifields);
      LoadField(it, klass, &ifields[i]);
    }
    klass->SetIFields(ifields);
    klass->SetNumInstanceFields(num_ifields);
    DCHECK_EQ(klass->NumInstanceFields(), num_ifields);
    // Load methods.
   //遍历dex中的相关Method并初始化
    if (it.NumDirectMethods() != 0) {
      klass->SetDirectMethodsPtr(AllocArtMethodArray(self, it.NumDirectMethods()));
    }
    klass->SetNumDirectMethods(it.NumDirectMethods());
    if (it.NumVirtualMethods() != 0) {
      klass->SetVirtualMethodsPtr(AllocArtMethodArray(self, it.NumVirtualMethods()));
    }
    klass->SetNumVirtualMethods(it.NumVirtualMethods());
    size_t class_def_method_index = 0;
    uint32_t last_dex_method_index = DexFile::kDexNoIndex;
    size_t last_class_def_method_index = 0;
    //首先遍历初始化DirectMethod
    for (size_t i = 0; it.HasNextDirectMethod(); i++, it.Next()) {
      ArtMethod* method = klass->GetDirectMethodUnchecked(i, image_pointer_size_);
      LoadMethod(self, dex_file, it, klass, method);
      LinkCode(method, oat_class, class_def_method_index);
      uint32_t it_method_index = it.GetMemberIndex();
      if (last_dex_method_index == it_method_index) {
        // duplicate case
        method->SetMethodIndex(last_class_def_method_index);
      } else {
        method->SetMethodIndex(class_def_method_index);
        last_dex_method_index = it_method_index;
        last_class_def_method_index = class_def_method_index;
      }
      class_def_method_index++;
    }
   //然后遍历初始化VirtualMethod
    for (size_t i = 0; it.HasNextVirtualMethod(); i++, it.Next()) {
      ArtMethod* method = klass->GetVirtualMethodUnchecked(i, image_pointer_size_);
      LoadMethod(self, dex_file, it, klass, method);
      DCHECK_EQ(class_def_method_index, it.NumDirectMethods() + i);
      LinkCode(method, oat_class, class_def_method_index);
      class_def_method_index++;
    }
    DCHECK(!it.HasNext());
  }
  self->AllowThreadSuspension();
}
```



```cpp
void ClassLinker::LoadMethod(Thread* self, const DexFile& dex_file, const ClassDataItemIterator& it,
                             Handle<mirror::Class> klass, ArtMethod* dst) {
  uint32_t dex_method_idx = it.GetMemberIndex();
  const DexFile::MethodId& method_id = dex_file.GetMethodId(dex_method_idx);
  const char* method_name = dex_file.StringDataByIdx(method_id.name_idx_);
 
  ScopedAssertNoThreadSuspension ants(self, "LoadMethod");
  //初始化相关变量
  dst->SetDexMethodIndex(dex_method_idx);
  dst->SetDeclaringClass(klass.Get());
  //初始化CodeItem指针(指向smali指令在内存中的偏移)
  dst->SetCodeItemOffset(it.GetMethodCodeItemOffset());
 
  dst->SetDexCacheResolvedMethods(klass->GetDexCache()->GetResolvedMethods());
  dst->SetDexCacheResolvedTypes(klass->GetDexCache()->GetResolvedTypes());
 
  uint32_t access_flags = it.GetMethodAccessFlags();
 
  if (UNLIKELY(strcmp("finalize", method_name) == 0)) {
    // Set finalizable flag on declaring class.
    if (strcmp("V", dex_file.GetShorty(method_id.proto_idx_)) == 0) {
      // Void return type.
      if (klass->GetClassLoader() != nullptr) {  // All non-boot finalizer methods are flagged.
        klass->SetFinalizable();
      } else {
        std::string temp;
        const char* klass_descriptor = klass->GetDescriptor(&temp);
        // The Enum class declares a "final" finalize() method to prevent subclasses from
        // introducing a finalizer. We don't want to set the finalizable flag for Enum or its
        // subclasses, so we exclude it here.
        // We also want to avoid setting the flag on Object, where we know that finalize() is
        // empty.
        if (strcmp(klass_descriptor, "Ljava/lang/Object;") != 0 &&
            strcmp(klass_descriptor, "Ljava/lang/Enum;") != 0) {
          klass->SetFinalizable();
        }
      }
    }
  } else if (method_name[0] == '<') {
    // Fix broken access flags for initializers. Bug 11157540.
    bool is_init = (strcmp("<init>", method_name) == 0);
    bool is_clinit = !is_init && (strcmp("<clinit>", method_name) == 0);
    if (UNLIKELY(!is_init && !is_clinit)) {
      LOG(WARNING) << "Unexpected '<' at start of method name " << method_name;
    } else {
      if (UNLIKELY((access_flags & kAccConstructor) == 0)) {
        LOG(WARNING) << method_name << " didn't have expected constructor access flag in class "
            << PrettyDescriptor(klass.Get()) << " in dex file " << dex_file.GetLocation();
        access_flags |= kAccConstructor;
      }
    }
  }
  dst->SetAccessFlags(access_flags);
}
```







**代码示例**

hook LoadMethod

```cpp
struct DexFile {
    // Field order required by test "ValidateFieldOrderOfJavaCppUnionClasses".
    // The class we are a part of.
    uint32_t declaring_class_;
    // Access flags; low 16 bits are defined by spec.
    void *begin;
    /* Dex file fields. The defining dex file is available via declaring_class_->dex_cache_ */
    // Offset to the CodeItem.
    uint32_t size;
};

// http://androidxref.com/8.0.0_r4/xref/art/runtime/art_method.h
struct ArtMethod {
    // Field order required by test "ValidateFieldOrderOfJavaCppUnionClasses".
    // The class we are a part of.
    uint32_t declaring_class_;
    // Access flags; low 16 bits are defined by spec.
    uint32_t access_flags_;
    /* Dex file fields. The defining dex file is available via declaring_class_->dex_cache_ */
    // Offset to the CodeItem.
    uint32_t dex_code_item_offset_;
    // Index into method_ids of the dex file associated with this method.
    uint32_t dex_method_index_;
};

void hookART() {
    LOGD("go into hookART");
    void *libart_addr = dlopen_compat("/system/lib/libart.so", RTLD_NOW);
    if (libart_addr != NULL) {
        // 具体的函数名，可以用IDA从libart.so中搜索LoadMethod中找到
        void *loadmethod_addr = dlsym_compat(libart_addr,                           "_ZN3art11ClassLinker10LoadMethodERKNS_7DexFileERKNS_21ClassDataItemIteratorENS_6HandleINS_6mirror5ClassEEEPNS_9ArtMethodE");
        if (loadmethod_addr != NULL) {
            if (ELE7EN_OK == registerInlineHook((uint32_t) loadmethod_addr, (uint32_t) myloadmethod,
                                                (uint32_t **) &oriloadmethod)) {
                if (ELE7EN_OK == inlineHook((uint32_t) loadmethod_addr)) {
                    LOGD("inlineHook loadmethod success");
                } else {
                    LOGD("inlineHook loadmethod failure");
                }
            }
        }
    }
}

// 函数原型:第二个参数是dex文件,最后个参数是java层函数对应的ArtMethod
//void ClassLinker::LoadMethod(Thread* self, const DexFile& dex_file, const ClassDataItemIterator& it,Handle<mirror::Class> klass, ArtMethod* dst)
void *(*oriloadmethod)(void *, void *, void *, void *, void *);

void *myloadmethod(void *a, void *b, void *c, void *d, void *e) {
    LOGD("process:%d,before run loadmethod:", getpid());
    struct ArtMethod *artmethod = (struct ArtMethod *) e;
    struct DexFile *dexfile = (struct DexFile *) b;
    LOGD("process:%d,enter loadmethod:dexfilebegin:%p,size:%d", getpid(), dexfile->begin,
         dexfile->size);//0,57344
    // 将dex文件dump下来，类似脱壳的操作(这里的作用是修复前和修复后dump下来进行对比)
    char dexfilepath[100] = {0};
    sprintf(dexfilepath, "/sdcard/%d_%d.dex", dexfile->size, getpid());
    int fd = open(dexfilepath, O_CREAT | O_RDWR, 0666);
    if (fd > 0) {
        write(fd, dexfile->begin, dexfile->size);
        close(fd);
    }
	// 将原有的smali指令填充回去
    // 当函数没调用时，ArtMethod还没初始化，里面的值都是空的
    // 调用了原始的oriloadmethod后，ArtMethod关键变量就初始化好了，例如dex_method_index_
    void *result = oriloadmethod(a, b, c, d, e);
    LOGD("process:%d,enter loadmethod:code_offset:%d,idx:%d", getpid(),
         artmethod->dex_code_item_offset_, artmethod->dex_method_index_);

    byte *code_item_addr = static_cast<byte *>(dexfile->begin) + artmethod->dex_code_item_offset_;
    LOGD("process:%d,enter loadmethod:dexfilebegin:%p,size:%d,beforedumpcodeitem:%p", getpid(),
         dexfile->begin, dexfile->size, code_item_addr);

	// 15203指的是要恢复的函数index
    if (artmethod->dex_method_index_ == 15203) {//TestClass.testFunc->methodidx
        LOGD("process:%d,enter loadmethod:dexfilebegin:%p,size:%d,start repire method", getpid(),
             dexfile->begin, dexfile->size);
        byte *code_item_addr = (byte *) dexfile->begin + artmethod->dex_code_item_offset_;
        LOGD("process:%d,enter loadmethod:dexfilebegin:%p,size:%d,beforedumpcodeitem:%p", getpid(),
             dexfile->begin, dexfile->size, code_item_addr);

        // 更改内存页的保护属性,使得该内存页变为可写。
        int result = mprotect(dexfile->begin, dexfile->size, PROT_WRITE);
        
        // +16 指的是code_item前16个字节是固定的，后面的字节才是指令流
        byte *code_item_start = static_cast<byte *>(code_item_addr) + 16;
        LOGD("process:%d,enter loadmethod:dexfilebegin:%p,size:%d,code_item_start:%p", getpid(),
             dexfile->begin, dexfile->size, code_item_start);
        // 原有的指令
        byte inst[16] = {0x1a, 0x00, 0xed, 0x34, 0x1a, 0x01, 0x43, 0x32, 0x71, 0x20, 0x91, 0x05,
                         0x10, 0x00, 0x0e, 0x00};
        // 赋值
        for (int i = 0; i < sizeof(inst); i++) {
            code_item_start[i] = inst[i];
        }

        memset(dexfilepath, 0, 100);
        
        // 将dex文件dump下来
        sprintf(dexfilepath, "/sdcard/%d_%d.dex_15203_2", dexfile->size, getpid());
        fd = open(dexfilepath, O_CREAT | O_RDWR, 0666);
        if (fd > 0) {
            write(fd, dexfile->begin, dexfile->size);
            close(fd);
        }
    }
    LOGD("process:%d,after loadmethod:code_offset:%d,idx:%d", getpid(),
         artmethod->dex_code_item_offset_, artmethod->dex_method_index_);//0,57344
    return result;

}
```





### FART框架

框架由脱壳组件、主动调用组件、修复组件组成

#### 流程解析

**dex2oat编译流程：函数粒度进行编译**

并不是所有的函数都会被编译，比如类的初始化函数\<clinit>

因此当一个类被初始化时，该类的初始化函数始终运行在interpreter模式



[compiler_driver.cc](http://androidxref.com/8.0.0_r4/xref/art/compiler/driver/compiler_driver.cc)

```cpp
static void CompileMethod(Thread* self,
                          CompilerDriver* driver,
                          const DexFile::CodeItem* code_item,
                          uint32_t access_flags,
                          InvokeType invoke_type,
                          uint16_t class_def_idx,
                          uint32_t method_idx,
                          Handle<mirror::ClassLoader> class_loader,
                          const DexFile& dex_file,
                          optimizer::DexToDexCompilationLevel dex_to_dex_compilation_level,
                          bool compilation_enabled,
                          Handle<mirror::DexCache> dex_cache) {


  if (driver->GetCurrentDexToDexMethods() != nullptr) {
    
  } else if ((access_flags & kAccNative) != 0) {
    if (!driver->GetCompilerOptions().IsJniCompilationEnabled() &&
    } else {
      ArtMethod* method =
          Runtime::Current()->GetClassLinker()->ResolveMethod<ClassLinker::kNoICCECheckForCache>(
              dex_file,
              method_idx,
              dex_cache,
              class_loader,
              /* referrer */ nullptr,
              invoke_type);
    }
  } else if ((access_flags & kAccAbstract) != 0) {
  } else {
    const VerifiedMethod* verified_method =
        driver->GetVerificationResults()->GetVerifiedMethod(method_ref);
    bool compile = compilation_enabled &&
        // Basic checks, e.g., not <clinit>.
        // 初始化函数不会编译
        driver->GetVerificationResults()
            ->IsCandidateForCompilation(method_ref, access_flags) &&
        // Did not fail to create VerifiedMethod metadata.
        verified_method != nullptr &&
        // Do not have failures that should punt to the interpreter.
        !verified_method->HasRuntimeThrow() &&
        (verified_method->GetEncounteredVerificationFailures() &
            (verifier::VERIFY_ERROR_FORCE_INTERPRETER | verifier::VERIFY_ERROR_LOCKING)) == 0 &&
        // Is eligable for compilation by methods-to-compile filter.
        driver->IsMethodToCompile(method_ref) &&
        driver->ShouldCompileBasedOnProfile(method_ref);

    if (compile) {
      // NOTE: if compiler declines to compile this method, it will return null.
      compiled_method = driver->GetCompiler()->Compile(code_item,
                                                       access_flags,
                                                       invoke_type,
                                                       class_def_idx,
                                                       method_idx,
                                                       class_loader,
                                                       dex_file,
                                                       dex_cache);
    }
    if (compiled_method == nullptr &&
        dex_to_dex_compilation_level != optimizer::DexToDexCompilationLevel::kDontDexToDexCompile) {
      DCHECK(!Runtime::Current()->UseJitCompilation());
      // TODO: add a command-line option to disable DEX-to-DEX compilation ?
      driver->MarkForDexToDexCompilation(self, method_ref);
    }
  }
  if (kTimeCompileMethod) {
    uint64_t duration_ns = NanoTime() - start_ns;
    if (duration_ns > MsToNs(driver->GetCompiler()->GetMaximumCompilationTimeBeforeWarning())) {
      LOG(WARNING) << "Compilation of " << dex_file.PrettyMethod(method_idx)
                   << " took " << PrettyDuration(duration_ns);
    }
  }

  if (compiled_method != nullptr) {
    // Count non-relative linker patches.
    size_t non_relative_linker_patch_count = 0u;
    for (const LinkerPatch& patch : compiled_method->GetPatches()) {
      if (!patch.IsPcRelative()) {
        ++non_relative_linker_patch_count;
      }
    }
    bool compile_pic = driver->GetCompilerOptions().GetCompilePic();  // Off by default
    // When compiling with PIC, there should be zero non-relative linker patches
    CHECK(!compile_pic || non_relative_linker_patch_count == 0u);

    driver->AddCompiledMethod(method_ref, compiled_method, non_relative_linker_patch_count);
  }

  if (self->IsExceptionPending()) {
    ScopedObjectAccess soa(self);
    LOG(FATAL) << "Unexpected exception compiling: " << dex_file.PrettyMethod(method_idx) << "\n"
        << self->GetException()->Dump();
  }
}
```



**ART函数执行模式:**

interpreter模式：由ART下的解释器解释执行

quick模式：直接运行dex2oat编译生成的arm指令



说明:

没有禁用dex2oat，类的初始化运行在解释模式

禁用dex2oat，dex所有的函数都运行在解释模式

所以在这2种模式，类的初始化始终运行在解释模式下



ART解释器不同版本有不同实现：

switch、汇编(默认，效率高)、computedGoto



#### 脱壳点(3.0)

在这个函数中最终就会转交给解释器去执行



**为什么推荐用Execute脱壳点？**

例如在dex2oat中去脱壳，某些厂商直接把此流程给禁了，这个脱壳点就失效了。

在Execute脱壳点，不管有没有禁用掉dex2oat流程，所有的类初始化函数都会走到解释执行流程中。

加固厂商在对抗中，hook关键脱壳点，修改原有的逻辑，导致就算再某些脱壳点加入了dump逻辑，dump下来不是明文的dex。

例如：非标准库中的fopen,fwrite等，加固厂商可以对这些函数hook并修改原有的逻辑

而对于Execute是内联函数，加固厂商很难通过hook修改掉内部逻辑。



其他脱壳点推荐

```
LoadClassMembers、LoadMethod、LinkCode
```





[interpreter.cc](http://androidxref.com/8.0.0_r4/xref/art/runtime/interpreter/interpreter.cc)

```cpp
static inline JValue Execute(
    Thread* self,
    const DexFile::CodeItem* code_item,
    ShadowFrame& shadow_frame,
    JValue result_register,
    bool stay_in_interpreter = false) REQUIRES_SHARED(Locks::mutator_lock_) {
    
  // 此处开始dump************************************
    // 通过artmethod的PrettyMethod方法进行函数名判断，只在初始化函数做操作
    // 如果不判断会导致重复写，非常卡顿
    if(strstr(artmethod->PrettyMethod().c_str(),"<clinit>")) {
        // shadow_frame 解释模式下的堆栈管理
        // 通过shadow_frame获取ArtMethod
        ArtMethod* artmethod=shadow_frame.GetMethod();
        // 通过ArtMethod获取DexFile
        const DexFile* dexfile=artmethod->GetDexFile();
        // 获取dexFile起始地址
        const uint8_t* begin=dexfile->Begin();
        // 获取dexFile大小
        size_t size=dexfile->Size();
        //dump 操作
        char dexfilepath[100]={0};
        sprintf(dexfilepath,"/sdcard/%d_%d_Execute.dex",(int)size,getpid());
        int fd=open(dexfilepath,O_CREAT|O_RDWR,0666);
        if(fd>0){
            int number=write(fd,begin,size);
            if(number>0){
            }
            close(fd);
        }        
    }
    
  // dump 结束************************************
    
  DCHECK(!shadow_frame.GetMethod()->IsAbstract());
  DCHECK(!shadow_frame.GetMethod()->IsNative());
  if (LIKELY(shadow_frame.GetDexPC() == 0)) {  // Entering the method, but not via deoptimization.
    if (kIsDebugBuild) {
      self->AssertNoPendingException();
    }
    instrumentation::Instrumentation* instrumentation = Runtime::Current()->GetInstrumentation();
    ArtMethod *method = shadow_frame.GetMethod();

    if (UNLIKELY(instrumentation->HasMethodEntryListeners())) {
      instrumentation->MethodEnterEvent(self, shadow_frame.GetThisObject(code_item->ins_size_),
                                        method, 0);
    }

    if (!stay_in_interpreter) {
      jit::Jit* jit = Runtime::Current()->GetJit();
      if (jit != nullptr) {
        jit->MethodEntered(self, shadow_frame.GetMethod());
        if (jit->CanInvokeCompiledCode(method)) {
          JValue result;

          // Pop the shadow frame before calling into compiled code.
          self->PopShadowFrame();
          ArtInterpreterToCompiledCodeBridge(self, nullptr, code_item, &shadow_frame, &result);
          // Push the shadow frame back as the caller will expect it.
          self->PushShadowFrame(&shadow_frame);

          return result;
        }
      }
    }
  }

  shadow_frame.GetMethod()->GetDeclaringClass()->AssertInitializedOrInitializingInThread(self);

  // Lock counting is a special version of accessibility checks, and for simplicity and
  // reduction of template parameters, we gate it behind access-checks mode.
  ArtMethod* method = shadow_frame.GetMethod();
  DCHECK(!method->SkipAccessChecks() || !method->MustCountLocks());

  bool transaction_active = Runtime::Current()->IsActiveTransaction();
  if (LIKELY(method->SkipAccessChecks())) {
    // Enter the "without access check" interpreter.
    if (kInterpreterImplKind == kMterpImplKind) {
      if (transaction_active) {
        // No Mterp variant - just use the switch interpreter.
        return ExecuteSwitchImpl<false, true>(self, code_item, shadow_frame, result_register,
                                              false);
      } else if (UNLIKELY(!Runtime::Current()->IsStarted())) {
        return ExecuteSwitchImpl<false, false>(self, code_item, shadow_frame, result_register,
                                               false);
      } else {
        while (true) {
          // Mterp does not support all instrumentation/debugging.
          if (MterpShouldSwitchInterpreters() != 0) {
            return ExecuteSwitchImpl<false, false>(self, code_item, shadow_frame, result_register,
                                                   false);
          }
          bool returned = ExecuteMterpImpl(self, code_item, &shadow_frame, &result_register);
          if (returned) {
            return result_register;
          } else {
            // Mterp didn't like that instruction.  Single-step it with the reference interpreter.
            result_register = ExecuteSwitchImpl<false, false>(self, code_item, shadow_frame,
                                                              result_register, true);
            if (shadow_frame.GetDexPC() == DexFile::kDexNoIndex) {
              // Single-stepped a return or an exception not handled locally.  Return to caller.
              return result_register;
            }
          }
        }
      }
    } else {
      DCHECK_EQ(kInterpreterImplKind, kSwitchImplKind);
      if (transaction_active) {
        return ExecuteSwitchImpl<false, true>(self, code_item, shadow_frame, result_register,
                                              false);
      } else {
        return ExecuteSwitchImpl<false, false>(self, code_item, shadow_frame, result_register,
                                               false);
      }
    }
  } else {
    // Enter the "with access check" interpreter.
    if (kInterpreterImplKind == kMterpImplKind) {
      // No access check variants for Mterp.  Just use the switch version.
      if (transaction_active) {
        return ExecuteSwitchImpl<true, true>(self, code_item, shadow_frame, result_register,
                                             false);
      } else {
        return ExecuteSwitchImpl<true, false>(self, code_item, shadow_frame, result_register,
                                              false);
      }
    } else {
      DCHECK_EQ(kInterpreterImplKind, kSwitchImplKind);
      if (transaction_active) {
        return ExecuteSwitchImpl<true, true>(self, code_item, shadow_frame, result_register,
                                             false);
      } else {
        return ExecuteSwitchImpl<true, false>(self, code_item, shadow_frame, result_register,
                                              false);
      }
    }
  }
}
```



#### Dalvik脱壳方案

Dalvik下基于主动调用的自动化脱壳方案，将粒度下降到函数粒度。

例:dexhunter以及f8的Fupk3



#### Fart主动调用相关概念

被动调用：app正常运行过程中发生的调用，缺点是函数调用不全问题

主动调用：构造虚拟调用，从而达成欺骗“壳”，让壳误以为app在执行正常的函数调用流程，从而达到dex中所有类函数的虚拟调用，

同时，函数修复的准确度同主动调用链的构造深度有关。



GDA反编译后的一些指令解释

```
// 1a 对应 smali的const-string
11dab0: 1a00ef34       | 0000: const-string v0, string@34ef
// 71 对应 invoke-static
// method_index 是 05ae 转成十进制是 1454, 通过010Editor的method列表里找到对应的方法
11dab8: 7120ae051000   | 0004: invoke-static {v0, v1}, method@05ae
```



#### Fart生成bin文件格式

5元祖填充

```
{
name:函数名，
method_idx:函数索引(必须),
offset:偏移,
code_item_len:长度,
ins:函数体CodeItem的base64字符串(必须)
}
```



#### 字节码文档

https://source.android.com/devices/tech/dalvik/dalvik-bytecode



#### 使用步骤

1.安装待脱壳的apk

2.到系统设置中授予app读写SDK卡权限(因为dex要写到sdk目录里)

3.点击启动app，等待FART脱壳线程启动

4.等待app进程的logcat中出现fart run ove，则代表主动调用过程结束，此时脱壳结束

5.将/sdcard/fart/进程名下脱壳的dex和函数体bin文件拷贝到电脑即可

通过 grep -ril "SplashActivity" ./*.txt 找到你需要的类所在的dex

6.使用fart.py进行抽取函数的修复工作

还原脚本指令(py2.7)

```
python fart.py -d xx.dex -i xx.bin >> result.txt
```

查看result结果手动回填进去



#### 脱壳中的问题

1.运行一段时间后app异常退出

解决方案：某些加固厂商已经针对FART的指纹特征进行了检测；加固厂商在dex中插入了一些“垃圾类”，通过判断“垃圾类”的加载来确定正在被脱壳，并退出。此时可以通过设置白名单的方式解决，只对app正常运行加载过的类进行主动调用即可。

2.app没有申请sdk权限怎么办

解决方案：写入到私有目录下



#### 版本迭代

##### 1.0:classloader中dump

```
1、时机：
APP中的Application类中的attachBaseContext和onCreate函数是app中最先执行的方法。
因此需要选在在Application的onCreate函数执行之后才开始被调用的任意一个函数中。
比如选择在ActivityThread中的performLaunchActivity函数作为时机，来获取最终的应用的Classloader。

2、方式：“hook” →、反射和“dump”
获取到应用解密后的dex文件最终依附的Classloader之后
通过java的反射机制最终获取到对应的DexFile的结构体，并完成dex的dump
```

##### 2.0:更多”海量“的脱壳点

```
1、时机：
所有类和方法的装载和链接/编译和执行流程之中

2、方式：基于“hook”→ ”dump“
ART下DexFile类中定义了两个关键的变量： begin_、size_以及用于获取这两个变量的Begin()和Size()函数
这两个变量分别代表着当前DexFile对象对应的内存中的dex文件加载的起始位置和大小。
只要有了这两个值，我们就可以完成对这个dex的dump。
```

##### 3.0:优中选优后 的脱壳点

```
1、时机：
找到绕过dex2oat的时机
类的初始化函数始终运行在ART下的inpterpreter模式

2、方式：
在解释执行<clinit>时进行脱壳 实现“绕过”dex2oat
因此必然进入到interpreter.cc文件中的Execute函数，进而进入ART下的解释器解释执行
```

##### 4.0:优中选优 + 双保险

```
1、时机和方法：
同时在dex2oat和类的初始化流程函数设置“hook”
```



#### 参考资料

- https://bbs.pediy.com/thread-252630.htm
- https://bbs.pediy.com/thread-254028.htm





### Youpk框架

基于ART的主动调用的脱壳机

仅支持pixel 1代(7.1.2_r33)



#### 原理

Youpk是一款针对Dex整体加固+各式各样的Dex抽取的脱壳机

基本流程如下:

1. 从内存中dump DEX
2. 构造完整调用链, 主动调用所有方法并dump CodeItem
3. 合并 DEX, CodeItem



#### 从内存中dump DEX

DEX文件在art虚拟机中使用DexFile对象表示, 而ClassLinker中引用了这些对象, 因此可以采用从ClassLinker中遍历DexFile对象并dump的方式来获取.

```c
//unpacker.cc
std::list<const DexFile*> Unpacker::getDexFiles() {
  std::list<const DexFile*> dex_files;
  Thread* const self = Thread::Current();
  ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
  ReaderMutexLock mu(self, *class_linker->DexLock());
  const std::list<ClassLinker::DexCacheData>& dex_caches = class_linker->GetDexCachesData();
  for (auto it = dex_caches.begin(); it != dex_caches.end(); ++it) {
    ClassLinker::DexCacheData data = *it;
    const DexFile* dex_file = data.dex_file;
    dex_files.push_back(dex_file);
  }
  return dex_files;
}
```

另外, 为了避免dex做任何形式的优化影响dump下来的dex文件, 在dex2oat中设置 CompilerFilter 为仅验证

```
//dex2oat.cc
compiler_options_->SetCompilerFilter(CompilerFilter::kVerifyAtRuntime);
```





#### 参考资料

https://github.com/Youlor/Youpk

https://github.com/youlor/unpacker







### 其他资料

```
《Android免Root权限Hook系统函数修改程序运行时内存指令逻辑》
https://mp.weixin.qq.com/s/XeS1x3YGEyTrjUvL4u8mEQ

《Android应用实现「类方法指令抽取方式」加固方案原理解析》
https://mp.weixin.qq.com/s/Qs7AZswzpHZlv5cNWxztkg

寒冰大佬的三篇脱壳文章：
https://bbs.pediy.com/user-632473.htm

推荐阅读：https://bbs.pediy.com/thread-254028.htm

基于自定义linker的加壳工具
https://bbs.pediy.com/thread-225798.htm

未来？arm指令级别的VMP即将来临！
https://bbs.pediy.com/thread-265017.htm

函数抽取
https://mp.weixin.qq.com/s/3tjY_03aLeluwXZGgl3ftw


VMP
https://github.com/chago/ADVMP
https://geneblue.github.io/2019/09/13/android/sec--android-dex-vmp/

https://github.com/guanchao



DexRepair
https://github.com/luoyesiqiu/DexRepair


```

