# 网络

## 环境

### 抓包软件

charles

burpsuite(不支持websocks)

手机代理软件:postern

配置指南:https://blog.csdn.net/MoMozzzzz/article/details/123216616



注：如果使用虚拟机抓包，网络配置需要改成桥接模式







### 证书读取软件

https://keystore-explorer.org/downloads.html



### OSI模型对应?

```
应用
表示
会话
传输
网络
数据链路
物理
```

- 应用层：`Http(s)`协议抓包
- 会话层：`Socket`端口通信抓包(TCP层？)
- 路由层：VPN抓包



socket协议对应传输层



### 防止抓包设置

不同框架中设置 Proxy.NO_PROXY







## 证书

### 证书迁移(用户到系统)

方法一

magisk：MoveCertificate

https://github.com/ys1231/MoveCertificate



方法二(8.1之前？)

```
cd /data/misc/user/0/cacerts-added
mount -o remount,rw /
cp * /etc/security/cacerts/
mount -o remount,ro /
```





### 证书dump

```js
function hook_KeyStore_load() {
    Java.perform(function () {
        var ByteString = Java.use("com.android.okhttp.okio.ByteString");
        var myArray=new Array(1024);
        var i = 0
        for (i = 0; i < myArray.length; i++) {
            myArray[i]= 0x0;
         }
        var buffer = Java.array('byte',myArray);
        
        var StringClass = Java.use("java.lang.String");
        var KeyStore = Java.use("java.security.KeyStore");
        KeyStore.load.overload('java.security.KeyStore$LoadStoreParameter').implementation = function (arg0) {
            console.log(Java.use("android.util.Log").getStackTraceString(Java.use("java.lang.Throwable").$new()));

            console.log("KeyStore.load1:", arg0);
            this.load(arg0);
        };
        KeyStore.load.overload('java.io.InputStream', '[C').implementation = function (arg0, arg1) {
            console.log(Java.use("android.util.Log").getStackTraceString(Java.use("java.lang.Throwable").$new()));

            console.log("KeyStore.load2:", arg0, arg1 ? StringClass.$new(arg1) : null);

            if (arg0){
                var file =  Java.use("java.io.File").$new("/sdcard/Download/"+ String(arg0)+".p12");
                var out = Java.use("java.io.FileOutputStream").$new(file);
                var r;
                while( (r = arg0.read(buffer)) > 0){
                    out.write(buffer,0,r)
                }
                console.log("save success!")
                out.close()
            }
            this.load(arg0, arg1);
        };
        console.log("hook_KeyStore_load...");
    });
}
```





### SSL pinning:对证书在代码中进行额外校验

在自定义证书已经配置好情况下，还是无法访问，可能是在代码中进行了二次校验，所以我们将校验方法进行hook绕过原校验机制

```js
function hook_ssl() {
    Java.perform(function() {
        var ClassName = "com.android.org.conscrypt.Platform";
        var Platform = Java.use(ClassName);
        var targetMethod = "checkServerTrusted";
        var len = Platform[targetMethod].overloads.length;
        console.log(len);
        for(var i = 0; i < len; ++i) {
            Platform[targetMethod].overloads[i].implementation = function () {
                console.log("class:", ClassName, "target:", targetMethod, " i:", i, arguments);
                //printStack(ClassName + "." + targetMethod);
            }
        }
    });
}
```

也可以通过objection关闭sslpinning

```
android sslpinning disable
```



另一个安卓证书锁定解除的工具(增加了objection没有覆盖到的场景)

https://github.com/WooyunDota/DroidSSLUnpinning



## 抓包步骤

通过http代理抓包抓不到，通过postern进行socks抓包

使用socks proxy抓包时，记得确认抓包的端口是否包含进去，

可能有些用socks proxy 代理，反而http proxy可以





如果对证书进行了二次校验，可以进行hook，bypass





## VPN检测

TODO



## 常见问题

1.SSL: Unsupported or unrecognized SSL message

可能端口没有识别，在抓包软件中增加对应的端口









## 其他知识

### 主机网路计算

```
wlan0     Link encap:Ethernet  HWaddr 40:4e:36:90:a0:59  Driver icnss
          inet addr:10.128.171.254  Bcast:10.128.191.255  Mask:255.255.192.0
          inet6 addr: 2001:250:6010:8080:5929:c1c8:6914:9b67/64 Scope: Global
          inet6 addr: 2001:250:6010:8080:806:e1e3:a941:2a65/64 Scope: Global
          inet6 addr: fe80::a58d:c6fb:9846:37b5/64 Scope: Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:868180 errors:0 dropped:0 overruns:0 frame:0
          TX packets:463502 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:3000
          RX bytes:1116035368 TX bytes:62077305
```

```
wlan0的IPv4地址是10.128.171.254，子网掩码是255.255.192.0
IPv4地址：10.128.171.254（二进制表示为00001010.10000000.10101011.11111110）

子网掩码：255.255.192.0（二进制表示为11111111.11111111.11000000.00000000）

按位与运算结果为：00001010.10000000.10000000.00000000，即10.128.128.0。

子网掩码是255.255.192.0，这意味着有18位用于网络地址（/18子网掩码）。因此，剩下的14位用于主机地址。

```

