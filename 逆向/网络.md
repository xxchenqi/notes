# 网络

## 环境

### 抓包软件

charles

burpsuite(不支持websocks)

手机代理软件:postern

配置指南:https://blog.csdn.net/MoMozzzzz/article/details/123216616



注：如果使用虚拟机抓包，网络配置需要改成桥接模式







### 证书读取软件

https://keystore-explorer.org/downloads.html



### OSI模型对应?

```
应用
表示
会话
传输
网络
数据链路
物理
```

- 应用层：`Http(s)`协议抓包
- 会话层：`Socket`端口通信抓包(TCP层？)
- 路由层：VPN抓包



socket协议对应传输层



### 防止抓包设置

不同框架中设置 Proxy.NO_PROXY







## 证书

### 证书迁移(用户到系统)

方法一

magisk：MoveCertificate

https://github.com/ys1231/MoveCertificate



方法二(8.1之前？)

```
cd /data/misc/user/0/cacerts-added
mount -o remount,rw /
cp * /etc/security/cacerts/
mount -o remount,ro /
```





### 证书dump

```js
function hook_KeyStore_load() {
    Java.perform(function () {
        var ByteString = Java.use("com.android.okhttp.okio.ByteString");
        var myArray=new Array(1024);
        var i = 0
        for (i = 0; i < myArray.length; i++) {
            myArray[i]= 0x0;
         }
        var buffer = Java.array('byte',myArray);
        
        var StringClass = Java.use("java.lang.String");
        var KeyStore = Java.use("java.security.KeyStore");
        KeyStore.load.overload('java.security.KeyStore$LoadStoreParameter').implementation = function (arg0) {
            console.log(Java.use("android.util.Log").getStackTraceString(Java.use("java.lang.Throwable").$new()));

            console.log("KeyStore.load1:", arg0);
            this.load(arg0);
        };
        KeyStore.load.overload('java.io.InputStream', '[C').implementation = function (arg0, arg1) {
            console.log(Java.use("android.util.Log").getStackTraceString(Java.use("java.lang.Throwable").$new()));

            console.log("KeyStore.load2:", arg0, arg1 ? StringClass.$new(arg1) : null);

            if (arg0){
                var file =  Java.use("java.io.File").$new("/sdcard/Download/"+ String(arg0)+".p12");
                var out = Java.use("java.io.FileOutputStream").$new(file);
                var r;
                while( (r = arg0.read(buffer)) > 0){
                    out.write(buffer,0,r)
                }
                console.log("save success!")
                out.close()
            }
            this.load(arg0, arg1);
        };
        console.log("hook_KeyStore_load...");
    });
}
```





### SSL pinning:对证书在代码中进行额外校验

在自定义证书已经配置好情况下，还是无法访问，可能是在代码中进行了二次校验，所以我们将校验方法进行hook绕过原校验机制

```js
function hook_ssl() {
    Java.perform(function() {
        var ClassName = "com.android.org.conscrypt.Platform";
        var Platform = Java.use(ClassName);
        var targetMethod = "checkServerTrusted";
        var len = Platform[targetMethod].overloads.length;
        console.log(len);
        for(var i = 0; i < len; ++i) {
            Platform[targetMethod].overloads[i].implementation = function () {
                console.log("class:", ClassName, "target:", targetMethod, " i:", i, arguments);
                //printStack(ClassName + "." + targetMethod);
            }
        }
    });
}
```

也可以通过objection关闭sslpinning

```
android sslpinning disable
```



另一个安卓证书锁定解除的工具(增加了objection没有覆盖到的场景)

https://github.com/WooyunDota/DroidSSLUnpinning



## 抓包步骤

通过http代理抓包抓不到，通过postern进行socks抓包

使用socks proxy抓包时，记得确认抓包的端口是否包含进去，

可能有些用socks proxy 代理，反而http proxy可以





如果对证书进行了二次校验，可以进行hook，bypass





## VPN检测

https://sanshiok.com/archive/8.html







## TCP

### 服务端

```python
# coding=utf-8
import threading
import socket

socket_list = []

s = socket.socket()
s.bind(('0.0.0.0', 9999))
s.listen()
def read_from_client(s):
    try:
        return s.recv(1024).decode('utf-8')
    except:
        socket_list.remove(s)
def server_target(s):
    try:
        while True:
            content = read_from_client(s)
            if content is None:
                break
            length=len(content)
            if length>0:
                print("receive:"+content)
                response=content+" from server"
                print("send:"+response)
                s.send(response.encode('utf-8'))
    except IOError as e:
        print(e.strerror)


while True:
    c, addr = s.accept() 
    socket_list.append(c)
    threading.Thread(target=server_target, args=(c,)).start()
```



### 客户端

```java
import android.util.Log;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.util.Date;

public class TcpClient {

    public static String ip = "192.168.5.150";
    public static int port = 9999;
    public static boolean connected = false;
    public static Socket socket = null;
    public static OutputStream outputstream = null;
    public static InputStream inputStream = null;
    public static long lastheartresponse = 0;

    public static void start() {
        servicethread();
    }
    
    public static void servicethread() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                heartthread();
                while (true) {
                    if (connected == false) {
                        try {
                            socket = new Socket(ip, port);
                            socket.setSoTimeout(10*1000);
                            connected = true;
                            outputstream = socket.getOutputStream();
                            inputStream = socket.getInputStream();
                            receivethread();
                        } catch (IOException e) {
                            e.printStackTrace();
                            connected = false;
                            socket = null;
                            outputstream = null;
                            inputStream = null;
                        }
                    }
                    if (outputstream != null) {
                        try {
                            JSONObject object = new JSONObject();
                            object.put("msgtype", "heart");
                            sendmsg(object.toString());
                        } catch (JSONException e) {
                            e.printStackTrace();
                        }
                    }
                    try {
                        Thread.currentThread().sleep(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                }
            }
        }).start();
    }
    
    public static void heartthread() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    long currenttime = getTimestamp();
                    if (lastheartresponse != 0) {
                        long offset = currenttime - lastheartresponse;
                        int seconds = (int) (offset / 1000);
                        if (seconds > 10) {
                            close();
                        }
                    }
                    try {
                        Thread.currentThread().sleep(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                }
            }
        }).start();
    }

    public static void receivethread() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                int arraysize = 1024;
                byte[] content = new byte[arraysize];
                while (true) {
                    if (inputStream != null) {
                        try {
                            int count = inputStream.read(content);
                            if (count > 0 && count < arraysize) {
                                byte[] tmparray = new byte[count];
                                System.arraycopy(content, 0, tmparray, 0, count);
                                String str = new String(tmparray, "utf-8");
                            }
                        } catch (IOException e) {
                            e.printStackTrace();
                            close();
                            break;
                        }
                    } else {
                        close();
                        break;
                    }
                }
            }
        }).start();
    }
    
    public static Long getTimestamp() {
        Date date = new Date();
        if (null == date) {
            return (long) 0;
        }
        String timestamp = String.valueOf(date.getTime());
        return Long.valueOf(timestamp);
    }

    public static void close() {
        try {
            if (socket != null) {
                socket.close();
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
        inputStream = null;
        outputstream = null;
        connected = false;
    }

    public static void sendmsg(final String msg) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                if (connected == false) {
                } else {
                    try {
                        if (outputstream != null) {
                            String crypt = msg;
                            outputstream.write(crypt.getBytes("utf-8"));
                            outputstream.flush();
                        }

                    } catch (IOException e) {
                        close();
                        e.printStackTrace();
                    }
                }
            }
        }).start();

    }
}
```





### hook tcp

```js
function LogPrint(log) {
    var theDate = new Date();
    var hour = theDate.getHours();
    var minute = theDate.getMinutes();
    var second = theDate.getSeconds();
    var mSecond = theDate.getMilliseconds();

    hour < 10 ? hour = "0" + hour : hour;
    minute < 10 ? minute = "0" + minute : minute;
    second < 10 ? second = "0" + second : second;
    mSecond < 10 ? mSecond = "00" + mSecond : mSecond < 100 ? mSecond = "0" + mSecond : mSecond;
    var time = hour + ":" + minute + ":" + second + ":" + mSecond;
    var threadid = Process.getCurrentThreadId();
    console.log("[" + time + "]" + "->threadid:" + threadid + "--" + log);
}

function printJavaStack(name) {
    Java.perform(function () {
        var Exception = Java.use("java.lang.Exception");
        var ins = Exception.$new("Exception");
        var straces = ins.getStackTrace();
        if (straces != undefined && straces != null) {
            var strace = straces.toString();
            var replaceStr = strace.replace(/,/g, " \n ");
            LogPrint("=============================" + name + " Stack strat=======================");
            LogPrint(replaceStr);
            LogPrint("=============================" + name + " Stack end======================= \n ");
            Exception.$dispose();
        }
    });
}

// ASCII 可打印字符与控制字符 https://www.cnblogs.com/hyserendipity/p/7376103.html
function isprintable(value) {
    if (value >= 32 && value <= 126) {
        return true;
    }
    return false;
}

function hooktcp() {
    Java.perform(function () {
        var SocketClass = Java.use('java.net.Socket');
        // hook构造方法打印ip和端口
        SocketClass.$init.overload('java.lang.String', 'int').implementation = function (arg0, arg1) {
            console.log("[" + Process.getCurrentThreadId() + "]new Socket connection:" + arg0 + ",port:" + arg1);
            printJavaStack('tcp connect...')
            return this.$init(arg0, arg1);
        }
        
        // hook socketRead0
        var SocketInputStreamClass = Java.use('java.net.SocketInputStream');
        SocketInputStreamClass.socketRead0.implementation = function (arg0, arg1, arg2, arg3, arg4) {
            var size = this.socketRead0(arg0, arg1, arg2, arg3, arg4);
            // 将 Java 数组转换为 JavaScript 字节数组。
            var bytearray = Java.array('byte', arg1);
            var content = '';
            for (var i = 0; i < size; i++) {
                if (isprintable(bytearray[i])) {
                    // 将字节转换为对应的字符
                    content = content + String.fromCharCode(bytearray[i]);
                }
            }
            // this.impl 找到当前对象实现类,可以通过断点调试方式找到想要的属性
            var socketimpl = this.impl.value;
            var address = socketimpl.address.value;
            var port = socketimpl.port.value;
            console.log("\naddress:" + address + ",port" + port + "\n" + JSON.stringify(this.socket.value) + "\n[" + Process.getCurrentThreadId() + "]receive:" + content);
            printJavaStack('socketRead0')
            return size;
        }
        
        // hook socketWrite0
        var SocketOutPutStreamClass = Java.use('java.net.SocketOutputStream');
        SocketOutPutStreamClass.socketWrite0.implementation = function (arg0, arg1, arg2, arg3) {
            var result = this.socketWrite0(arg0, arg1, arg2, arg3);
            var bytearray = Java.array('byte', arg1);
            var content = '';
            for (var i = 0; i < arg3; i++) {
                if (isprintable(bytearray[i])) {
                    content = content + String.fromCharCode(bytearray[i]);
                }
            }
            var socketimpl = this.impl.value;
            var address = socketimpl.address.value;
            var port = socketimpl.port.value;
            console.log("send address:" + address + ",port" + port + "[" + Process.getCurrentThreadId() + "]send:" + content);
            console.log("\n" + JSON.stringify(this.socket.value) + "\n[" + Process.getCurrentThreadId() + "]send:" + content);
            printJavaStack('socketWrite0')
            return result;
        }
    })
}

function main() {
    hooktcp();
}

setImmediate(main)
```



### java调用栈跟踪(8.0)

http://androidxref.com/8.0.0_r4/xref/libcore/ojluni/src/main/java/java/net/SocketInputStream.java

http://androidxref.com/8.0.0_r4/xref/libcore/ojluni/src/main/java/java/net/SocketOutputStream.java

```
java.net.Socket类构造数:new Socket(i,port);
->Socket(InetAddress[] addresses,int port,SocketAddress localAddr,boolean stream)
->impl
->java.net.SocksSocketImpl

建立连接:connect(SocketAddress endpoint)

接收数据:java.net.SocketInputStream.read(byte[]) 
-> read(b, 0, b.length) 
-> read(b, off, length, impl.getTimeout()) 
-> socketRead(fd, b, off, length, timeout) 
-> socketRead0(fd, b, off, len, timeout)  (jni函数)

发送数据:java.net.Socket0utputStream.write(byte[])
-> socketWrite(b, 0, b.length)
-> socketWrite0(fd, b, off, len)  (jni函数)

```

### c调用栈跟踪(8.0)

http://androidxref.com/8.0.0_r4/xref/libcore/ojluni/src/main/native/SocketInputStream.c

http://androidxref.com/8.0.0_r4/xref/libcore/ojluni/src/main/native/SocketOutputStream.c

```
socketRead0(fd, b, off, len, timeout)  (jni函数)
SocketInputStream_socketRead0
NET_Read
ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len) 
(libc中的函数) 
syscall:292 (系统调用号)

socketWrite0(fd, b, off, len)  (jni函数)
SocketOutputStream_socketWrite0
NET_Send
ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len)
syscall:290	

```



查找对应的so方法

```
路径:
libcore-ojluni-src-main-native-SocketOutputStream.c
检索哪个so使用了
cd libcore/ojluni
grep -r SocketOutputStream.c .
输出 - /src/main/native/openjdksub.mk
cat后，未找到编译最终的模块，然后查找是否引用了子模块
cd ..
grep -r openjdksub.mk .
输出 - ./NativeCode.mk
cat后，找到 LOCAL_MODULE := libopenjdkd
然后就可以从手机中导出
adb pull /system/lib/libopenjdk.so
adb pull /system/lib64/libopenjdk.so libopenjdk64.so


导入到IDA中，通过字符串搜索找到SocketInputStream_socketRead0
分析调用了哪些方法
```





### hook tcp(c)

```js
function printNativeStack(context, name) {
    var array = Thread.backtrace(context, Backtracer.ACCURATE);
    // 只回溯一层
    var first = DebugSymbol.fromAddress(array[0]);
    // 通过此判断,避免java和native多次打印
    if (first.toString().indexOf('libopenjdk.so!NET_Send') < 0) {
        var trace = Thread.backtrace(context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join("\n");
        LogPrint("-----------start:" + name + "--------------");
        LogPrint(trace);
        LogPrint("-----------end:" + name + "--------------");
    }
}

function getsocketdetail(fd) {
    var result = "";
    // https://frida.re/docs/javascript-api/#socket
    var type = Socket.type(fd);
    if (type != null) {
        result = result + "type:" + type;
        var peer = Socket.peerAddress(fd);
        var local = Socket.localAddress(fd);
        result = result + ",address:" + JSON.stringify(peer) + ",local:" + JSON.stringify(local);
    } else {
        result = "unknown";
    }
    return result;

}

function hooklibc() {
    var libcmodule = Process.getModuleByName("libc.so");
    var recvfrom_addr = libcmodule.getExportByName("recvfrom");
    var sendto_addr = libcmodule.getExportByName("sendto");
    console.log(recvfrom_addr + "---" + sendto_addr);
    //ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len)
    Interceptor.attach(recvfrom_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];

            LogPrint("go into libc.so->recvfom");

            printNativeStack(this.context, "recvfom");
        }, onLeave(retval) {
            var size = retval.toInt32();
            if (size > 0) {
                var result = getsocketdetail(this.arg0.toInt32());
                console.log(result + "---libc.so->recvfrom:" + hexdump(this.arg1, {
                    length: size
                }));
            }

            LogPrint("leave libc.so->recvfom");
        }
    });
    //ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len)
    Interceptor.attach(sendto_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];
            LogPrint("go into libc.so->sendto");
            printNativeStack(this.context, "sendto");
        }, onLeave(retval) {
            var size = ptr(this.arg2).toInt32();
            if (size > 0) {
                var result = getsocketdetail(this.arg0.toInt32());
                console.log(result + "---libc.so->sendto:" + hexdump(this.arg1, {
                    length: size
                }));
            }

            LogPrint("leave libc.so->sendto");
        }
    });
}

function main() {
    hooklibc();
}

setImmediate(main);
```





## UDP

### 服务端

```js
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import socket
import threading
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind(("0.0.0.0", 8888))
print("UDP bound on port 8888...")

while True:
    data, addr = s.recvfrom(1024)
    print("Receive from %s:%s" %(data,addr))
    if data == b"exit":
        s.sendto(b"Good bye!\n", addr)
        continue
    response=str(data)+" received from udpserver"
    s.sendto(response.encode("utf-8"), addr)
```



### 客户端

```java
import android.util.Log;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.util.Scanner;
import java.util.TreeMap;

public class UdpClient {
    public static final int DEST_PORT = 8888;
    public static final String DEST_IP = "192.168.5.150";
    public static final int DATA_LEN = 4096;
    public static byte[] inBuff = new byte[DATA_LEN];
    public static DatagramSocket socket;
    public static DatagramPacket inPacket = new DatagramPacket(inBuff, inBuff.length);
    public static DatagramPacket outPacket = null;
    
    static {
        try {
            socket = new DatagramSocket();
            receivethread();
        } catch (SocketException e) {
            e.printStackTrace();
        }
    }

    public static void start() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    try {
                        Thread.currentThread().sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    udpsend("i am from udpclient!");
                }
            }
        }).start();
    }
    
    public static void udpsend(String content) {
        try {
            outPacket = new DatagramPacket(new byte[0], 0, InetAddress.getByName(DEST_IP), DEST_PORT);
            byte[] buff = content.getBytes();
            outPacket.setData(buff);
            socket.send(outPacket);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    public static void receivethread() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    try {
                        socket.receive(inPacket);
                        Log.i("udpreceive", new String(inBuff, 0, inPacket.getLength()));
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }
}
```



### hook udp

```js
function hookudp() {
    Java.perform(function () {
        var LinuxClass = Java.use('libcore.io.Linux');
        //private native int recvfromBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, InetSocketAddress srcAddress) throws ErrnoException, SocketException;
        
        // 接收数据
        LinuxClass.recvfromBytes.implementation = function (arg0, arg1, arg2, arg3, arg4, arg5) {
            var size = this.recvfromBytes(arg0, arg1, arg2, arg3, arg4, arg5);
            // arg1在此函数中是object，在上一级是byte[]
            var bytearray = Java.array('byte', arg1);
            var content = "";
            for (var i = 0; i < size; i++) {
                if (isprintable(bytearray[i])) {
                    content = content + String.fromCharCode(bytearray[i]);
                }
            }
            console.log("address:" + arg5 + " [" + Process.getCurrentThreadId() + "]recvfromBytes:size:" + size + ",content:" + JSON.stringify(arg1) + "---content," + content);
            printJavaStack('recvfromBytes');
            return size;
        }
        
        
        //private native int sendtoBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, InetAddress inetAddress, int port) throws ErrnoException, SocketException;
        // private native int sendtoBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, SocketAddress address) throws ErrnoException, SocketException;
        // 发送数据
        LinuxClass.sendtoBytes.overload('java.io.FileDescriptor', 'java.lang.Object', 'int', 'int', 'int', 'java.net.InetAddress', 'int').implementation = function (arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
            var size = this.sendtoBytes(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            var bytearray = Java.array('byte', arg1);
            var content = "";
            for (var i = 0; i < size; i++) {
                if (isprintable(bytearray[i])) {
                    content = content + String.fromCharCode(bytearray[i]);
                }

            }
            console.log("address:" + arg5 + ",port" + arg6 + " [" + Process.getCurrentThreadId() + "]LinuxClass11.sendtoBytes:len:" + size + "--content:" + JSON.stringify(arg1) + "--content:" + content);
            printJavaStack('LinuxClass11.sendtoBytes')
            return size;
        }
        
        // 发送数据(重载)
        LinuxClass.sendtoBytes.overload('java.io.FileDescriptor', 'java.lang.Object', 'int', 'int', 'int', 'java.net.SocketAddress').implementation = function (arg0, arg1, arg2, arg3, arg4, arg5) {
            var size = this.sendtoBytes(arg0, arg1, arg2, arg3, arg4, arg5);
            var bytearray = Java.array('byte', arg1);
            var content = "";
            for (var i = 0; i < size; i++) {
                if (isprintable(bytearray[i])) {
                    content = content + String.fromCharCode(bytearray[i]);
                }
            }
            console.log("address:" + arg5 + " [" + Process.getCurrentThreadId() + "]LinuxClass22.sendtoBytes:len:" + size + "--content:" + JSON.stringify(arg1) + ",content:" + content);
            printJavaStack('LinuxClass22.sendtoBytes')
            return size;
        }
    })
}

function main() {
    hookudp();
}

setImmediate(main)
```





### 调用栈跟踪

```
java.net.DatagramSocket -> receive


发送数据:
PlainDatagramSocketImpl.send
-> IoBridge.sendto(fd, p.getData(), p.getOffset(), p.getLength(), 0, address, port)
-> Libcore.os.sendto(fd, bytes, byteOffset, byteCount, flags, inetAddress, port);

public final class Libcore {
    public static Os rawOs = new Linux();
    public static Os os = new BlockGuardOs(rawOs);
}

-> os.sendto(fd, bytes, byteOffset, byteCount, flags, inetAddress, port);
-> sendtoBytes(fd, bytes, byteOffset, byteCount, flags, inetAddress, port); (jni 函数)
-> private native int sendtoBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, InetAddress inetAddress, int port) throws ErrnoException, SocketException;
  
private native int sendtoBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, SocketAddress address) throws ErrnoException, SocketException; (重载)


接收数据:
...
private native int recvfromBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, InetSocketAddress srcAddress) throws ErrnoException, SocketException;
```



### hook udp(c)

```js
function printNativeStack(context, name) {
    //Debug.
    var array = Thread.backtrace(context, Backtracer.ACCURATE);
    var first = DebugSymbol.fromAddress(array[0]);
    if (first.toString().indexOf('libopenjdk.so!NET_Send') < 0) {
        var trace = Thread.backtrace(context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join("\n");
        LogPrint("-----------start:" + name + "--------------");
        LogPrint(trace);
        LogPrint("-----------end:" + name + "--------------");
    }
}

function getsocketdetail(fd) {
    var result = "";
    var type = Socket.type(fd);
    if (type != null) {
        result = result + "type:" + type;
        var peer = Socket.peerAddress(fd);
        var local = Socket.localAddress(fd);
        result = result + ",address:" + JSON.stringify(peer) + ",local:" + JSON.stringify(local);
    } else {
        result = "unknown";
    }
    return result;
}

function getip(ip_ptr) {
    var result = ptr(ip_ptr).readU8() + "." + ptr(ip_ptr.add(1)).readU8() + "." + ptr(ip_ptr.add(2)).readU8() + "." + ptr(ip_ptr.add(3)).readU8()
    return result;
}

function getudpaddr(addrptr) {
    var port_ptr = addrptr.add(2);
    var port = ptr(port_ptr).readU8() * 256 + ptr(port_ptr.add(1)).readU8();
    var ip_ptr = addrptr.add(4);
    var ip_addr = getip(ip_ptr);
    return "peer:"+ip_addr+"--port:"+port;
}

function hooklibc() {
    var libcmodule = Process.getModuleByName("libc.so");
    var recvfrom_addr = libcmodule.getExportByName("recvfrom");
    var sendto_addr = libcmodule.getExportByName("sendto");
    console.log(recvfrom_addr + "---" + sendto_addr);
    //ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len)
    Interceptor.attach(recvfrom_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];
            this.arg3 = args[3];
            this.arg4 = args[4];
            this.arg5 = args[5];
            LogPrint("go into libc.so->recvfom");
            printNativeStack(this.context, "recvfom");
        }, onLeave(retval) {
            var size = retval.toInt32();
            if (size > 0) {
                var result = getsocketdetail(this.arg0.toInt32());
                if (result.indexOf('udp') >= 0) {
                    /*
                    struct sockaddr_in {
                    	short	sin_family;  // 2字节
                    	u_short	sin_port;   // 2字节
                    	struct in_addr	sin_addr; 
                    	char	sin_zero[8]; // 8字节
                    };
                    */
                    var sockaddr_in_ptr = this.arg4;
                    var sizeofsockaddr_in = this.arg5;

                    //02 00 22 b8 c0 a8 05 96 00 00 00 00 00 00 00 00
                    console.log("this is a recvfrom udp!->" + getudpaddr(sockaddr_in_ptr) + "---" + sizeofsockaddr_in);
                }
                console.log(Process.getCurrentThreadId()+result + "---libc.so->recvfrom:" + hexdump(this.arg1, {
                    length: size
                }));
            }

            LogPrint("leave libc.so->recvfom");
        }
    });
    
    //ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len)
    Interceptor.attach(sendto_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];
            this.arg3 = args[3];
            this.arg4 = args[4];
            this.arg5 = args[5];
            LogPrint("go into libc.so->sendto");
            printNativeStack(this.context, "sendto");
        }, onLeave(retval) {
            var size = ptr(this.arg2).toInt32();
            if (size > 0) {
                var result = getsocketdetail(this.arg0.toInt32());
                if (result.indexOf('udp') >= 0) {
                    var sockaddr_in_ptr = this.arg4;
                    var sizeofsockaddr_in = this.arg5;
                    console.log("this is a sendto udp!->" + getudpaddr(sockaddr_in_ptr) + "---" + sizeofsockaddr_in);
                }
                console.log(Process.getCurrentThreadId()+"---"+result + "---libc.so->sendto:" + hexdump(this.arg1, {
                    length: size
                }));
            }

            LogPrint("leave libc.so->sendto");
        }
    });
}

function main() {
    hooklibc();
}

setImmediate(main);
```





## SSL(okhttp2.6)

### hook sll

```js
function hookssl() {
    Java.perform(function () {
        var NativeCryptoClass = Java.use('com.android.org.conscrypt.NativeCrypto');
        NativeCryptoClass.SSL_read.implementation = function (arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
            var size = this.SSL_read(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            var bytearray = Java.array('byte', arg3);
            var content = '';
            for (var i = 0; i < size; i++) {
                if (isprintable(bytearray[i])) {
                    content = content + String.fromCharCode(bytearray[i]);
                }
            }
            console.log("\n[" + Process.getCurrentThreadId() + "]ssl receive:" + content);
            printJavaStack('NativeCryptoClass.read')
            return size;
        }
        NativeCryptoClass.SSL_write.implementation = function (arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
            var result = this.SSL_write(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            var bytearray = Java.array('byte', arg3);
            var content = '';
            for (var i = 0; i < arg5; i++) {
                if (isprintable(bytearray[i])) {
                    content = content + String.fromCharCode(bytearray[i]);
                }
            }
            console.log("\n[" + Process.getCurrentThreadId() + "]ssl send:" + content);
            printJavaStack('NativeCryptoClass.SSL_write')
            return result;
        }
    })
}
function enumerate() {
    Java.perform(function () {
        Java.enumerateLoadedClassesSync().forEach(function (classname) {
            if (classname.indexOf("NativeCrypto") >= 0) {
                console.log(classname);
            }
        })
    })
}

function main() {
    //enumerate();
    hookssl();
}

setImmediate(main)
```



### 调用栈跟踪

```
sslSocket->com.android.org.conscrypt.0penSSLSocketImplWrapper

前置流程
call.enqueue(Callback responseCallback)
client.getDispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));
getExecutorService().execute(call);
AsyncCall.execute()
Response response = getResponseWithInterceptorChain(forWebSocket);
chain.proceed(originalRequest);
ApplicationInterceptorChain.proceed(Request request)
getResponse(request, forWebSocket);
engine = new HttpEngine(client, request, false, false, forWebSocket, null, null, null, null);
engine.sendRequest();
connect();
Internal.instance.connectAndSetOwner(client, connection, this);
connection.connectAndSetOwner(client, owner);
connect(client.getConnectTimeout(), client.getReadTimeout(), client.getWriteTimeout(),
          connectionSpecs, client.getRetryOnConnectionFailure());
	new Socket(proxy)
	connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);

connectTls(readTimeout, writeTimeout, connectionSpecSelector);
	sslSocket = (SSLSocket) sslSocketFactory.createSocket( socket, address.getUriHost(), address.getUriPort(), true /* autoClose */);
	sslSocket.startHandshake();
	Handshake unverifiedHandshake = Handshake.get(sslSocket.getSession());

httpConnection = new HttpConnection(pool, this, socket);
this.sink = Okio.buffer(Okio.sink(socket));
Sink sink = sink(socket.getOutputStream(), timeout);

发送数据
...
Sink sink = sink(socket.getOutputStream(), timeout);
com.android.org.conscrypt.OpenSSLSocketImpl$SSLOutputStream
public void write(int oneByte)
public void write(byte[] buf, int offset, int byteCount) 
NativeCrypto.SSL_write(sslNativePointer, Platform.getFileDescriptor(socket), OpenSSLSocketImpl.this, buf, offset, byteCount, writeTimeoutMilliseconds);

(org.conscrypt.NativeCrypto)
public static native void SSL_write(long sslNativePointer, FileDescriptor fd, SSLHandshakeCallbacks shc, byte[] b, int off, int len, int writeTimeoutMillis)

(jni)
static void NativeCrypto_SSL_write(JNIEnv* env, jclass, jlong ssl_address, jobject fdObject,
                                   jobject shc, jbyteArray b, jint offset, jint len,
                                   jint write_timeout_millis)

static int sslWrite(JNIEnv* env, SSL* ssl, jobject fdObject, jobject shc, const char* buf, jint len,
                    OpenSslError& sslError, int write_timeout_millis) 

(openssl/boringssl)
int result = SSL_write(ssl, buf, len);
int SSL_write(SSL *ssl, const void *buf, int num) // 明文hook
int ssl3_write_app_data(SSL *ssl, const uint8_t *buf, int len) 

int do_ssl3_write(SSL *ssl, int type, const uint8_t *buf, unsigned len) // 明文密文分界线

ssl3_write_pending(SSL *ssl, int type, const uint8_t *buf, unsigned int len)
int ssl_write_buffer_flush(SSL *ssl)
 if (SSL_is_dtls(ssl)) {
    return dtls_write_buffer_flush(ssl);
  } else {
    return tls_write_buffer_flush(ssl);
  }

int BIO_write(BIO *bio, const void *in, int inl) // libssl-密文hook
static int bio_io(BIO *bio, void *buf, int len, size_t method_offset, int callback_flags, size_t *num) 
io_func = *((const io_func_t *)(((const uint8_t *)bio->method) + method_offset));
static int sock_write(BIO *b, const char *in, int inl)
int ret = (int)write(b->num, in, inl); // // libc-密文hook


接收数据
com.android.org.conscrypt.OpenSSLSocketImpl$SSLInputStream
public int read()
public int read(byte[] buf, int offset, int byteCount)
NativeCrypto.SSL_read(sslNativePointer, Platform.getFileDescriptor(socket), OpenSSLSocketImpl.this, buf, offset, byteCount, getSoTimeout());

public static native int SSL_read(long sslNativePointer, FileDescriptor fd, SSLHandshakeCallbacks shc, byte[] b, int off, int len, int readTimeoutMillis)

```



https://github.com/google/boringssl/blob/58a318edc892a595a5b043359a5d441869158699/crypto/bio/socket.c#L94

openssl并没有使用sendto以及send来发送加密数据，而是使用write函数来发送加密数据

```c
static int sock_read(BIO *b, char *out, int outl) {
  if (out == NULL) {
    return 0;
  }

  bio_clear_socket_error();
#if defined(OPENSSL_WINDOWS)
  int ret = recv(b->num, out, outl, 0);
#else
  int ret = (int)read(b->num, out, outl);
#endif
  BIO_clear_retry_flags(b);
  if (ret <= 0) {
    if (bio_socket_should_retry(ret)) {
      BIO_set_retry_read(b);
    }
  }
  return ret;
}

static int sock_write(BIO *b, const char *in, int inl) {
  bio_clear_socket_error();
#if defined(OPENSSL_WINDOWS)
  int ret = send(b->num, in, inl, 0);
#else
  int ret = (int)write(b->num, in, inl);
#endif
  BIO_clear_retry_flags(b);
  if (ret <= 0) {
    if (bio_socket_should_retry(ret)) {
      BIO_set_retry_write(b);
    }
  }
  return ret;
}
```



### hook ssl all(ip等信息)

```js
function hooksslsocket() {
    Java.perform(function () {
        var SSLInputStreamClass = Java.use('com.android.org.conscrypt.OpenSSLSocketImpl$SSLInputStream');
        SSLInputStreamClass.read.overload().implementation = function () {
            var value = this.read();
            //通过内部类对象得到外部类对象
            var sslsocketimplwrapper = this.this$0.value;
            console.log("SSLInputStreamClass.read 1obj->" + sslsocketimplwrapper);
            var socket = sslsocketimplwrapper.socket.value;
            console.log("SSLInputStreamClass.read 1socket->" + socket);
            console.log("[" + Process.getCurrentThreadId() + "]sslsocket read a int:" + value);
            printJavaStack('sslInputStream.read()')
            return value;
        }
		
        //public int read(byte[] buf, int offset, int byteCount)
        SSLInputStreamClass.read.overload('[B', 'int', 'int').implementation = function (arg0, arg1, arg2) {
            var size = this.read(arg0, arg1, arg2);
            var sslsocketimplwrapper = this.this$0.value;
            console.log("SSLInputStreamClass.read 2obj->" + sslsocketimplwrapper);
            var socket = sslsocketimplwrapper.socket.value;
            console.log("SSLInputStreamClass.read 2socket->" + socket);
            var bytearray = Java.array('byte', arg0);
            var content = '';
            for (var i = 0; i < size; i++) {
                if (isprintable(bytearray[i])) {
                    content = content + String.fromCharCode(bytearray[i]);
                }
            }
            console.log("[" + Process.getCurrentThreadId() + "]sslsocket read:" + content);
            printJavaStack('sslInputStream.read')
            return size;
        }

        var SSLOutputStreamClass = Java.use('com.android.org.conscrypt.OpenSSLSocketImpl$SSLOutputStream');
        SSLOutputStreamClass.write.overload('int').implementation = function (arg0) {
            var result = this.write(arg0);
            var sslsocketimplwrapper = this.this$0.value;
            console.log("SSLOutputStream 1obj->" + sslsocketimplwrapper);
            var socket = sslsocketimplwrapper.socket.value;
            console.log("SSLOutputStream 1socket->" + socket);
            console.log("[" + Process.getCurrentThreadId() + "]write(int):len:" + 4 + "--content:" + arg0);
            printJavaStack('sslOutputStream.write(int)')
            return result;
        }

        //public void write(byte[] buf, int offset, int byteCount)
        SSLOutputStreamClass.write.overload('[B', 'int', 'int').implementation = function (arg0, arg1, arg2) {
            var result = this.write(arg0, arg1, arg2);
            var sslsocketimplwrapper = this.this$0.value;
            console.log("SSLOutputStream 2obj->" + sslsocketimplwrapper);
            var socket = sslsocketimplwrapper.socket.value;
            console.log("SSLOutputStream 2socket->" + socket);
            var bytearray = Java.array('byte', arg0);
            var content = '';
            for (var i = 0; i < arg2; i++) {
                if (isprintable(bytearray[i])) {
                    content = content + String.fromCharCode(bytearray[i]);
                }
            }
            console.log("[" + Process.getCurrentThreadId() + "]sslsocket send:" + content);
            printJavaStack('sslOutputStream.write')
            return result;
        }
    })
}

function main() {
    hooksslsocket();
}

setImmediate(main)0
```





### hook ssl (c)

```js
function printNativeStack(context, name) {
    var array = Thread.backtrace(context, Backtracer.ACCURATE);
    var first = DebugSymbol.fromAddress(array[0]);
    if (first.toString().indexOf('libopenjdk.so!NET_Send') < 0) {
        var trace = Thread.backtrace(context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join("\n");
        LogPrint("-----------start:" + name + "--------------");
        LogPrint(trace);
        LogPrint("-----------end:" + name + "--------------");
    }
}

function getsocketdetail(fd) {
    var result = "";
    var type = Socket.type(fd);
    if (type != null) {
        result = result + "type:" + type;
        var peer = Socket.peerAddress(fd);
        var local = Socket.localAddress(fd);
        result = result + ",address:" + JSON.stringify(peer) + ",local:" + JSON.stringify(local);
    } else {
        result = "unknown";
    }
    return result;

}

function getip(ip_ptr) {
    var result = ptr(ip_ptr).readU8() + "." + ptr(ip_ptr.add(1)).readU8() + "." + ptr(ip_ptr.add(2)).readU8() + "." + ptr(ip_ptr.add(3)).readU8()
    return result;
}

// 密文hook
function hooklibc() {
    var libcmodule = Process.getModuleByName("libc.so");
    var read_addr = libcmodule.getExportByName("read");
    var write_addr = libcmodule.getExportByName("write");
    console.log(read_addr + "---" + write_addr);
    Interceptor.attach(read_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];

            this.socketinfo = getsocketdetail(this.arg0.toInt32());
            LogPrint("go into libc.so->read_addr" + "---" + this.socketinfo);
            this.flag = false;
            if (this.socketinfo.indexOf("tcp") >= 0) {
                this.flag = true;
            }
            if (this.flag) {
                printNativeStack(this.context, Process.getCurrentThreadId() + "read");
            }
        }, onLeave(retval) {
            if (this.flag) {
                var size = retval.toInt32();
                if (size > 0) {
                    console.log(Process.getCurrentThreadId() + "---libc.so->read:" + hexdump(this.arg1, {
                        length: size
                    }));
                }
            }
            LogPrint("leave libc.so->read");
        }
    });
    Interceptor.attach(write_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];

            this.socketinfo = getsocketdetail(this.arg0.toInt32());
            LogPrint("go into libc.so->write" + "---" + this.socketinfo);
            this.flag = false;
            if (this.socketinfo.indexOf("tcp") >= 0) {
                this.flag = true;
            }
            if (this.flag) {
                printNativeStack(this.context, Process.getCurrentThreadId() + "write");
            }


        }, onLeave(retval) {
            if (this.flag) {
                var size = ptr(this.arg2).toInt32();
                if (size > 0) {
                    console.log(Process.getCurrentThreadId() + "---libc.so->write:" + hexdump(this.arg1, {
                        length: size
                    }));
                }
            }

            LogPrint("leave libc.so->write");
        }
    });
}

// 明文hook
function hookssl() {
    var libcmodule = Process.getModuleByName("libssl.so");
    var read_addr = libcmodule.getExportByName("SSL_read");
    var write_addr = libcmodule.getExportByName("SSL_write");
    Interceptor.attach(read_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];
            LogPrint("go into libssl.so->SSL_read");
            printNativeStack(this.context, Process.getCurrentThreadId() + "SSL_read");
        }, onLeave(retval) {
            var size = retval.toInt32();
            if (size > 0) {
                console.log(Process.getCurrentThreadId() + "---libssl.so->SSL_read:" + hexdump(this.arg1, {
                    length: size
                }));
            }
            LogPrint("leave libssl.so->SSL_read");
        }
    });
    Interceptor.attach(write_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];
            LogPrint("go into libssl.so->SSL_write");
            printNativeStack(this.context, Process.getCurrentThreadId() + "SSL_write");
        }, onLeave(retval) {
            var size = ptr(this.arg2).toInt32();
            if (size > 0) {
                console.log(Process.getCurrentThreadId() + "---libssl.so->SSL_write:" + hexdump(this.arg1, {
                    length: size
                }));
            }
            LogPrint("leave libssl.so->SSL_write");
        }
    });
}

function main() {
    //hooklibc();
    hookssl();
}

setImmediate(main);
```





### 自编译openssl

```js
function printNativeStack(context, name) {
    var trace = Thread.backtrace(context, Backtracer.FUZZY).map(DebugSymbol.fromAddress).join("\n");
    LogPrint("-----------start:" + name + "--------------");
    LogPrint(trace);
    LogPrint("-----------end:" + name + "--------------");
}

function getsocketdetail(fd) {
    var result = "";
    var type = Socket.type(fd);
    if (type != null) {
        result = result + "type:" + type;
        var peer = Socket.peerAddress(fd);
        var local = Socket.localAddress(fd);
        result = result + ",address:" + JSON.stringify(peer) + ",local:" + JSON.stringify(local);
    } else {
        result = "unknown";
    }
    return result;
}

function getip(ip_ptr) {
    var result = ptr(ip_ptr).readU8() + "." + ptr(ip_ptr.add(1)).readU8() + "." + ptr(ip_ptr.add(2)).readU8() + "." + ptr(ip_ptr.add(3)).readU8()
    return result;
}

function hooklibc() {
    var libcmodule = Process.getModuleByName("libc.so");
    var read_addr = libcmodule.getExportByName("read");
    var write_addr = libcmodule.getExportByName("write");
    console.log(read_addr + "---" + write_addr);
    Interceptor.attach(read_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];
            this.socketinfo = getsocketdetail(this.arg0.toInt32());
            LogPrint("go into libc.so->read_addr" + "---" + this.socketinfo);
            this.flag = false;
            if (this.socketinfo.indexOf("tcp") >= 0) {
                this.flag = true;
            }
            if (this.flag) {
                printNativeStack(this.context, Process.getCurrentThreadId() + "read");
            }
        }, onLeave(retval) {
            if (this.flag) {
                var size = retval.toInt32();
                if (size > 0) {
                    console.log(Process.getCurrentThreadId() + "---libc.so->read:" + hexdump(this.arg1, {
                        length: size
                    }));
                }
            }
            LogPrint("leave libc.so->read");
        }
    });
    
    Interceptor.attach(write_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];

            this.socketinfo = getsocketdetail(this.arg0.toInt32());
            LogPrint("go into libc.so->write" + "---" + this.socketinfo);
            this.flag = false;
            if (this.socketinfo.indexOf("tcp") >= 0) {
                this.flag = true;
            }
            if (this.flag) {
                printNativeStack(this.context, Process.getCurrentThreadId() + "write");
                var size = ptr(this.arg2).toInt32();
                if (size > 0) {
                    console.log(Process.getCurrentThreadId() + "---libc.so->write:" + hexdump(this.arg1, {
                        length: size
                    }));
                }
            }
        }, onLeave(retval) {
            LogPrint("leave libc.so->write");
        }
    });
}

function hookssl() {
    //SSL_get_rfd
    //int SSL_get_rfd(const SSL *ssl)
    var libsslmodule = Process.getModuleByName("libssl.so");
    var read_addr = libsslmodule.getExportByName("SSL_read");
    var write_addr = libsslmodule.getExportByName("SSL_write");
    var bioread_addr = libsslmodule.getExportByName("BIO_read");
    var biowrite_addr = libsslmodule.getExportByName("BIO_write");
    var SSL_get_rfd_ptr = libsslmodule.getExportByName('SSL_get_rfd');
    var SSL_get_rfd = new NativeFunction(SSL_get_rfd_ptr, 'int', ['pointer']);
    Interceptor.attach(read_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];
            LogPrint("go into libssl.so->SSL_read");
            printNativeStack(this.context, Process.getCurrentThreadId() + "SSL_read");
        }, onLeave(retval) {
            var size = retval.toInt32();
            if (size > 0) {
                var sockfd = SSL_get_rfd(this.arg0);
                var socketdetail = getsocketdetail(sockfd);
                console.log(socketdetail + "---" + Process.getCurrentThreadId() + "---libssl.so->SSL_read:" + hexdump(this.arg1, {
                    length: size
                }));
            }
            LogPrint("leave libssl.so->SSL_read");
        }
    });
    Interceptor.attach(write_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];
            LogPrint("go into libssl.so->SSL_write");
            printNativeStack(this.context, Process.getCurrentThreadId() + "SSL_write");
            var size = ptr(this.arg2).toInt32();
            if (size > 0) {
                var sockfd = SSL_get_rfd(this.arg0);
                var socketdetail = getsocketdetail(sockfd);
                console.log(socketdetail + "---" + Process.getCurrentThreadId() + "---libssl.so->SSL_write:" + hexdump(this.arg1, {
                    length: size
                }));
            }
        }, onLeave(retval) {
            LogPrint("leave libssl.so->SSL_write");
        }
    });
    Interceptor.attach(bioread_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];
            LogPrint("go into libssl.so->bioread_addr");
            printNativeStack(this.context, Process.getCurrentThreadId() + "bioread_addr");
        }, onLeave(retval) {
            var size = retval.toInt32();
            if (size > 0) {
                var sockfd = SSL_get_rfd(this.arg0);
                var socketdetail = getsocketdetail(sockfd);
                console.log(socketdetail + "---" + Process.getCurrentThreadId() + "---libssl.so->bioread_addr:" + hexdump(this.arg1, {
                    length: size
                }));
            }
            LogPrint("leave libssl.so->bioread_addr");
        }
    });
    Interceptor.attach(biowrite_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];
            LogPrint("go into libssl.so->biowrite_addr");
            printNativeStack(this.context, Process.getCurrentThreadId() + "biowrite_addr");
            var size = ptr(this.arg2).toInt32();
            if (size > 0) {
                var sockfd = SSL_get_rfd(this.arg0);
                var socketdetail = getsocketdetail(sockfd);
                console.log(socketdetail + "---" + Process.getCurrentThreadId() + "---libssl.so->biowrite_addr:" + hexdump(this.arg1, {
                    length: size
                }));
            }
        }, onLeave(retval) {

            LogPrint("leave libssl.so->biowrite_addr");
        }
    });
}

function hookallssl() {
    var libsslmodule = Process.getModuleByName("libssl.so");
    var SSL_get_rfd_ptr = libsslmodule.getExportByName('SSL_get_rfd');
    var SSL_get_rfd = new NativeFunction(SSL_get_rfd_ptr, 'int', ['pointer']);
    Process.enumerateModules().forEach(function (module) {
        module.enumerateExports().forEach(function (symbol) {
            var name = symbol.name;
            if (name == 'SSL_read') {
                LogPrint(JSON.stringify(module) + JSON.stringify(symbol));
            }
            if (name == 'SSL_write') {
                LogPrint(JSON.stringify(module) + JSON.stringify(symbol));
                Interceptor.attach(symbol.address, {
                    onEnter: function (args) {
                        this.arg0 = args[0];
                        this.arg1 = args[1];
                        this.arg2 = args[2];
                        LogPrint("go into " + Process.getCurrentThreadId() + "---" + JSON.stringify(module) + "---" + JSON.stringify(symbol));
                        printNativeStack(this.context, Process.getCurrentThreadId() + "---" + JSON.stringify(module) + "---" + JSON.stringify(symbol));
                        var size = ptr(this.arg2).toInt32();
                        if (size > 0) {
                            var sockfd = SSL_get_rfd(this.arg0);
                            var socketdetail = getsocketdetail(sockfd);
                            console.log(socketdetail + "---" + Process.getCurrentThreadId() + "---" + JSON.stringify(module) + "---" + JSON.stringify(symbol) + hexdump(this.arg1, {
                                length: size
                            }));
                        }
                    }, onLeave(retval) {
                        LogPrint("leave " + Process.getCurrentThreadId() + "---" + JSON.stringify(module) + "---" + JSON.stringify(symbol));
                    }
                });
            }
        })
    })
}

function main() {
    hooklibc();
    hookssl();
    //hookallssl();
}

setImmediate(main);
```





## okHttp反混淆方案

```
通过jadx-gui检索字符串okhttp/ 可以查到okhttp使用的具体版本
然后通过自己的项目依赖此版本

通过对比混淆前后的代码，例如excute函数，找到关键字符串,然后再混淆app进行检索该字符串，控制流等信息，找到对应的方法

通过hook相同的代码，打印出堆栈信息进行一一对应
```





## 常见问题

1.SSL: Unsupported or unrecognized SSL message

可能端口没有识别，在抓包软件中增加对应的端口









## 其他知识

### 主机网路计算

```
wlan0     Link encap:Ethernet  HWaddr 40:4e:36:90:a0:59  Driver icnss
          inet addr:10.128.171.254  Bcast:10.128.191.255  Mask:255.255.192.0
          inet6 addr: 2001:250:6010:8080:5929:c1c8:6914:9b67/64 Scope: Global
          inet6 addr: 2001:250:6010:8080:806:e1e3:a941:2a65/64 Scope: Global
          inet6 addr: fe80::a58d:c6fb:9846:37b5/64 Scope: Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:868180 errors:0 dropped:0 overruns:0 frame:0
          TX packets:463502 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:3000
          RX bytes:1116035368 TX bytes:62077305
```

```
wlan0的IPv4地址是10.128.171.254，子网掩码是255.255.192.0
IPv4地址：10.128.171.254（二进制表示为00001010.10000000.10101011.11111110）

子网掩码：255.255.192.0（二进制表示为11111111.11111111.11000000.00000000）

按位与运算结果为：00001010.10000000.10000000.00000000，即10.128.128.0。

子网掩码是255.255.192.0，这意味着有18位用于网络地址（/18子网掩码）。因此，剩下的14位用于主机地址。

```

