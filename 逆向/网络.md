# 网络

## 环境

### 抓包软件

charles

burpsuite(不支持websocks)

手机代理软件:postern

配置指南:https://blog.csdn.net/MoMozzzzz/article/details/123216616



注：如果使用虚拟机抓包，网络配置需要改成桥接模式







### 证书读取软件

https://keystore-explorer.org/downloads.html



### OSI模型对应?

```
应用
表示
会话
传输
网络
数据链路
物理
```

- 应用层：`Http(s)`协议抓包
- 会话层：`Socket`端口通信抓包(TCP层？)
- 路由层：VPN抓包



socket协议对应传输层



### 防止抓包设置

不同框架中设置 Proxy.NO_PROXY







## 证书

### 证书迁移(用户到系统)

方法一

magisk：MoveCertificate

https://github.com/ys1231/MoveCertificate



方法二(8.1之前？)

```
cd /data/misc/user/0/cacerts-added
mount -o remount,rw /
cp * /etc/security/cacerts/
mount -o remount,ro /
```





### 证书dump

```js
function hook_KeyStore_load() {
    Java.perform(function () {
        var ByteString = Java.use("com.android.okhttp.okio.ByteString");
        var myArray=new Array(1024);
        var i = 0
        for (i = 0; i < myArray.length; i++) {
            myArray[i]= 0x0;
         }
        var buffer = Java.array('byte',myArray);
        
        var StringClass = Java.use("java.lang.String");
        var KeyStore = Java.use("java.security.KeyStore");
        KeyStore.load.overload('java.security.KeyStore$LoadStoreParameter').implementation = function (arg0) {
            console.log(Java.use("android.util.Log").getStackTraceString(Java.use("java.lang.Throwable").$new()));

            console.log("KeyStore.load1:", arg0);
            this.load(arg0);
        };
        KeyStore.load.overload('java.io.InputStream', '[C').implementation = function (arg0, arg1) {
            console.log(Java.use("android.util.Log").getStackTraceString(Java.use("java.lang.Throwable").$new()));

            console.log("KeyStore.load2:", arg0, arg1 ? StringClass.$new(arg1) : null);

            if (arg0){
                var file =  Java.use("java.io.File").$new("/sdcard/Download/"+ String(arg0)+".p12");
                var out = Java.use("java.io.FileOutputStream").$new(file);
                var r;
                while( (r = arg0.read(buffer)) > 0){
                    out.write(buffer,0,r)
                }
                console.log("save success!")
                out.close()
            }
            this.load(arg0, arg1);
        };
        console.log("hook_KeyStore_load...");
    });
}
```





### SSL pinning:对证书在代码中进行额外校验

在自定义证书已经配置好情况下，还是无法访问，可能是在代码中进行了二次校验，所以我们将校验方法进行hook绕过原校验机制

```js
function hook_ssl() {
    Java.perform(function() {
        var ClassName = "com.android.org.conscrypt.Platform";
        var Platform = Java.use(ClassName);
        var targetMethod = "checkServerTrusted";
        var len = Platform[targetMethod].overloads.length;
        console.log(len);
        for(var i = 0; i < len; ++i) {
            Platform[targetMethod].overloads[i].implementation = function () {
                console.log("class:", ClassName, "target:", targetMethod, " i:", i, arguments);
                //printStack(ClassName + "." + targetMethod);
            }
        }
    });
}
```

也可以通过objection关闭sslpinning

```
android sslpinning disable
```



另一个安卓证书锁定解除的工具(增加了objection没有覆盖到的场景)

https://github.com/WooyunDota/DroidSSLUnpinning



## 抓包步骤

通过http代理抓包抓不到，通过postern进行socks抓包

使用socks proxy抓包时，记得确认抓包的端口是否包含进去，

可能有些用socks proxy 代理，反而http proxy可以





如果对证书进行了二次校验，可以进行hook，bypass





## VPN检测

https://sanshiok.com/archive/8.html







## TCP

### 服务端

```python
# coding=utf-8
import threading
import socket

socket_list = []

s = socket.socket()
s.bind(('0.0.0.0', 9999))
s.listen()
def read_from_client(s):
    try:
        return s.recv(1024).decode('utf-8')
    except:
        socket_list.remove(s)
def server_target(s):
    try:
        while True:
            content = read_from_client(s)
            if content is None:
                break
            length=len(content)
            if length>0:
                print("receive:"+content)
                response=content+" from server"
                print("send:"+response)
                s.send(response.encode('utf-8'))
    except IOError as e:
        print(e.strerror)


while True:
    c, addr = s.accept() 
    socket_list.append(c)
    threading.Thread(target=server_target, args=(c,)).start()
```



### 客户端

```java
import android.util.Log;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.util.Date;

public class TcpClient {

    public static String ip = "192.168.5.150";
    public static int port = 9999;
    public static boolean connected = false;
    public static Socket socket = null;
    public static OutputStream outputstream = null;
    public static InputStream inputStream = null;
    public static long lastheartresponse = 0;

    public static void start() {
        servicethread();
    }
    
    public static void servicethread() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                heartthread();
                while (true) {
                    if (connected == false) {
                        try {
                            socket = new Socket(ip, port);
                            socket.setSoTimeout(10*1000);
                            connected = true;
                            outputstream = socket.getOutputStream();
                            inputStream = socket.getInputStream();
                            receivethread();
                        } catch (IOException e) {
                            e.printStackTrace();
                            connected = false;
                            socket = null;
                            outputstream = null;
                            inputStream = null;
                        }
                    }
                    if (outputstream != null) {
                        try {
                            JSONObject object = new JSONObject();
                            object.put("msgtype", "heart");
                            sendmsg(object.toString());
                        } catch (JSONException e) {
                            e.printStackTrace();
                        }
                    }
                    try {
                        Thread.currentThread().sleep(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                }
            }
        }).start();
    }
    
    public static void heartthread() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    long currenttime = getTimestamp();
                    if (lastheartresponse != 0) {
                        long offset = currenttime - lastheartresponse;
                        int seconds = (int) (offset / 1000);
                        if (seconds > 10) {
                            close();
                        }
                    }
                    try {
                        Thread.currentThread().sleep(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                }
            }
        }).start();
    }

    public static void receivethread() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                int arraysize = 1024;
                byte[] content = new byte[arraysize];
                while (true) {
                    if (inputStream != null) {
                        try {
                            int count = inputStream.read(content);
                            if (count > 0 && count < arraysize) {
                                byte[] tmparray = new byte[count];
                                System.arraycopy(content, 0, tmparray, 0, count);
                                String str = new String(tmparray, "utf-8");
                            }
                        } catch (IOException e) {
                            e.printStackTrace();
                            close();
                            break;
                        }
                    } else {
                        close();
                        break;
                    }
                }
            }
        }).start();
    }
    
    public static Long getTimestamp() {
        Date date = new Date();
        if (null == date) {
            return (long) 0;
        }
        String timestamp = String.valueOf(date.getTime());
        return Long.valueOf(timestamp);
    }

    public static void close() {
        try {
            if (socket != null) {
                socket.close();
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
        inputStream = null;
        outputstream = null;
        connected = false;
    }

    public static void sendmsg(final String msg) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                if (connected == false) {
                } else {
                    try {
                        if (outputstream != null) {
                            String crypt = msg;
                            outputstream.write(crypt.getBytes("utf-8"));
                            outputstream.flush();
                        }

                    } catch (IOException e) {
                        close();
                        e.printStackTrace();
                    }
                }
            }
        }).start();

    }
}
```





### hook tcp

```js
function LogPrint(log) {
    var theDate = new Date();
    var hour = theDate.getHours();
    var minute = theDate.getMinutes();
    var second = theDate.getSeconds();
    var mSecond = theDate.getMilliseconds();

    hour < 10 ? hour = "0" + hour : hour;
    minute < 10 ? minute = "0" + minute : minute;
    second < 10 ? second = "0" + second : second;
    mSecond < 10 ? mSecond = "00" + mSecond : mSecond < 100 ? mSecond = "0" + mSecond : mSecond;
    var time = hour + ":" + minute + ":" + second + ":" + mSecond;
    var threadid = Process.getCurrentThreadId();
    console.log("[" + time + "]" + "->threadid:" + threadid + "--" + log);
}

function printJavaStack(name) {
    Java.perform(function () {
        var Exception = Java.use("java.lang.Exception");
        var ins = Exception.$new("Exception");
        var straces = ins.getStackTrace();
        if (straces != undefined && straces != null) {
            var strace = straces.toString();
            var replaceStr = strace.replace(/,/g, " \n ");
            LogPrint("=============================" + name + " Stack strat=======================");
            LogPrint(replaceStr);
            LogPrint("=============================" + name + " Stack end======================= \n ");
            Exception.$dispose();
        }
    });
}

// ASCII 可打印字符与控制字符 https://www.cnblogs.com/hyserendipity/p/7376103.html
function isprintable(value) {
    if (value >= 32 && value <= 126) {
        return true;
    }
    return false;
}

function hooktcp() {
    Java.perform(function () {
        var SocketClass = Java.use('java.net.Socket');
        // hook构造方法打印ip和端口
        SocketClass.$init.overload('java.lang.String', 'int').implementation = function (arg0, arg1) {
            console.log("[" + Process.getCurrentThreadId() + "]new Socket connection:" + arg0 + ",port:" + arg1);
            printJavaStack('tcp connect...')
            return this.$init(arg0, arg1);
        }
        
        // hook socketRead0
        var SocketInputStreamClass = Java.use('java.net.SocketInputStream');
        SocketInputStreamClass.socketRead0.implementation = function (arg0, arg1, arg2, arg3, arg4) {
            var size = this.socketRead0(arg0, arg1, arg2, arg3, arg4);
            // 将 Java 数组转换为 JavaScript 字节数组。
            var bytearray = Java.array('byte', arg1);
            var content = '';
            for (var i = 0; i < size; i++) {
                if (isprintable(bytearray[i])) {
                    // 将字节转换为对应的字符
                    content = content + String.fromCharCode(bytearray[i]);
                }
            }
            // this.impl 找到当前对象实现类,可以通过断点调试方式找到想要的属性
            var socketimpl = this.impl.value;
            var address = socketimpl.address.value;
            var port = socketimpl.port.value;
            console.log("\naddress:" + address + ",port" + port + "\n" + JSON.stringify(this.socket.value) + "\n[" + Process.getCurrentThreadId() + "]receive:" + content);
            printJavaStack('socketRead0')
            return size;
        }
        
        // hook socketWrite0
        var SocketOutPutStreamClass = Java.use('java.net.SocketOutputStream');
        SocketOutPutStreamClass.socketWrite0.implementation = function (arg0, arg1, arg2, arg3) {
            var result = this.socketWrite0(arg0, arg1, arg2, arg3);
            var bytearray = Java.array('byte', arg1);
            var content = '';
            for (var i = 0; i < arg3; i++) {
                if (isprintable(bytearray[i])) {
                    content = content + String.fromCharCode(bytearray[i]);
                }
            }
            var socketimpl = this.impl.value;
            var address = socketimpl.address.value;
            var port = socketimpl.port.value;
            console.log("send address:" + address + ",port" + port + "[" + Process.getCurrentThreadId() + "]send:" + content);
            console.log("\n" + JSON.stringify(this.socket.value) + "\n[" + Process.getCurrentThreadId() + "]send:" + content);
            printJavaStack('socketWrite0')
            return result;
        }
    })
}

function main() {
    hooktcp();
}

setImmediate(main)
```



### 调用栈跟踪(8.0)

http://androidxref.com/8.0.0_r4/xref/libcore/ojluni/src/main/java/java/net/SocketInputStream.java

http://androidxref.com/8.0.0_r4/xref/libcore/ojluni/src/main/java/java/net/SocketOutputStream.java

```
java.net.Socket类构造数:new Socket(i,port);
->Socket(InetAddress[] addresses,int port,SocketAddress localAddr,boolean stream)
->impl
->java.net.SocksSocketImpl

建立连接:connect(SocketAddress endpoint)

接收数据:java.net.SocketInputStream.read(byte[]) 
-> read(b, 0, b.length) 
-> read(b, off, length, impl.getTimeout()) 
-> socketRead(fd, b, off, length, timeout) 
-> socketRead0(fd, b, off, len, timeout)  (jni函数)

发送数据:java.net.Socket0utputStream.write(byte[])
-> socketWrite(b, 0, b.length)
-> socketWrite0(fd, b, off, len)  (jni函数)

```





## UDP

### 服务端

```js
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import socket
import threading
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind(("0.0.0.0", 8888))
print("UDP bound on port 8888...")

while True:
    data, addr = s.recvfrom(1024)
    print("Receive from %s:%s" %(data,addr))
    if data == b"exit":
        s.sendto(b"Good bye!\n", addr)
        continue
    response=str(data)+" received from udpserver"
    s.sendto(response.encode("utf-8"), addr)
```



### 客户端

```java
import android.util.Log;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.util.Scanner;
import java.util.TreeMap;

public class UdpClient {
    public static final int DEST_PORT = 8888;
    public static final String DEST_IP = "192.168.5.150";
    public static final int DATA_LEN = 4096;
    public static byte[] inBuff = new byte[DATA_LEN];
    public static DatagramSocket socket;
    public static DatagramPacket inPacket = new DatagramPacket(inBuff, inBuff.length);
    public static DatagramPacket outPacket = null;
    
    static {
        try {
            socket = new DatagramSocket();
            receivethread();
        } catch (SocketException e) {
            e.printStackTrace();
        }
    }

    public static void start() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    try {
                        Thread.currentThread().sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    udpsend("i am from udpclient!");
                }
            }
        }).start();
    }
    
    public static void udpsend(String content) {
        try {
            outPacket = new DatagramPacket(new byte[0], 0, InetAddress.getByName(DEST_IP), DEST_PORT);
            byte[] buff = content.getBytes();
            outPacket.setData(buff);
            socket.send(outPacket);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    public static void receivethread() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    try {
                        socket.receive(inPacket);
                        Log.i("udpreceive", new String(inBuff, 0, inPacket.getLength()));
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }
}
```



### hook udp

```js
function hookudp() {
    Java.perform(function () {
        var LinuxClass = Java.use('libcore.io.Linux');
        //private native int recvfromBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, InetSocketAddress srcAddress) throws ErrnoException, SocketException;
        
        // 接收数据
        LinuxClass.recvfromBytes.implementation = function (arg0, arg1, arg2, arg3, arg4, arg5) {
            var size = this.recvfromBytes(arg0, arg1, arg2, arg3, arg4, arg5);
            // arg1在此函数中是object，在上一级是byte[]
            var bytearray = Java.array('byte', arg1);
            var content = "";
            for (var i = 0; i < size; i++) {
                if (isprintable(bytearray[i])) {
                    content = content + String.fromCharCode(bytearray[i]);
                }
            }
            console.log("address:" + arg5 + " [" + Process.getCurrentThreadId() + "]recvfromBytes:size:" + size + ",content:" + JSON.stringify(arg1) + "---content," + content);
            printJavaStack('recvfromBytes');
            return size;
        }
        
        
        //private native int sendtoBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, InetAddress inetAddress, int port) throws ErrnoException, SocketException;
        // private native int sendtoBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, SocketAddress address) throws ErrnoException, SocketException;
        // 发送数据
        LinuxClass.sendtoBytes.overload('java.io.FileDescriptor', 'java.lang.Object', 'int', 'int', 'int', 'java.net.InetAddress', 'int').implementation = function (arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
            var size = this.sendtoBytes(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            var bytearray = Java.array('byte', arg1);
            var content = "";
            for (var i = 0; i < size; i++) {
                if (isprintable(bytearray[i])) {
                    content = content + String.fromCharCode(bytearray[i]);
                }

            }
            console.log("address:" + arg5 + ",port" + arg6 + " [" + Process.getCurrentThreadId() + "]LinuxClass11.sendtoBytes:len:" + size + "--content:" + JSON.stringify(arg1) + "--content:" + content);
            printJavaStack('LinuxClass11.sendtoBytes')
            return size;
        }
        
        // 发送数据(重载)
        LinuxClass.sendtoBytes.overload('java.io.FileDescriptor', 'java.lang.Object', 'int', 'int', 'int', 'java.net.SocketAddress').implementation = function (arg0, arg1, arg2, arg3, arg4, arg5) {
            var size = this.sendtoBytes(arg0, arg1, arg2, arg3, arg4, arg5);
            var bytearray = Java.array('byte', arg1);
            var content = "";
            for (var i = 0; i < size; i++) {
                if (isprintable(bytearray[i])) {
                    content = content + String.fromCharCode(bytearray[i]);
                }
            }
            console.log("address:" + arg5 + " [" + Process.getCurrentThreadId() + "]LinuxClass22.sendtoBytes:len:" + size + "--content:" + JSON.stringify(arg1) + ",content:" + content);
            printJavaStack('LinuxClass22.sendtoBytes')
            return size;
        }
    })
}

function main() {
    hookudp();
}

setImmediate(main)
```





### 调用栈跟踪

```
java.net.DatagramSocket -> receive


发送数据:
PlainDatagramSocketImpl.send
-> IoBridge.sendto(fd, p.getData(), p.getOffset(), p.getLength(), 0, address, port)
-> Libcore.os.sendto(fd, bytes, byteOffset, byteCount, flags, inetAddress, port);

public final class Libcore {
    public static Os rawOs = new Linux();
    public static Os os = new BlockGuardOs(rawOs);
}

-> os.sendto(fd, bytes, byteOffset, byteCount, flags, inetAddress, port);
-> sendtoBytes(fd, bytes, byteOffset, byteCount, flags, inetAddress, port); (jni 函数)
-> private native int sendtoBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, InetAddress inetAddress, int port) throws ErrnoException, SocketException;
  
private native int sendtoBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, SocketAddress address) throws ErrnoException, SocketException; (重载)


接收数据:
...
private native int recvfromBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, InetSocketAddress srcAddress) throws ErrnoException, SocketException;
```



## SSL(okhttp2.6)

### hook sll

```js
function hookssl() {
    Java.perform(function () {
        var NativeCryptoClass = Java.use('com.android.org.conscrypt.NativeCrypto');
        NativeCryptoClass.SSL_read.implementation = function (arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
            var size = this.SSL_read(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            var bytearray = Java.array('byte', arg3);
            var content = '';
            for (var i = 0; i < size; i++) {
                if (isprintable(bytearray[i])) {
                    content = content + String.fromCharCode(bytearray[i]);
                }
            }
            console.log("\n[" + Process.getCurrentThreadId() + "]ssl receive:" + content);
            printJavaStack('NativeCryptoClass.read')
            return size;
        }
        NativeCryptoClass.SSL_write.implementation = function (arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
            var result = this.SSL_write(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            var bytearray = Java.array('byte', arg3);
            var content = '';
            for (var i = 0; i < arg5; i++) {
                if (isprintable(bytearray[i])) {
                    content = content + String.fromCharCode(bytearray[i]);
                }
            }
            console.log("\n[" + Process.getCurrentThreadId() + "]ssl send:" + content);
            printJavaStack('NativeCryptoClass.SSL_write')
            return result;
        }
    })
}
function enumerate() {
    Java.perform(function () {
        Java.enumerateLoadedClassesSync().forEach(function (classname) {
            if (classname.indexOf("NativeCrypto") >= 0) {
                console.log(classname);
            }
        })
    })
}

function main() {
    //enumerate();
    hookssl();
}

setImmediate(main)
```



### 调用栈跟踪

```
sslSocket->com.android.org.conscrypt.0penSSLSocketImplWrapper

前置流程
call.enqueue(Callback responseCallback)
client.getDispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));
getExecutorService().execute(call);
AsyncCall.execute()
Response response = getResponseWithInterceptorChain(forWebSocket);
chain.proceed(originalRequest);
ApplicationInterceptorChain.proceed(Request request)
getResponse(request, forWebSocket);
engine = new HttpEngine(client, request, false, false, forWebSocket, null, null, null, null);
engine.sendRequest();
connect();
Internal.instance.connectAndSetOwner(client, connection, this);
connection.connectAndSetOwner(client, owner);
connect(client.getConnectTimeout(), client.getReadTimeout(), client.getWriteTimeout(),
          connectionSpecs, client.getRetryOnConnectionFailure());
	new Socket(proxy)
	connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);

connectTls(readTimeout, writeTimeout, connectionSpecSelector);
	sslSocket = (SSLSocket) sslSocketFactory.createSocket( socket, address.getUriHost(), address.getUriPort(), true /* autoClose */);
	sslSocket.startHandshake();
	Handshake unverifiedHandshake = Handshake.get(sslSocket.getSession());

httpConnection = new HttpConnection(pool, this, socket);
this.sink = Okio.buffer(Okio.sink(socket));
Sink sink = sink(socket.getOutputStream(), timeout);

发送数据
...
Sink sink = sink(socket.getOutputStream(), timeout);
com.android.org.conscrypt.OpenSSLSocketImpl$SSLOutputStream
public void write(int oneByte)
public void write(byte[] buf, int offset, int byteCount) 
NativeCrypto.SSL_write(sslNativePointer, Platform.getFileDescriptor(socket), OpenSSLSocketImpl.this, buf, offset, byteCount, writeTimeoutMilliseconds);

(org.conscrypt.NativeCrypto)
public static native void SSL_write(long sslNativePointer, FileDescriptor fd, SSLHandshakeCallbacks shc, byte[] b, int off, int len, int writeTimeoutMillis)


接收数据
com.android.org.conscrypt.OpenSSLSocketImpl$SSLInputStream
public int read()
public int read(byte[] buf, int offset, int byteCount)
NativeCrypto.SSL_read(sslNativePointer, Platform.getFileDescriptor(socket), OpenSSLSocketImpl.this, buf, offset, byteCount, getSoTimeout());

public static native int SSL_read(long sslNativePointer, FileDescriptor fd, SSLHandshakeCallbacks shc, byte[] b, int off, int len, int readTimeoutMillis)

```





## 常见问题

1.SSL: Unsupported or unrecognized SSL message

可能端口没有识别，在抓包软件中增加对应的端口









## 其他知识

### 主机网路计算

```
wlan0     Link encap:Ethernet  HWaddr 40:4e:36:90:a0:59  Driver icnss
          inet addr:10.128.171.254  Bcast:10.128.191.255  Mask:255.255.192.0
          inet6 addr: 2001:250:6010:8080:5929:c1c8:6914:9b67/64 Scope: Global
          inet6 addr: 2001:250:6010:8080:806:e1e3:a941:2a65/64 Scope: Global
          inet6 addr: fe80::a58d:c6fb:9846:37b5/64 Scope: Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:868180 errors:0 dropped:0 overruns:0 frame:0
          TX packets:463502 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:3000
          RX bytes:1116035368 TX bytes:62077305
```

```
wlan0的IPv4地址是10.128.171.254，子网掩码是255.255.192.0
IPv4地址：10.128.171.254（二进制表示为00001010.10000000.10101011.11111110）

子网掩码：255.255.192.0（二进制表示为11111111.11111111.11000000.00000000）

按位与运算结果为：00001010.10000000.10000000.00000000，即10.128.128.0。

子网掩码是255.255.192.0，这意味着有18位用于网络地址（/18子网掩码）。因此，剩下的14位用于主机地址。

```

