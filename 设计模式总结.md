# 设计模式总结

创建型模式：静态工厂模式、工厂方法模式、抽象工厂模式、
	单例模式、建造者模式

结构型模式：桥接模式、适配器模式、装饰器模式、代理模式、组合模式 

行为型模式：模板方法模式、策略模式、观察者模式、
责任链模式、命令模式、访问者模式 



## 设计模式六大原则

开闭原则：对扩展开放，修改一关闭

单一职责原则：一个类只负责一项职责

里式替换原则：子类可以扩展父类功能，但不要改变父类原有的功能

依赖倒置原则：面向接口编程

接口隔离原则：设计接口功能尽量细粒度，最小功能单元

迪米特法则：降低耦合（局部变量中，不要引入新的类）



## 创建型模式

### 工厂模式&建造者模式:

总结:

原则：
1、解耦：把对象的创建和使用的过程分开。
2、工厂负责对象的创建，包括其init方法的调用，黑盒创建过程。
3、面向接口编程： 使用者只管使用，只知其接口而不知其实现类。
对比：
4、静态工厂：把所有对象的创建逻辑集中到一个（专业）类里处理
5、工厂方法模式：一个工厂负责创建一个产品类的创建
6、抽象工厂模式:将一个系列的产品的工厂合并成一个工厂，负责生产这个系列的产品
7、建造者模式:对象的创建比较复杂时，按步骤一块块创建，让创建过程模板化。



### 单例模式:

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

1、为防止实例实创建多个，将构造函数限制为private。
2、建一个类静态变量，持有一个自己的实例。
3、通过静态方式对外部提供这一实例。

对静态实例的初始化，有两种方式：饿汉式和懒汉式

懒汉式:DCL，枚举，静态内部类



## 结构型模式

### 适配器模式:

将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。(例如多种格式播放器)

组合中，a、b变量名持有的对象，可以是A、B类的子类。
在程序的运行中，还可以更换a、b实际的对象，更为灵活



### 桥接模式:

将两个维度变化的功能组合起来，为的是独立变化



**适配器模式与桥接模式区别:**

都是把两个对象组合起来配合工作。桥接的目标是分离，适配的目标是合并。



### 装饰器模式:

动态地给一个对象增加一些额外的职责，为的是功能增强。(例如:FileOutPutStream)



### 代理模式:

定义：给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用；
目的：（1）通过引入代理对象的方式来间接访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性； （2）通过代理对象对原有的业务增强；



静态代理:扩展能力差，可维护性差，违反开闭原则

动态代理:扩展能力强，多个接口兼容

创建:

```java
Proxy.newProxyInstance(factory.getClass().getClassLoader(),
        factory.getClass().getInterfaces(),this)
```

自动生成代理类$Proxy0

mX:内部通过反射获取方法

```java
ProxyGenerator.generateProxyClass(proxyName, new Class[]{clazz})
```





**代理模式与装饰模式区别**:

都是当前对象无法胜任主功能，转给第三方对象来完成主功能。
装饰目标是增强自身（第三方是我内部），代理目标是找经纪人/甩锅（外部）。



### 组合模式:

把一组相似的对象当作一个单一的对象，为的是减少数据类型。

1、定义一个抽象对象，它可以表示两种或多种实际类型的对象
2、在对象内部，聚合一个抽象类型对象
3、构造时，递归这种联系
4、适合构造树形结构的对象关系





## 行为型模式

### 外观模式(蒙面模式):

糅合功能，对外只提供一个入口。

1、调用方只关注facade组件，不需要知道底层服务。
2、隐藏掉底层服务中，不相干的功能。

场景：当访问流程较复杂时，将流程封闭成一个接口，供外部使用

例如:

请求框架替换，facade调用 get post请求，最终调用的是接口实现类，

将volley和retorfit 实现接口具体功能来调用，这样如果请求框架变更了，外部的都不需要变更，只需要替换facade里的接口的实现类就好了。





### 模板方法模式:

在父类中编排主流程，将步骤实现延迟到子类去实现。

1、先将主流程框架逻辑（清点商品/计算价目/结算/送货上门）设计完成
2、再实现各模块小步骤。
3、不能确实的步骤，作为虚拟方法，甩锅给子类实现。
3、子类只需要聚焦自己的小步骤逻辑。

例：下订单，第三方支付，支付方式有多重，但是下单的逻辑一致。



### 策略模式:

通过选择策略类，来执行不同算法分支。核心是通过注入对象，改变行为。

1、将每一种策略，单独成一个组件对象，独出来。
2、使用方通过选择不同的组件，达到不同的行为。

PS：此模式其实就是spring IOC思想。

例如:购物车结算选择优惠





### 责任链模式:

将请求传给一个接收者链，由链将请求流转给目标对象。

PS：当出现多个对象可以处理同一个请求时，适合责任链模式

例：

retrofit的5大拦截器，请求任务交给Chain即可



### 观察者模式:

一个对象状态改变时通知其他对象。为的是尽量弱化对象间的依赖。



### 命令模式:

通过增加Command抽象命令类，将不符合抽象编程的调用，转为抽象编程。





### 访问者模式:

利用双重分派机制，弥补java多态中的方法重载是静态化的不足。

何为双重分派？

通过访问者去调用多态对象指向不了具体的实现类，visit.sell(Fruit)

应该用多态对象去执行访问者里的方法，用this指针指向真实类型对象。

fruit.accpet(visit)->visit.sell(this)





1、集合中有不同类型的对象，通过方法重载（形参），无法识别它们的具体类型（出错）
2、通过双重委派，可以实现遍历识别，达成目标









