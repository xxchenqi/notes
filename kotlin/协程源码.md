# 协程源码

## 挂起函数

### CPS 参数变化

```kotlin
suspend fun testCoroutine() {
    val user = getUserInfo()
    val friendList = getFriendList(user)
    val feedList = getFeedList(user, friendList)
    log(feedList)
}

//挂起函数
// ↓
suspend fun getUserInfo(): String {
    withContext(Dispatchers.IO) {
        delay(1000L)
    }
    return "BoyCoder"
}

//挂起函数
// ↓
suspend fun getFriendList(user: String): String {
    withContext(Dispatchers.IO) {
        delay(1000L)
    }
    return "Tom, Jack"
}

//挂起函数
// ↓
suspend fun getFeedList(user: String, list: String): String {
    withContext(Dispatchers.IO) {
        delay(1000L)
    }
    return "{FeedList..}"
}
```

从 Java 的角度来看待 testCoroutine() 的话，代码中所有的参数都会发生变化。

如下所示：

```kotlin
//                 变化在这里
//                     ↓
fun testCoroutine(continuation: Continuation): Any? {
//                          变化在这里
//                              ↓
    val user = getUserInfo(continuation)
//                                        变化在这里
//                                            ↓
    val friendList = getFriendList(user, continuation)
//                                          变化在这里
//                                              ↓
    val feedList = getFeedList(friendList, continuation)
    log(feedList)
}
```



**为什么挂起函数可以调用挂起函数，普通函数则不能？**

因为普通函数不会有 continuation 这个参数

协程函数会带有 continuation 这个参数



### CPS 返回值变化

```kotlin
suspend fun getUserInfo(): String {}

//                                  变化在这里
//                                     ↓
fun getUserInfo(cont: Continuation): Any? {}
```

getUserInfo() 这个方法，经过 CPS 转换后，它完整的函数签名应该是这样的：

```kotlin
suspend fun getUserInfo(): String {}

//                                变化在这里
//                                    ↓
fun getUserInfo(cont: Continuation<String>): Any? {}
```



**这里的“Any?”又是干什么的呢?**

挂起函数经过 CPS 转换后，它的返回值有一个重要作用：标志该挂起函数有没有被挂起。



**挂起的函数，它还能不被挂起吗?**

当 getUserInfo() 执行到 withContext{} 的时候，就会返回 CoroutineSingletons.COROUTINE_SUSPENDED 表示函数被挂起了。

```kotlin
// suspend 修饰
// ↓
suspend fun noSuspendFriendList(user: String): String{
    // 函数体跟普通函数一样
    return "Tom, Jack"
}
```

当我们调用 noSuspendFriendList() 这个挂起函数的时候，它不会真正挂起，而是会直接返回 String 类型："no suspend"。针对这样的挂起函数，你可以把它看作是伪挂起函数。



**总结**

Any? 可能返回

1.CoroutineSingletons.COROUTINE_SUSPENDED

2."no suspend"

3.null



### 挂起函数的反编译

1.在 testCoroutine() 函数里，会多出一个 ContinuationImpl 的子类，它是整个协程挂起函数的核心。

```kotlin
fun testCoroutine(completion: Continuation<Any?>): Any? {
    // TestContinuation本质上是匿名内部类
    class TestContinuation(completion: Continuation<Any?>?) : ContinuationImpl(completion) {
        // 表示协程状态机当前的状态
        var label: Int = 0
        // 协程返回结果
        var result: Any? = null

        // 用于保存之前协程的计算结果
        var mUser: Any? = null
        var mFriendList: Any? = null

        // invokeSuspend 是协程的关键
        // 它最终会调用 testCoroutine(this) 开启协程状态机
        // 状态机相关代码就是后面的 when 语句
        // 协程的本质，可以说就是 CPS + 状态机
        override fun invokeSuspend(_result: Result<Any?>): Any? {
            result = _result
            label = label or Int.Companion.MIN_VALUE
            return testCoroutine(this)
        }
    }
}
```

- label 是用来代表协程状态机当中状态的；
- result 是用来存储当前挂起函数执行结果的；
- mUser、mFriendList 则是用来存储历史挂起函数执行结果的；
- invokeSuspend 这个函数，是整个状态机的入口，它会将执行流程转交给 testCoroutine() 进行再次调用。



2.判断 testCoroutine 是不是初次运行，如果是初次运行，我们就要创建一个 TestContinuation 的实例对象。

```kotlin
//                    ↓
fun testCoroutine(completion: Continuation<Any?>): Any? {
    ...
    val continuation = if (completion is TestContinuation) {
        completion
    } else {
        //                作为参数
        //                   ↓
        TestContinuation(completion)
    }
}
```

- invokeSuspend 最终会调用 testCoroutine，然后走到这个判断语句；
- 如果是初次运行，会创建一个 TestContinuation 对象，completion 作为参数；
- 这相当于用一个新的 Continuation 包装了旧的 Continuation；
- 如果不是初次运行，直接将 completion 赋值给 continuation；
- 这说明 continuation 在整个运行期间，只会产生一个实例，这能极大地节省内存开销（对比 CallBack）。



3.变量的定义：

```kotlin
// 三个变量，对应原函数的三个变量
lateinit var user: String
lateinit var friendList: String
lateinit var feedList: String

// result 接收协程的运行结果
var result = continuation.result

// suspendReturn 接收挂起函数的返回值
var suspendReturn: Any? = null

// CoroutineSingletons 是个枚举类
// COROUTINE_SUSPENDED 代表当前函数被挂起了
val sFlag = CoroutineSingletons.COROUTINE_SUSPENDED
```

分别代表了函数当中的临时变量、挂起函数执行结果，以及是否挂起的标志位。



4.核心逻辑:

```kotlin
when (continuation.label) {
    0 -> {
        // 检测异常
        throwOnFailure(result)

        log("start")
        // 将 label 置为 1，准备进入下一次状态
        continuation.label = 1

        // 执行 getUserInfo
        suspendReturn = getUserInfo(continuation)

        // 判断是否挂起
        if (suspendReturn == sFlag) {
            return suspendReturn
        } else {
            result = suspendReturn
            //go to next state
        }
    }

    1 -> {
        throwOnFailure(result)

        // 获取 user 值
        user = result as String
        log(user)
        // 将协程结果存到 continuation 里
        continuation.mUser = user
        // 准备进入下一个状态
        continuation.label = 2

        // 执行 getFriendList
        suspendReturn = getFriendList(user, continuation)

        // 判断是否挂起
        if (suspendReturn == sFlag) {
            return suspendReturn
        } else {
            result = suspendReturn
            //go to next state
        }
    }

    2 -> {
        throwOnFailure(result)

        user = continuation.mUser as String

        // 获取 friendList 的值
        friendList = result as String
        log(friendList)

        // 将协程结果存到 continuation 里
        continuation.mUser = user
        continuation.mFriendList = friendList

        // 准备进入下一个状态
        continuation.label = 3

        // 执行 getFeedList
        suspendReturn = getFeedList(user, friendList, continuation)

        // 判断是否挂起
        if (suspendReturn == sFlag) {
            return suspendReturn
        } else {
            result = suspendReturn
            //go to next state
        }
    }

    3 -> {
        throwOnFailure(result)

        user = continuation.mUser as String
        friendList = continuation.mFriendList as String
        feedList = continuation.result as String
        log(feedList)
        loop = false
    }
}
```

- when 表达式实现了协程状态机；
- continuation.label 是状态流转的关键，continuation.label 改变一次，就代表了挂起函数被调用了一次；
- 每次挂起函数执行完后，都会检查是否发生异常；
- testCoroutine 里的原本的代码，被拆分到状态机里各个状态中，分开执行；
- getUserInfo(continuation)、getFriendList(user, continuation)、getFeedList(friendList, continuation) 三个函数调用的是同一个 continuation 实例；
- 如果一个函数被挂起了，它的返回值会是 CoroutineSingletons.COROUTINE_SUSPENDED；
- 在挂起函数执行的过程中，状态机会把之前的结果以成员变量的方式保存在 continuation 中。



#### 协程未挂起的情况

```kotlin
// “伪”挂起函数
// 虽然它有 suspend 修饰，但执行的时候并不会真正挂起，因为它函数体里没有其他挂起函数
//  ↓
suspend fun noSuspendFriendList(user: String): String{
    return "Tom, Jack"
}

suspend fun testNoSuspend() {
    log("start")
    val user = getUserInfo()
    log(user)                  
    //                  变化在这里
    //                      ↓
    val friendList = noSuspendFriendList(user)
    log(friendList)
    val feedList = getFeedList(friendList)
    log(feedList)
}
```



Kotlin 编译器进行 CPS 转换。

```kotlin
when (continuation.label) {
    0 -> {
        ...
    }

    1 -> {
        ...
        //               变化在这里
        //                   ↓
        suspendReturn = noSuspendFriendList(user, continuation)

        // 判断是否挂起
        if (suspendReturn == sFlag) {
            return suspendReturn
        } else {
            result = suspendReturn // 未挂起直接将结果赋值
            //go to next state
        }
    }

    2 -> {
        ...
    }

    3 -> {
        ...
    }
}
```



#### go to next state具体实现？

协程状态机底层字节码，是通过 label 来实现这个 go to next state 的。



真实的字节码反编译出来的 Java 代码

```java
@Nullable
public static final Object testCoroutine(@NotNull Continuation $completion) {
    Object $continuation;
    label37: {
        if ($completion instanceof <TestSuspendKt$testCoroutine$1>) {
            $continuation = (<TestSuspendKt$testCoroutine$1>)$completion;
            if ((((<TestSuspendKt$testCoroutine$1>)$continuation).label & Integer.MIN_VALUE) != 0) {
                ((<TestSuspendKt$testCoroutine$1>)$continuation).label -= Integer.MIN_VALUE;
                break label37;
            }
        }

        $continuation = new ContinuationImpl($completion) {
            // $FF: synthetic field
            Object result;
            int label;
            Object L$0;
            Object L$1;

            @Nullable
            public final Object invokeSuspend(@NotNull Object $result) {
                this.result = $result;
                this.label |= Integer.MIN_VALUE;
                return TestSuspendKt.testCoroutine(this);
            }
        };
    }

    Object var10000;
    label31: {
        String user;
        String friendList;
        Object var6;
        label30: {
            Object $result = ((<TestSuspendKt$testCoroutine$1>)$continuation).result;
            var6 = IntrinsicsKt.getCOROUTINE_SUSPENDED();
            switch(((<TestSuspendKt$testCoroutine$1>)$continuation).label) {
                case 0:
                    ResultKt.throwOnFailure($result);
                    log("start");
                    ((<TestSuspendKt$testCoroutine$1>)$continuation).label = 1;
                    var10000 = getUserInfo((Continuation)$continuation);
                    if (var10000 == var6) {
                        return var6;
                    }
                    break;
                case 1:
                    ResultKt.throwOnFailure($result);
                    var10000 = $result;
                    break;
                case 2:
                    user = (String)((<TestSuspendKt$testCoroutine$1>)$continuation).L$0;
                    ResultKt.throwOnFailure($result);
                    var10000 = $result;
                    break label30;
                case 3:
                    friendList = (String)((<TestSuspendKt$testCoroutine$1>)$continuation).L$1;
                    user = (String)((<TestSuspendKt$testCoroutine$1>)$continuation).L$0;
                    ResultKt.throwOnFailure($result);
                    var10000 = $result;
                    break label31;
                default:
                    throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
            }

            user = (String)var10000;
            log(user);
            ((<TestSuspendKt$testCoroutine$1>)$continuation).L$0 = user;
            ((<TestSuspendKt$testCoroutine$1>)$continuation).label = 2;
            var10000 = getFriendList(user, (Continuation)$continuation);
            if (var10000 == var6) {
                return var6;
            }
        }

        friendList = (String)var10000;
        log(friendList);
        ((<TestSuspendKt$testCoroutine$1>)$continuation).L$0 = user;
        ((<TestSuspendKt$testCoroutine$1>)$continuation).L$1 = friendList;
        ((<TestSuspendKt$testCoroutine$1>)$continuation).label = 3;
        var10000 = getFeedList(friendList, (Continuation)$continuation);
        if (var10000 == var6) {
            return var6;
        }
    }

    String feedList = (String)var10000;
    log(feedList);
    return Unit.INSTANCE;
}
```



### 挂起函数为什么能直接访问协程上下文

挂起函数为什么能直接访问协程上下文

```kotlin
import kotlinx.coroutines.*
import kotlin.coroutines.coroutineContext

//                        挂起函数能可以访问协程上下文吗？
//                                 ↓                              
suspend fun testContext() = coroutineContext
```

反编译成 Java

```java
public static final Object testContext(Continuation $completion) {
  return $completion.getContext();
}
```



Continuation.kt

```kotlin
public interface Continuation<in T> {
    public val context: CoroutineContext

    public fun resumeWith(result: Result<T>)
}

@Suppress("WRONG_MODIFIER_TARGET")
public suspend inline val coroutineContext: CoroutineContext
    get() {
        throw NotImplementedError("Implemented as intrinsic")
    }

```

“suspend inline val coroutineContext”，本质上就是 Kotlin 官方提供的一种方便开发者在挂起函数当中，获取协程上下文的手段。它的具体实现，其实是 Kotlin 编译器来完成的。



我们在挂起函数当中无法直接访问 Continuation 对象，但可以访问到 Continuation 当中的 coroutineContext。要知道，正常情况下，我们想要访问 Continuation.coroutineContext，首先是要拿到 Continuation 对象的。但是，Kotlin 官方通过“suspend inline val coroutineContext”这个顶层变量，让我们开发者能直接拿到 coroutineContext，却对 Continuation 毫无感知。



### 总结

Kotlin 的挂起函数，本质上就是一个状态机。

Kotlin 协程就是通过 label 代码段嵌套，配合 switch 巧妙构造出一个状态机结构



## 协程基础元素

Continuation、SafeContinuation、CoroutineContext、CombinedContext、CancellationException、intrinsics。



