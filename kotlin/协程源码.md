# 协程源码

## 一.挂起函数

### CPS 参数变化

```kotlin
suspend fun testCoroutine() {
    val user = getUserInfo()
    val friendList = getFriendList(user)
    val feedList = getFeedList(user, friendList)
    log(feedList)
}

//挂起函数
// ↓
suspend fun getUserInfo(): String {
    withContext(Dispatchers.IO) {
        delay(1000L)
    }
    return "BoyCoder"
}

//挂起函数
// ↓
suspend fun getFriendList(user: String): String {
    withContext(Dispatchers.IO) {
        delay(1000L)
    }
    return "Tom, Jack"
}

//挂起函数
// ↓
suspend fun getFeedList(user: String, list: String): String {
    withContext(Dispatchers.IO) {
        delay(1000L)
    }
    return "{FeedList..}"
}
```

从 Java 的角度来看待 testCoroutine() 的话，代码中所有的参数都会发生变化。

如下所示：

```kotlin
//                 变化在这里
//                     ↓
fun testCoroutine(continuation: Continuation): Any? {
//                          变化在这里
//                              ↓
    val user = getUserInfo(continuation)
//                                        变化在这里
//                                            ↓
    val friendList = getFriendList(user, continuation)
//                                          变化在这里
//                                              ↓
    val feedList = getFeedList(friendList, continuation)
    log(feedList)
}
```



**为什么挂起函数可以调用挂起函数，普通函数则不能？**

因为普通函数不会有 continuation 这个参数

协程函数会带有 continuation 这个参数



### CPS 返回值变化

```kotlin
suspend fun getUserInfo(): String {}

//                                  变化在这里
//                                     ↓
fun getUserInfo(cont: Continuation): Any? {}
```

getUserInfo() 这个方法，经过 CPS 转换后，它完整的函数签名应该是这样的：

```kotlin
suspend fun getUserInfo(): String {}

//                                变化在这里
//                                    ↓
fun getUserInfo(cont: Continuation<String>): Any? {}
```



**这里的“Any?”又是干什么的呢?**

挂起函数经过 CPS 转换后，它的返回值有一个重要作用：标志该挂起函数有没有被挂起。



**挂起的函数，它还能不被挂起吗?**

当 getUserInfo() 执行到 withContext{} 的时候，就会返回 CoroutineSingletons.COROUTINE_SUSPENDED 表示函数被挂起了。

```kotlin
// suspend 修饰
// ↓
suspend fun noSuspendFriendList(user: String): String{
    // 函数体跟普通函数一样
    return "Tom, Jack"
}
```

当我们调用 noSuspendFriendList() 这个挂起函数的时候，它不会真正挂起，而是会直接返回 String 类型："no suspend"。针对这样的挂起函数，你可以把它看作是伪挂起函数。



**总结**

Any? 可能返回

1.CoroutineSingletons.COROUTINE_SUSPENDED

2."no suspend"

3.null



### 挂起函数的反编译

1.在 testCoroutine() 函数里，会多出一个 ContinuationImpl 的子类，它是整个协程挂起函数的核心。

```kotlin
fun testCoroutine(completion: Continuation<Any?>): Any? {
    // TestContinuation本质上是匿名内部类
    class TestContinuation(completion: Continuation<Any?>?) : ContinuationImpl(completion) {
        // 表示协程状态机当前的状态
        var label: Int = 0
        // 协程返回结果
        var result: Any? = null

        // 用于保存之前协程的计算结果
        var mUser: Any? = null
        var mFriendList: Any? = null

        // invokeSuspend 是协程的关键
        // 它最终会调用 testCoroutine(this) 开启协程状态机
        // 状态机相关代码就是后面的 when 语句
        // 协程的本质，可以说就是 CPS + 状态机
        override fun invokeSuspend(_result: Result<Any?>): Any? {
            result = _result
            label = label or Int.Companion.MIN_VALUE
            return testCoroutine(this)
        }
    }
}
```

- label 是用来代表协程状态机当中状态的；
- result 是用来存储当前挂起函数执行结果的；
- mUser、mFriendList 则是用来存储历史挂起函数执行结果的；
- invokeSuspend 这个函数，是整个状态机的入口，它会将执行流程转交给 testCoroutine() 进行再次调用。



2.判断 testCoroutine 是不是初次运行，如果是初次运行，我们就要创建一个 TestContinuation 的实例对象。

```kotlin
//                    ↓
fun testCoroutine(completion: Continuation<Any?>): Any? {
    ...
    val continuation = if (completion is TestContinuation) {
        completion
    } else {
        //                作为参数
        //                   ↓
        TestContinuation(completion)
    }
}
```

- invokeSuspend 最终会调用 testCoroutine，然后走到这个判断语句；
- 如果是初次运行，会创建一个 TestContinuation 对象，completion 作为参数；
- 这相当于用一个新的 Continuation 包装了旧的 Continuation；
- 如果不是初次运行，直接将 completion 赋值给 continuation；
- 这说明 continuation 在整个运行期间，只会产生一个实例，这能极大地节省内存开销（对比 CallBack）。



3.变量的定义：

```kotlin
// 三个变量，对应原函数的三个变量
lateinit var user: String
lateinit var friendList: String
lateinit var feedList: String

// result 接收协程的运行结果
var result = continuation.result

// suspendReturn 接收挂起函数的返回值
var suspendReturn: Any? = null

// CoroutineSingletons 是个枚举类
// COROUTINE_SUSPENDED 代表当前函数被挂起了
val sFlag = CoroutineSingletons.COROUTINE_SUSPENDED
```

分别代表了函数当中的临时变量、挂起函数执行结果，以及是否挂起的标志位。



4.核心逻辑:

```kotlin
when (continuation.label) {
    0 -> {
        // 检测异常
        throwOnFailure(result)

        log("start")
        // 将 label 置为 1，准备进入下一次状态
        continuation.label = 1

        // 执行 getUserInfo
        suspendReturn = getUserInfo(continuation)

        // 判断是否挂起
        if (suspendReturn == sFlag) {
            return suspendReturn
        } else {
            result = suspendReturn
            //go to next state
        }
    }

    1 -> {
        throwOnFailure(result)

        // 获取 user 值
        user = result as String
        log(user)
        // 将协程结果存到 continuation 里
        continuation.mUser = user
        // 准备进入下一个状态
        continuation.label = 2

        // 执行 getFriendList
        suspendReturn = getFriendList(user, continuation)

        // 判断是否挂起
        if (suspendReturn == sFlag) {
            return suspendReturn
        } else {
            result = suspendReturn
            //go to next state
        }
    }

    2 -> {
        throwOnFailure(result)

        user = continuation.mUser as String

        // 获取 friendList 的值
        friendList = result as String
        log(friendList)

        // 将协程结果存到 continuation 里
        continuation.mUser = user
        continuation.mFriendList = friendList

        // 准备进入下一个状态
        continuation.label = 3

        // 执行 getFeedList
        suspendReturn = getFeedList(user, friendList, continuation)

        // 判断是否挂起
        if (suspendReturn == sFlag) {
            return suspendReturn
        } else {
            result = suspendReturn
            //go to next state
        }
    }

    3 -> {
        throwOnFailure(result)

        user = continuation.mUser as String
        friendList = continuation.mFriendList as String
        feedList = continuation.result as String
        log(feedList)
        loop = false
    }
}
```

- when 表达式实现了协程状态机；
- continuation.label 是状态流转的关键，continuation.label 改变一次，就代表了挂起函数被调用了一次；
- 每次挂起函数执行完后，都会检查是否发生异常；
- testCoroutine 里的原本的代码，被拆分到状态机里各个状态中，分开执行；
- getUserInfo(continuation)、getFriendList(user, continuation)、getFeedList(friendList, continuation) 三个函数调用的是同一个 continuation 实例；
- 如果一个函数被挂起了，它的返回值会是 CoroutineSingletons.COROUTINE_SUSPENDED；
- 在挂起函数执行的过程中，状态机会把之前的结果以成员变量的方式保存在 continuation 中。



#### 协程未挂起的情况

```kotlin
// “伪”挂起函数
// 虽然它有 suspend 修饰，但执行的时候并不会真正挂起，因为它函数体里没有其他挂起函数
//  ↓
suspend fun noSuspendFriendList(user: String): String{
    return "Tom, Jack"
}

suspend fun testNoSuspend() {
    log("start")
    val user = getUserInfo()
    log(user)                  
    //                  变化在这里
    //                      ↓
    val friendList = noSuspendFriendList(user)
    log(friendList)
    val feedList = getFeedList(friendList)
    log(feedList)
}
```



Kotlin 编译器进行 CPS 转换。

```kotlin
when (continuation.label) {
    0 -> {
        ...
    }

    1 -> {
        ...
        //               变化在这里
        //                   ↓
        suspendReturn = noSuspendFriendList(user, continuation)

        // 判断是否挂起
        if (suspendReturn == sFlag) {
            return suspendReturn
        } else {
            result = suspendReturn // 未挂起直接将结果赋值
            //go to next state
        }
    }

    2 -> {
        ...
    }

    3 -> {
        ...
    }
}
```



#### go to next state具体实现？

协程状态机底层字节码，是通过 label 来实现这个 go to next state 的。



真实的字节码反编译出来的 Java 代码

```java
@Nullable
public static final Object testCoroutine(@NotNull Continuation $completion) {
    Object $continuation;
    label37: {
        if ($completion instanceof <TestSuspendKt$testCoroutine$1>) {
            $continuation = (<TestSuspendKt$testCoroutine$1>)$completion;
            if ((((<TestSuspendKt$testCoroutine$1>)$continuation).label & Integer.MIN_VALUE) != 0) {
                ((<TestSuspendKt$testCoroutine$1>)$continuation).label -= Integer.MIN_VALUE;
                break label37;
            }
        }

        $continuation = new ContinuationImpl($completion) {
            // $FF: synthetic field
            Object result;
            int label;
            Object L$0;
            Object L$1;

            @Nullable
            public final Object invokeSuspend(@NotNull Object $result) {
                this.result = $result;
                this.label |= Integer.MIN_VALUE;
                return TestSuspendKt.testCoroutine(this);
            }
        };
    }

    Object var10000;
    label31: {
        String user;
        String friendList;
        Object var6;
        label30: {
            Object $result = ((<TestSuspendKt$testCoroutine$1>)$continuation).result;
            var6 = IntrinsicsKt.getCOROUTINE_SUSPENDED();
            switch(((<TestSuspendKt$testCoroutine$1>)$continuation).label) {
                case 0:
                    ResultKt.throwOnFailure($result);
                    log("start");
                    ((<TestSuspendKt$testCoroutine$1>)$continuation).label = 1;
                    var10000 = getUserInfo((Continuation)$continuation);
                    if (var10000 == var6) {
                        return var6;
                    }
                    break;
                case 1:
                    ResultKt.throwOnFailure($result);
                    var10000 = $result;
                    break;
                case 2:
                    user = (String)((<TestSuspendKt$testCoroutine$1>)$continuation).L$0;
                    ResultKt.throwOnFailure($result);
                    var10000 = $result;
                    break label30;
                case 3:
                    friendList = (String)((<TestSuspendKt$testCoroutine$1>)$continuation).L$1;
                    user = (String)((<TestSuspendKt$testCoroutine$1>)$continuation).L$0;
                    ResultKt.throwOnFailure($result);
                    var10000 = $result;
                    break label31;
                default:
                    throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
            }

            user = (String)var10000;
            log(user);
            ((<TestSuspendKt$testCoroutine$1>)$continuation).L$0 = user;
            ((<TestSuspendKt$testCoroutine$1>)$continuation).label = 2;
            var10000 = getFriendList(user, (Continuation)$continuation);
            if (var10000 == var6) {
                return var6;
            }
        }

        friendList = (String)var10000;
        log(friendList);
        ((<TestSuspendKt$testCoroutine$1>)$continuation).L$0 = user;
        ((<TestSuspendKt$testCoroutine$1>)$continuation).L$1 = friendList;
        ((<TestSuspendKt$testCoroutine$1>)$continuation).label = 3;
        var10000 = getFeedList(friendList, (Continuation)$continuation);
        if (var10000 == var6) {
            return var6;
        }
    }

    String feedList = (String)var10000;
    log(feedList);
    return Unit.INSTANCE;
}
```



### 挂起函数为什么能直接访问协程上下文

挂起函数为什么能直接访问协程上下文

```kotlin
import kotlinx.coroutines.*
import kotlin.coroutines.coroutineContext

//                        挂起函数能可以访问协程上下文吗？
//                                 ↓                              
suspend fun testContext() = coroutineContext
```

反编译成 Java

```java
public static final Object testContext(Continuation $completion) {
  return $completion.getContext();
}
```



Continuation.kt

```kotlin
public interface Continuation<in T> {
    public val context: CoroutineContext

    public fun resumeWith(result: Result<T>)
}

@Suppress("WRONG_MODIFIER_TARGET")
public suspend inline val coroutineContext: CoroutineContext
    get() {
        throw NotImplementedError("Implemented as intrinsic")
    }

```

“suspend inline val coroutineContext”，本质上就是 Kotlin 官方提供的一种方便开发者在挂起函数当中，获取协程上下文的手段。它的具体实现，其实是 Kotlin 编译器来完成的。



我们在挂起函数当中无法直接访问 Continuation 对象，但可以访问到 Continuation 当中的 coroutineContext。要知道，正常情况下，我们想要访问 Continuation.coroutineContext，首先是要拿到 Continuation 对象的。但是，Kotlin 官方通过“suspend inline val coroutineContext”这个顶层变量，让我们开发者能直接拿到 coroutineContext，却对 Continuation 毫无感知。



### 总结

Kotlin 的挂起函数，本质上就是一个状态机。

Kotlin 协程就是通过 label 代码段嵌套，配合 switch 巧妙构造出一个状态机结构



## 二.协程基础元素

Continuation、SafeContinuation、CoroutineContext、CombinedContext、CancellationException、intrinsics。



### Continuation 到底该怎么用？

```kotlin
fun main() = runBlocking {
    val result = getLengthSuspend("Kotlin")
    println(result)
}

suspend fun getLengthSuspend(text: String): Int = suspendCoroutine { continuation->
    thread {
        // 模拟耗时
        Thread.sleep(1000L)
        continuation.resume(text.length)
    }
}

/*
输出结果：
等待1秒
6
*/
```

我们是使用 suspendCoroutine{}实现了挂起函数，然后在它的内部，我们使用 continuation.resume() 的方式，传出了挂起函数的返回值。



**为什么以 continuation.resume() 这样异步的方式传出结果以后，挂起函数就能接收到结果呢？**

把 getLengthSuspend() 这个函数强转成了带有 Continuation 的函数类型，然后通过匿名内部类的方式，创建了一个 Continuation 对象传了进去。

```kotlin
// 变化在这里
fun main()  {
    val func = ::getLengthSuspend as (String, Continuation<Int>) -> Any?

    func("Kotlin", object: Continuation<Int>{
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(result: Result<Int>) {
            println(result.getOrNull())
        }
    })

    // 防止程序提前结束
    Thread.sleep(2000L)
}

suspend fun getLengthSuspend(text: String): Int = suspendCoroutine { continuation->
    thread {
        // 模拟耗时
        Thread.sleep(1000L)
        continuation.resume(text.length)
    }
}
/*
输出结果：
等待1秒
6
*/
```

综上所述，Kotlin 协程当中的 Continuation，作用其实就相当于 Callback，它既可以用于实现挂起函数，往挂起函数的外部传递结果；也可以用于调用挂起函数，我们可以创建 Continuation 的匿名内部类，来接收挂起函数传递出来的结果。



**Java 代码中如何调用 Kotlin 的挂起函数？**

```kotlin
// 需要在Java中调用的Kotlin挂起函数
object SuspendFromJavaExample {
    // 在Java当中如何调用这个方法？
    suspend fun getUserInfo(id: Long):String {
        delay(1000L)
        return "Kotlin"
    }
}
```



```kotlin
public static void main(String[] args) throws InterruptedException {
    SuspendFromJavaExample.INSTANCE.getUserInfo(100L, new Continuation<String>() {
        @NotNull
        @Override
        public CoroutineContext getContext() {
            return EmptyCoroutineContext.INSTANCE;
        }

        @Override
        public void resumeWith(@NotNull Object o) {
            System.out.println(o+"");
        }
    });

    // 防止程序提前结束
    Thread.sleep(2000L);
}

/*
输出结果
Kotlin
*/
```



### suspendCoroutine{}

#### suspendCoroutineUninterceptedOrReturn

suspendCoroutineUninterceptedOrReturn{}。它其实就是实现 suspendCoroutine{}的关键。

```kotlin
public interface Continuation<in T> {
    public val context: CoroutineContext    
    public fun resumeWith(result: Result<T>)
}

public suspend inline fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T {

    // 注意这里
    return suspendCoroutineUninterceptedOrReturn { c: Continuation<T> ->
		// 把原本的 Continuation 包裹一遍。
        val safe = SafeContinuation(c.intercepted())
		// 调用 Lambda 当中的逻辑。
        block(safe)
		// 取出 block(safe) 的运行结果
        safe.getOrThrow()
    }
}
```



suspendCoroutineUninterceptedOrReturn源码:

```kotlin
public suspend inline fun <T> suspendCoroutineUninterceptedOrReturn(crossinline block: (Continuation<T>) -> Any?): T {
    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
    throw NotImplementedError("Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic")
}
```

suspendCoroutineUninterceptedOrReturn 是一个编译器内建函数，它是由 Kotlin 编译器来实现的。



**suspendCoroutineUninterceptedOrReturn 伪挂起函数解析**

```kotlin
fun main() = runBlocking {
    val result = testNoSuspendCoroutine()
    println(result)
}

private suspend fun testNoSuspendCoroutine() = suspendCoroutineUninterceptedOrReturn<String> {
        continuation ->
    return@suspendCoroutineUninterceptedOrReturn "Hello!"
}

/*
输出结果：
Hello!
*/
```

对应的java

```java

    private static final Object testNoSuspendCoroutine(Continuation $completion) {
      int var2 = false;
      if ("Hello!" == IntrinsicsKt.getCOROUTINE_SUSPENDED()) {
         DebugProbesKt.probeCoroutineSuspended($completion);
      }
    
      return "Hello!";
    }
```



**suspendCoroutineUninterceptedOrReturn 挂起函数解析**

```kotlin
fun main() = runBlocking {
    val result = testSuspendCoroutine()
    println(result)
}

private suspend fun testSuspendCoroutine() = suspendCoroutineUninterceptedOrReturn<String> {
    continuation ->
    thread {
        Thread.sleep(1000L)
        continuation.resume("Hello!")


    }
    return@suspendCoroutineUninterceptedOrReturn kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED
}

/*
输出结果：
等待1秒
Hello!
*/
```

对应的java

```java
private static final Object testSuspendCoroutine(Continuation $completion) {
    int var2 = false;
    // 1
    ThreadsKt.thread$default(false, false, (ClassLoader)null, (String)null, 0, (Function0)(new CoroutineBasicElementsKt$testSuspendCoroutine$2$1($completion)), 31, (Object)null);
    // 2
    Object var10000 = IntrinsicsKt.getCOROUTINE_SUSPENDED();
    if (var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED()) {
     DebugProbesKt.probeCoroutineSuspended($completion);
    }
    // 3
    return var10000;
}

final class CoroutineBasicElementsKt$testSuspendCoroutine$2$1 extends Lambda implements Function0 {

   final Continuation $it;

   public Object invoke() {
      this.invoke();
      return Unit.INSTANCE;
   }

   public final void invoke() {
      // 4
      Thread.sleep(1000L);
      Continuation var1 = this.$it;
      String var2 = "Hello!";
      Companion var3 = Result.Companion;
      var1.resumeWith(Result.constructor-impl(var2));
   }

   CoroutineBasicElementsKt$testSuspendCoroutine$2$1(Continuation var1) {
      super(0);
      this.$it = var1;
   }
}
```

- 注释 1、4，创建了一个新的线程，执行了 thread{}当中的代码。
- 注释 2，将 var10000 赋值为 COROUTINE_SUSPENDED 这个挂起标志位。
- 注释 3，返回挂起标志位，代表 testSuspendCoroutine() 这个函数会真正挂起。



**总结:**

suspendCoroutineUninterceptedOrReturn{}这个高阶函数的作用了：它可以将挂起函数当中的 Continuation 以参数的形式暴露出来，在它的 Lambda 当中，我们可以直接返回结果，这时候它就是一个“伪挂起函数”；或者，我们也可以返回 COROUTINE_SUSPENDED 这个挂起标志位，然后使用 continuation.resume() 传递结果。

相应的，suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数，只是对它的一种封装而已。





**suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数，它对比 suspendCoroutineUninterceptedOrReturn{}的优势在哪里？Kotlin 官方为什么要进行这样的封装呢？**

suspendCoroutine{} 或者 suspendCancellableCoroutine{} 在使用的时候，只需要知道 Continuation 接口，而接口中只有一个函数 resumeWith，相对让人比较容易和 Callback 回调关联起来，所以，使用这两个函数的成本较小，不需要对 coroutine 协程的原理有太多的理解。

 而 suspendCoroutineUninterceptedOrReturn{} 函数除了需要关心 Continuation 接口外，还需要关心对应的返回值，而这个返回值中有几种状态，每种状态代表什么意思，其实在对 coroutine 原理不太清楚的情况下，是完全不知道怎么调用的。 总的来说，suspendCoroutineUninterceptedOrReturn{} 使用的学习成本要高很多。





## 三.launch的背后到底发生了什么？

### 协程是如何启动的

Continuation.kt

```kotlin
public fun <T> (suspend () -> T).createCoroutine(
    completion: Continuation<T>
): Continuation<Unit> =
    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)

public fun <T> (suspend () -> T).startCoroutine(
    completion: Continuation<T>
) {
    createCoroutineUnintercepted(completion).intercepted().resume(Unit)
}
```

createCoroutine{}、startCoroutine{}这两个函数，就是 Kotlin 协程当中最基础的两个创建协程的 API。

启动协程有三种常见的方式：launch、runBlocking、async。它们其实属于协程中间层提供的 API，而它们的底层都在某种程度上调用了“基础层”的协程 API。



#### 用基础API来启动协程

**startCoroutine() 启动协程**

```kotlin
fun main() {
    testStartCoroutine()
    Thread.sleep(2000L)
}

// 它的类型就是 suspend () -> T
val block = suspend {
    println("Hello!")
    delay(1000L)
    println("World!")
    "Result"
}

private fun testStartCoroutine() {

    val continuation = object : Continuation<String> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(result: Result<String>) {
            println("Result is: ${result.getOrNull()}")
        }
    }

    block.startCoroutine(continuation)
}

/*
输出结果
Hello!
World!
Result is: Result
*/
```

startCoroutine() 的作用其实就是创建一个新的协程，并且执行 block 当中的逻辑，等协程执行完毕以后，将结果返回给 Continuation 对象。



**createCoroutine()**

```kotlin
private fun testCreateCoroutine() {

    val continuation = object : Continuation<String> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(result: Result<String>) {
            println("Result is: ${result.getOrNull()}")
        }
    }

    val coroutine = block.createCoroutine(continuation)

    coroutine.resume(Unit)
}

/*
输出结果
Hello!
World!
Result is: Result
*/
```

createCoroutine() 的作用其实就是创建一个协程，并暂时先不启动它。等我们想要启动它的时候，直接调用 resume() 即可。



**startCoroutine() 之所以可以创建并同时启动协程的原因就在于，它在源码中直接调用了 resume(Unit)**



### startCoroutine实现原理

反编译java

```kotlin
public final class LaunchUnderTheHoodKt {

    public static final void main() {
        testStartCoroutine();
        Thread.sleep(2000L);
    }

	// block 其实就是 SuspendLambda 的子类，而 SuspendLambda 则是 ContinuationImpl 的子类。
    private static final Function1<Continuation<? super String>, Object> block = new LaunchUnderTheHoodKt$block$1(null);


    public static final Function1<Continuation<? super String>, Object> getBlock() {
        return block;
    }

    /**
    1.block 具体的实现类
    2.继承自 SuspendLambda，而 SuspendLambda 是 ContinuationImpl 的子类，因此它也间接实现了 Continuation 接口。
    3.invokeSuspend()协程状态机逻辑
    4.create()方法
    */
    static final class LaunchUnderTheHoodKt$block$1 extends SuspendLambda implements Function1<Continuation<? super String>, Object> {
        int label;

        LaunchUnderTheHoodKt$block$1(Continuation $completion) {
          super(1, $completion);
        }

        @Nullable
        public final Object invokeSuspend(@NotNull Object $result) {
          Object object = IntrinsicsKt.getCOROUTINE_SUSPENDED();
          switch (this.label) {
            case 0:
              ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);
              System.out
                .println("Hello!");
              this.label = 1;
              if (DelayKt.delay(1000L, (Continuation)this) == object)
                return object; 
              DelayKt.delay(1000L, (Continuation)this);
              System.out
                .println("World!");
              return "Result";
            case 1:
              ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);
              System.out.println("World!");
              return "Result";
          } 
          throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
        }

        @NotNull
        public final Continuation<Unit> create(@NotNull Continuation<? super LaunchUnderTheHoodKt$block$1> $completion) {
          return (Continuation<Unit>)new LaunchUnderTheHoodKt$block$1($completion);
        }

        @Nullable
        public final Object invoke(@Nullable Continuation<?> p1) {
          return ((LaunchUnderTheHoodKt$block$1)create(p1)).invokeSuspend(Unit.INSTANCE);
        }
    }

    // block.startCoroutine(continuation) 变成了“ContinuationKt.startCoroutine(block, continuation)”，这其实就体现出了扩展函数的原理。
    private static final void testStartCoroutine() {
        LaunchUnderTheHoodKt$testStartCoroutine$continuation$1 continuation = new LaunchUnderTheHoodKt$testStartCoroutine$continuation$1();
        ContinuationKt.startCoroutine(block, continuation);
    }

    // continuation 变量对应的匿名内部类。
    public static final class LaunchUnderTheHoodKt$testStartCoroutine$continuation$1 implements Continuation<String> {
        @NotNull
        public CoroutineContext getContext() {
          return (CoroutineContext)EmptyCoroutineContext.INSTANCE;
        }

        public void resumeWith(@NotNull Object result) {
          System.out.println(Intrinsics.stringPlus("Result is: ", Result.isFailure-impl(result) ? null : result));
        }
    }
}

// SuspendLambda 则是 ContinuationImpl 的子类。
internal abstract class SuspendLambda(
    public override val arity: Int,
    completion: Continuation<Any?>?
) : ContinuationImpl(completion), FunctionBase<Any?>, SuspendFunction {}
```



#### 流程分析:

1.main() 函数会调用 testStartCoroutine() 函数，接着，就会调用 startCoroutine() 方法。

```kotlin
public fun <T> (suspend () -> T).startCoroutine(
    completion: Continuation<T>
) {
//        注意这里
//           ↓
createCoroutineUnintercepted(completion).intercepted().resume(Unit)
}
```

createCoroutineUnintercepted具体实现代码在Kotlin 的源代码， JVM 平台对应

```kotlin
//    1，注意这里, 这个 actual，代表了 createCoroutineUnintercepted() 在 JVM 平台的实现。
//       ↓
public actual fun <T> (suspend () -> T).createCoroutineUnintercepted(
    completion: Continuation<T>
): Continuation<Unit> {
    val probeCompletion = probeCoroutineCreated(completion)
    // 注意这里,this，其实就代表了前面 block 变量
    // block 其实就是 SuspendLambda 的子类，而 SuspendLambda 则是 ContinuationImpl 的子类。
    // (this is BaseContinuationImpl) 条件一定是为 true 的
    return if (this is BaseContinuationImpl)
        create(probeCompletion)
    else
        createCoroutineFromSuspendFunction(probeCompletion) {
            (this as Function1<Continuation<T>, Any?>).invoke(it)
        }
}
```

在默认情况下，这个 create() 方法是会抛出异常的，

```kotlin
public open fun create(completion: Continuation<*>): Continuation<Unit> {
    throw UnsupportedOperationException("create(Continuation) has not been overridden")
}
```

重写后

```kotlin
static final class LaunchUnderTheHoodKt$block$1 extends SuspendLambda implements Function1<Continuation<? super String>, Object> {
    // ...
    public final Continuation<Unit> create(@NotNull Continuation<? super LaunchUnderTheHoodKt$block$1> $completion) {
      // 最终会返回“LaunchUnderTheHoodKt$block$1”这个 block 实现类，对应的 Continuation 对象。
      // 这行代码，其实就对应着协程被创建的时刻。
      return (Continuation<Unit>)new LaunchUnderTheHoodKt$block$1($completion);
    }
    // ...
}
```



2.intercepted()

```kotlin
public actual fun <T> Continuation<T>.intercepted(): Continuation<T> = (this as? ContinuationImpl)?.intercepted() ?: this
```

将 Continuation 强转成了 ContinuationImpl，调用了它的 intercepted()。

由于 this 的类型是“LaunchUnderTheHoodKt$block$1”，它是 ContinuationImpl 的子类，所以这个类型转换一定可以成功。



ContinuationImpl:

```kotlin
internal abstract class ContinuationImpl(
    completion: Continuation<Any?>?,
    private val _context: CoroutineContext?
) : BaseContinuationImpl(completion) {

    @Transient
    private var intercepted: Continuation<Any?>? = null

    public fun intercepted(): Continuation<Any?> =
        intercepted
            ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)
                .also { intercepted = it }
}
```

这里其实就是通过 ContinuationInterceptor，对 Continuation 进行拦截，从而将程序的执行逻辑派发到特定的线程之上



3.resume(Unit)

resume(Unit)，作用其实就相当于启动了协程。



### launch 是如何启动协程的？

```kotlin
fun main() {
    testLaunch()
    Thread.sleep(2000L)
}

private fun testLaunch() {
    val scope = CoroutineScope(Job())
    scope.launch {
        println("Hello!")
        delay(1000L)
        println("World!")
    }
}

/*
输出结果：
Hello!
World!
*/
```

反编译java

```java
public final class LaunchUnderTheHoodKt {
  public static final void main() {
    testLaunch();
    Thread.sleep(2000L);
  }

  private static final void testLaunch() {
    CoroutineScope scope = CoroutineScopeKt.CoroutineScope((CoroutineContext)JobKt.Job$default(null, 1, null));
    BuildersKt.launch$default(scope, null, null, new LaunchUnderTheHoodKt$testLaunch$1(null), 3, null);
  }

    // “LaunchUnderTheHoodKt$testLaunch$1”这个类，它其实对应的就是我们 launch 当中的 Lambda。
  static final class LaunchUnderTheHoodKt$testLaunch$1 extends SuspendLambda implements Function2<CoroutineScope, Continuation<? super Unit>, Object> {
    int label;

    LaunchUnderTheHoodKt$testLaunch$1(Continuation $completion) {
      super(2, $completion);
    }

    @Nullable
    public final Object invokeSuspend(@NotNull Object $result) {
      Object object = IntrinsicsKt.getCOROUTINE_SUSPENDED();
      switch (this.label) {
        case 0:
          ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);
          System.out
            .println("Hello!");
          this.label = 1;
          if (DelayKt.delay(1000L, (Continuation)this) == object)
            return object; 
          DelayKt.delay(1000L, (Continuation)this);
          System.out
            .println("World!");
          return Unit.INSTANCE;
        case 1:
          ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);
          System.out.println("World!");
          return Unit.INSTANCE;
      } 
      throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
    }

    @NotNull
    public final Continuation<Unit> create(@Nullable Object value, @NotNull Continuation<? super LaunchUnderTheHoodKt$testLaunch$1> $completion) {
      return (Continuation<Unit>)new LaunchUnderTheHoodKt$testLaunch$1($completion);
    }

    @Nullable
    public final Object invoke(@NotNull CoroutineScope p1, @Nullable Continuation<?> p2) {
      return ((LaunchUnderTheHoodKt$testLaunch$1)create(p1, p2)).invokeSuspend(Unit.INSTANCE);
    }
  }
}
```





```kotlin
private fun testLaunch() {
    val scope = CoroutineScope(Job())
    val block: suspend CoroutineScope.() -> Unit = {
        println("Hello!")
        delay(1000L)
        println("World!")
    }
    scope.launch(block = block)
}
```

launch{} 的源代码

```kotlin
public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
): Job {
    // launch 会根据传入的 CoroutineContext 创建出新的 Context。
    val newContext = newCoroutineContext(context)
    // launch 会根据传入的启动模式来创建对应的协程对象。这里有两种，一种是标准的，一种是懒加载的。
    val coroutine = if (start.isLazy)
        LazyStandaloneCoroutine(newContext, block) else
        StandaloneCoroutine(newContext, active = true)
    // 尝试启动协程。
    coroutine.start(start, coroutine, block)
    return coroutine
}
```



coroutine.start() 这个方法，会进入 AbstractCoroutine 这个抽象类：

```kotlin
public abstract class AbstractCoroutine<in T>(
    parentContext: CoroutineContext,
    initParentJob: Boolean,
    active: Boolean
) : JobSupport(active), Job, Continuation<T>, CoroutineScope {

    // 省略

    public fun <R> start(start: CoroutineStart, receiver: R, block: suspend R.() -> T) {
        start(block, receiver, this)
    }
}
```

start(block, receiver, this)，就会进入 CoroutineStart.invoke()。

```kotlin
public enum class CoroutineStart {
    public operator fun <T> invoke(block: suspend () -> T, completion: Continuation<T>): Unit =
        when (this) {
            DEFAULT -> block.startCoroutineCancellable(completion) // 默认, 启动以后可以响应取消
            ATOMIC -> block.startCoroutine(completion) // startCoroutine() 这个协程基础 API。
            UNDISPATCHED -> block.startCoroutineUndispatched(completion) // 启动协程以后就不会被分发
            LAZY -> Unit // will start lazily
        }
}
```

startCoroutineCancellable

```kotlin
public fun <T> (suspend () -> T).startCoroutineCancellable(completion: Continuation<T>): Unit = runSafely(completion) {
    // 1
    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))
}

public actual fun <T> (suspend () -> T).createCoroutineUnintercepted(
    completion: Continuation<T>
): Continuation<Unit> {
    val probeCompletion = probeCoroutineCreated(completion)

    return if (this is BaseContinuationImpl)
        // 2
        create(probeCompletion)
    else
        createCoroutineFromSuspendFunction(probeCompletion) {
            (this as Function1<Continuation<T>, Any?>).invoke(it)
        }
}
```

此处流程和基础API流程一样





**使用挂起函数启动协程和suspend {} 启动的协程有什么不一样**

```kotlin
private suspend fun func(): String {
    println("Hello!")
    delay(1000L)
    println("World!")
    return "Result"
}

private fun testStartCoroutineForSuspend() {
    val block = ::func

    val continuation = object : Continuation<String> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(result: Result<String>) {
            println("Result is: ${result.getOrNull()}")
        }
    }

    block.startCoroutine(continuation)
}
```

startCoroutine -> createCoroutineUnintercepted -> createCoroutineFromSuspendFunction,最终返回一个RestrictedContinuationImpl对象,然后调用其resume方法,从而调用block的invoke方法.最终调起协程.





internal class CoroutineScheduler(
    @JvmField val corePoolSize: Int,
    @JvmField val maxPoolSize: Int,
    @JvmField val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS,
    @JvmField val schedulerName: String = DEFAULT_SCHEDULER_NAME
) : Executor, Closeable {

    override fun execute(command: Runnable) = dispatch(command)
    
    fun dispatch(block: Runnable, taskContext: TaskContext = NonBlockingContext, tailDispatch: Boolean = false) {
        trackTask() 
        // 将传入的 Runnable 类型的 block（也就是 DispatchedContinuation），包装成 Task。
        val task = createTask(block, taskContext)
        // currentWorker()，拿到当前执行的线程。这里的 Worker 其实是一个内部类，它本质上仍然是 Java 的 Thread。
        val currentWorker = currentWorker()
        // currentWorker.submitToLocalQueue()，将当前的 Task 添加到 Worker 线程的本地队列，等待执行。
        val notAdded = currentWorker.submitToLocalQueue(task, tailDispatch)
        if (notAdded != null) {
            if (!addToGlobalQueue(notAdded)) {
    
                throw RejectedExecutionException("$schedulerName was terminated")
            }
        }
        val skipUnpark = tailDispatch && currentWorker != null
    
        if (task.mode == TASK_NON_BLOCKING) {
            if (skipUnpark) return
            signalCpuWork()
        } else {
    
            signalBlockingWork(skipUnpark = skipUnpark)
        }
    }
    
    private fun currentWorker(): Worker? = (Thread.currentThread() as? Worker)?.takeIf { it.scheduler == this }
    
    // 内部类 Worker
    internal inner class Worker private constructor() : Thread() {
    
        // 重写 Thread 的 run() 方法，然后把执行流程交给 runWorker()
        override fun run() = runWorker()
    
        @JvmField
        var mayHaveLocalTasks = false
    
        private fun runWorker() {
            var rescanned = false
            while (!isTerminated && state != WorkerState.TERMINATED) {
                // 在 while 循环当中，会一直尝试从 Worker 的本地队列取 Task 出来，如果存在需要执行的 Task，就会进入下一步。
                val task = findTask(mayHaveLocalTasks)
    
                if (task != null) {
                    rescanned = false
                    minDelayUntilStealableTaskNs = 0L
                    // executeTask(task)，其实就是执行对应的 Task。
                    // Task 本质上就是 Runnable，而 Runnable.run() 其实就代表了我们的协程任务真正执行了！
                    executeTask(task)
                    continue
                } else {
                    mayHaveLocalTasks = false
                }
    
                if (minDelayUntilStealableTaskNs != 0L) {
                    if (!rescanned) {
                        rescanned = true
                    } else {
                        rescanned = false
                        tryReleaseCpu(WorkerState.PARKING)
                        interrupted()
                        LockSupport.parkNanos(minDelayUntilStealableTaskNs)
                        minDelayUntilStealableTaskNs = 0L
                    }
                    continue
                }
    
                tryPark()
            }
            tryReleaseCpu(WorkerState.TERMINATED)
        }
    }
}


## 四.Dispatchers

**Dispatchers、CoroutineDispatcher、ContinuationInterceptor、CoroutineContext 之间的关系**

Dispatchers 是一个单例对象，它当中的 Default、Main、Unconfined、IO，类型都是 CoroutineDispatcher，而它本身就是 CoroutineContext。

```kotlin
public actual object Dispatchers {

    public actual val Default: CoroutineDispatcher = DefaultScheduler

    public actual val Main: MainCoroutineDispatcher get() = MainDispatcherLoader.dispatcher

    public actual val Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined

    public val IO: CoroutineDispatcher = DefaultIoScheduler

    public fun shutdown() {    }
}

public abstract class CoroutineDispatcher :
    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {}

public interface ContinuationInterceptor : CoroutineContext.Element {}

public interface Element : CoroutineContext {}
```



### launch为什么运行在DefaultDispatcher上?

```kotlin
fun main() {
    testLaunch()
    Thread.sleep(2000L)
}

private fun testLaunch() {
    val scope = CoroutineScope(Job())
    scope.launch{
        logX("Hello!")
        delay(1000L)
        logX("World!")
    }
}

/**
 * 控制台输出带协程信息的log
 */
fun logX(any: Any?) {
    println(
        """
================================
$any
Thread:${Thread.currentThread().name}
================================""".trimIndent()
    )
}

/*
输出结果
================================
Hello!
Thread:DefaultDispatcher-worker-1 @coroutine#1
================================
================================
World!
Thread:DefaultDispatcher-worker-1 @coroutine#1
================================
*/
```



launch 的源代码

```kotlin
public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
): Job {
    // EmptyCoroutineContext相当于一个空的 Map, Kotlin 官方用 EmptyCoroutineContext 替代了 null。
    val newContext = newCoroutineContext(context)
    val coroutine = if (start.isLazy)
        LazyStandaloneCoroutine(newContext, block) else
        StandaloneCoroutine(newContext, active = true)
    coroutine.start(start, coroutine, block)
    return coroutine
}
```

newCoroutineContext

```kotlin
public actual fun CoroutineScope.newCoroutineContext(context: CoroutineContext): CoroutineContext {
    // newCoroutineContext() 是 CoroutineScope 的扩展函数，因此，我们可以直接访问 CoroutineScope 的 coroutineContext 对象
    // foldCopiesForChildCoroutine() 的作用，其实就是将 CoroutineScope 当中的所有上下文元素都拷贝出来，然后跟传入的 context 参数进行合并。这行代码，可以让子协程继承父协程的上下文元素。
    val combined = coroutineContext.foldCopiesForChildCoroutine() + context
    // 在调试模式下，为我们的协程对象增加唯一的 ID。
    val debug = if (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) else combined
    // 如果合并过后的 combined 当中没有 CoroutineDispatcher，那么，就会默认使用 Dispatchers.Default。
    return if (combined !== Dispatchers.Default && combined[ContinuationInterceptor] == null)
        debug + Dispatchers.Default else debug
}
```

由于我们定义的 scope 没有指定 Dispatcher，同时 launch 的参数也没有传入 Dispatcher，最终在 newCoroutineContext() 的时候，会被默认指定为 Default 线程池。



**为什么协程默认的线程池是 Dispatchers.Default，而不是 Main 呢？**

因为 Kotlin 协程是支持多平台的，Main 线程只在 UI 编程平台才有可用。



### CoroutineDispatcher 拦截器

#### intercepted流程

```kotlin
public fun <T> (suspend () -> T).startCoroutineCancellable(completion: Continuation<T>): Unit = runSafely(completion) {
    // intercepted() 方法，其实就是 Continuation 的扩展函数。
    //                                        注意这里
    //                                           ↓
    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))
}

// 最终会调用 BaseContinuationImpl 的 intercepted() 方法。
public actual fun <T> Continuation<T>.intercepted(): Continuation<T> =
    (this as? ContinuationImpl)?.intercepted() ?: this

internal abstract class ContinuationImpl(
    completion: Continuation<Any?>?,
    private val _context: CoroutineContext?
) : BaseContinuationImpl(completion) {
    constructor(completion: Continuation<Any?>?) : this(completion, completion?.context)

    @Transient
    private var intercepted: Continuation<Any?>? = null

    // intercepted 如果为空，就会调用 context[ContinuationInterceptor]，获取上下文当中的 Dispatcher 对象。
    // 上文sample的 Dispatcher 肯定是 Default 线程池。
    public fun intercepted(): Continuation<Any?> =
        intercepted
            ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)
                .also { intercepted = it }
}
```

interceptContinuation(this)

```kotlin
public abstract class CoroutineDispatcher :
    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {

    // interceptContinuation() 直接返回了一个 DispatchedContinuation 对象，并且将 this、continuation 作为参数传了进去。
    // 这里的 this，其实就是 Dispatchers.Default。
    public final override fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T> =
        DispatchedContinuation(this, continuation)
}
```



startCoroutineCancellable() 改写一下

```kotlin
public fun <T> (suspend () -> T).startCoroutineCancellable(completion: Continuation<T>): Unit = runSafely(completion) {
    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))
}

// 等价
//  ↓

public fun <T> (suspend () -> T).startCoroutineCancellable(completion: Continuation<T>): Unit = runSafely(completion) {
    // 1
    val continuation = createCoroutineUnintercepted(completion)
    // 2
    val dispatchedContinuation = continuation.intercepted()
    // 3
    dispatchedContinuation.resumeCancellableWith(Result.success(Unit))
}
```



#### resumeCancellableWith流程

```kotlin
// DispatchedContinuation 不仅是一个 Continuation，同时还是一个 Runnable。
internal class DispatchedContinuation<in T>(
    // dispatcher 对应的就是 Dispatcher.Default
    @JvmField val dispatcher: CoroutineDispatcher,
    // continuation 对应的则是 launch 当中传入的 SuspendLambda 实现类。
    @JvmField val continuation: Continuation<T>
) : DispatchedTask<T>(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation<T> by continuation {

    inline fun resumeCancellableWith(
        result: Result<T>,
        noinline onCancellation: ((cause: Throwable) -> Unit)?
    ) {
        val state = result.toState(onCancellation)
        // 除了 Unconfined 以外，其他的 Dispatcher 都会返回 true。
        if (dispatcher.isDispatchNeeded(context)) {
            _state = state
            resumeMode = MODE_CANCELLABLE
            // 将代码的执行流程分发到 Default 线程池
            // this 指的是 Runnable
            dispatcher.dispatch(context, this)
        } else {
            // executeUnconfined{}，它其实就对应着 Dispather 是 Unconfined 的情况，
            // 这时候，协程的执行不会被分发到别的线程，而是直接在当前线程执行。
            executeUnconfined(state, MODE_CANCELLABLE) {
                if (!resumeCancelled(state)) {
                    resumeUndispatchedWith(result)
                }
            }
        }
    }

}

public abstract class CoroutineDispatcher :
    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {
    // 默认是true
    public open fun isDispatchNeeded(context: CoroutineContext): Boolean = true

    public abstract fun dispatch(context: CoroutineContext, block: Runnable)
}

internal object Unconfined : CoroutineDispatcher() {
    // 只有Unconfined会重写成false
    override fun isDispatchNeeded(context: CoroutineContext): Boolean = false
}
```



##### DispatchedContinuation是什么?

DispatchedTask

```kotlin
internal abstract class DispatchedTask<in T>(
    @JvmField public var resumeMode: Int
) : SchedulerTask() {

}

internal actual typealias SchedulerTask = Task

internal abstract class Task(
    @JvmField var submissionTime: Long,
    @JvmField var taskContext: TaskContext
) : Runnable {
    constructor() : this(0, NonBlockingContext)
    inline val mode: Int get() = taskContext.taskMode // TASK_XXX
}
```

DispatchedContinuation 继承自 DispatchedTask，而它则是 SchedulerTask 的子类，SchedulerTask 是 Task 的类型别名，而 Task 实现了 Runnable 接口。

**因此，DispatchedContinuation 不仅是一个 Continuation，同时还是一个 Runnable。**





##### dispatcher.dispatch(context, this) 流程

相当于调用了Dispatchers.Default.dispatch()

```kotlin
public actual object Dispatchers {

    // Dispatchers.Default 本质上是一个单例对象 DefaultScheduler
    @JvmStatic
    public actual val Default: CoroutineDispatcher = DefaultScheduler
}

internal object DefaultScheduler : SchedulerCoroutineDispatcher(
    CORE_POOL_SIZE, MAX_POOL_SIZE,
    IDLE_WORKER_KEEP_ALIVE_NS, DEFAULT_SCHEDULER_NAME
) {}
```



SchedulerCoroutineDispatcher源码

```kotlin
internal open class SchedulerCoroutineDispatcher(
    private val corePoolSize: Int = CORE_POOL_SIZE,
    private val maxPoolSize: Int = MAX_POOL_SIZE,
    private val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS,
    private val schedulerName: String = "CoroutineScheduler",
) : ExecutorCoroutineDispatcher() {

    private var coroutineScheduler = createScheduler()
	// 调用的是 coroutineScheduler.dispatch()。
    override fun dispatch(context: CoroutineContext, block: Runnable): Unit = coroutineScheduler.dispatch(block)
}
```



CoroutineScheduler源码

```kotlin
internal class CoroutineScheduler(
    @JvmField val corePoolSize: Int,
    @JvmField val maxPoolSize: Int,
    @JvmField val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS,
    @JvmField val schedulerName: String = DEFAULT_SCHEDULER_NAME
) : Executor, Closeable {

    override fun execute(command: Runnable) = dispatch(command)

    fun dispatch(block: Runnable, taskContext: TaskContext = NonBlockingContext, tailDispatch: Boolean = false) {
        trackTask() 
        // 将传入的 Runnable 类型的 block（也就是 DispatchedContinuation），包装成 Task。
        val task = createTask(block, taskContext)
        // currentWorker()，拿到当前执行的线程。这里的 Worker 其实是一个内部类，它本质上仍然是 Java 的 Thread。
        val currentWorker = currentWorker()
        // currentWorker.submitToLocalQueue()，将当前的 Task 添加到 Worker 线程的本地队列，等待执行。
        val notAdded = currentWorker.submitToLocalQueue(task, tailDispatch)
        if (notAdded != null) {
            if (!addToGlobalQueue(notAdded)) {

                throw RejectedExecutionException("$schedulerName was terminated")
            }
        }
        val skipUnpark = tailDispatch && currentWorker != null

        if (task.mode == TASK_NON_BLOCKING) {
            if (skipUnpark) return
            signalCpuWork()
        } else {

            signalBlockingWork(skipUnpark = skipUnpark)
        }
    }

    private fun currentWorker(): Worker? = (Thread.currentThread() as? Worker)?.takeIf { it.scheduler == this }

    // 内部类 Worker
	internal inner class Worker private constructor() : Thread() {

        // 重写 Thread 的 run() 方法，然后把执行流程交给 runWorker()
        override fun run() = runWorker()

        @JvmField
        var mayHaveLocalTasks = false

        private fun runWorker() {
            var rescanned = false
            while (!isTerminated && state != WorkerState.TERMINATED) {
                // 在 while 循环当中，会一直尝试从 Worker 的本地队列取 Task 出来，如果存在需要执行的 Task，就会进入下一步。
                val task = findTask(mayHaveLocalTasks)

                if (task != null) {
                    rescanned = false
                    minDelayUntilStealableTaskNs = 0L
                    // executeTask(task)，其实就是执行对应的 Task。
                    // Task 本质上就是 Runnable，而 Runnable.run() 其实就代表了我们的协程任务真正执行了！
                    executeTask(task)
                    continue
                } else {
                    mayHaveLocalTasks = false
                }

                if (minDelayUntilStealableTaskNs != 0L) {
                    if (!rescanned) {
                        rescanned = true
                    } else {
                        rescanned = false
                        tryReleaseCpu(WorkerState.PARKING)
                        interrupted()
                        LockSupport.parkNanos(minDelayUntilStealableTaskNs)
                        minDelayUntilStealableTaskNs = 0L
                    }
                    continue
                }

                tryPark()
            }
            tryReleaseCpu(WorkerState.TERMINATED)
        }
    }
}
```



executeTask流程

```kotlin
internal inner class Worker private constructor() : Thread() {
    private fun executeTask(task: Task) {
        val taskMode = task.mode
        idleReset(taskMode)
        beforeTask(taskMode)
        // runSafely() 方法，最终会调用 task.run()。
        runSafely(task)
        afterTask(taskMode)
    }
}

fun runSafely(task: Task) {
    try {
        // 执行 DispatchedTask.run
        task.run()
    } catch (e: Throwable) {
        val thread = Thread.currentThread()
        thread.uncaughtExceptionHandler.uncaughtException(thread, e)
    } finally {
        unTrackTask()
    }
}

internal abstract class Task(
    @JvmField var submissionTime: Long,
    @JvmField var taskContext: TaskContext
) : Runnable {
    constructor() : this(0, NonBlockingContext)
    inline val mode: Int get() = taskContext.taskMode // TASK_XXX
}
```



DispatchedTask 实际上是 DispatchedContinuation 的父类

```kotlin
internal class DispatchedContinuation<in T>(
    @JvmField val dispatcher: CoroutineDispatcher,
    @JvmField val continuation: Continuation<T>
) : DispatchedTask<T>(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation<T> by continuation {

    public final override fun run() {

        val taskContext = this.taskContext
        var fatalException: Throwable? = null
        try {
            val delegate = delegate as DispatchedContinuation<T>
            val continuation = delegate.continuation
            withContinuationContext(continuation, delegate.countOrElement) {
                val context = continuation.context
                val state = takeState() 
                val exception = getExceptionalResult(state)

                val job = if (exception == null && resumeMode.isCancellableMode) context[Job] else null
                if (job != null && !job.isActive) {
                    // 在协程代码执行之前，它首先会判断当前协程是否已经取消。
                    // 如果已经取消的话，就会调用 continuation.resumeWithStackTrace(cause) 将具体的原因传出去。
                    val cause = job.getCancellationException()
                    cancelCompletedResult(state, cause)
                    continuation.resumeWithStackTrace(cause)
                } else {
                    if (exception != null) {
                        // 判断协程是否发生了异常，如果已经发生了异常，则需要调用 continuation.resumeWithException(exception) 将异常传递出去。
                        continuation.resumeWithException(exception)
                    } else {
                        // 如果一切正常，则会调用 continuation.resume(getSuccessfulResult(state))，
                        // 这时候，协程才会正式启动，并且执行 launch 当中传入的 Lambda 表达式。
                        continuation.resume(getSuccessfulResult(state))
                    }
                }
            }
        } catch (e: Throwable) {

            fatalException = e
        } finally {
            val result = runCatching { taskContext.afterTask() }
            handleFatalException(fatalException, result.exceptionOrNull())
        }
    }
}
```

