# 协程源码

## 一.挂起函数

### CPS 参数变化

```kotlin
suspend fun testCoroutine() {
    val user = getUserInfo()
    val friendList = getFriendList(user)
    val feedList = getFeedList(user, friendList)
    log(feedList)
}

//挂起函数
// ↓
suspend fun getUserInfo(): String {
    withContext(Dispatchers.IO) {
        delay(1000L)
    }
    return "BoyCoder"
}

//挂起函数
// ↓
suspend fun getFriendList(user: String): String {
    withContext(Dispatchers.IO) {
        delay(1000L)
    }
    return "Tom, Jack"
}

//挂起函数
// ↓
suspend fun getFeedList(user: String, list: String): String {
    withContext(Dispatchers.IO) {
        delay(1000L)
    }
    return "{FeedList..}"
}
```

从 Java 的角度来看待 testCoroutine() 的话，代码中所有的参数都会发生变化。

如下所示：

```kotlin
//                 变化在这里
//                     ↓
fun testCoroutine(continuation: Continuation): Any? {
//                          变化在这里
//                              ↓
    val user = getUserInfo(continuation)
//                                        变化在这里
//                                            ↓
    val friendList = getFriendList(user, continuation)
//                                          变化在这里
//                                              ↓
    val feedList = getFeedList(friendList, continuation)
    log(feedList)
}
```



**为什么挂起函数可以调用挂起函数，普通函数则不能？**

因为普通函数不会有 continuation 这个参数

协程函数会带有 continuation 这个参数



### CPS 返回值变化

```kotlin
suspend fun getUserInfo(): String {}

//                                  变化在这里
//                                     ↓
fun getUserInfo(cont: Continuation): Any? {}
```

getUserInfo() 这个方法，经过 CPS 转换后，它完整的函数签名应该是这样的：

```kotlin
suspend fun getUserInfo(): String {}

//                                变化在这里
//                                    ↓
fun getUserInfo(cont: Continuation<String>): Any? {}
```



**这里的“Any?”又是干什么的呢?**

挂起函数经过 CPS 转换后，它的返回值有一个重要作用：标志该挂起函数有没有被挂起。



**挂起的函数，它还能不被挂起吗?**

当 getUserInfo() 执行到 withContext{} 的时候，就会返回 CoroutineSingletons.COROUTINE_SUSPENDED 表示函数被挂起了。

```kotlin
// suspend 修饰
// ↓
suspend fun noSuspendFriendList(user: String): String{
    // 函数体跟普通函数一样
    return "Tom, Jack"
}
```

当我们调用 noSuspendFriendList() 这个挂起函数的时候，它不会真正挂起，而是会直接返回 String 类型："no suspend"。针对这样的挂起函数，你可以把它看作是伪挂起函数。



**总结**

Any? 可能返回

1.CoroutineSingletons.COROUTINE_SUSPENDED

2."no suspend"

3.null



### 挂起函数的反编译

1.在 testCoroutine() 函数里，会多出一个 ContinuationImpl 的子类，它是整个协程挂起函数的核心。

```kotlin
fun testCoroutine(completion: Continuation<Any?>): Any? {
    // TestContinuation本质上是匿名内部类
    class TestContinuation(completion: Continuation<Any?>?) : ContinuationImpl(completion) {
        // 表示协程状态机当前的状态
        var label: Int = 0
        // 协程返回结果
        var result: Any? = null

        // 用于保存之前协程的计算结果
        var mUser: Any? = null
        var mFriendList: Any? = null

        // invokeSuspend 是协程的关键
        // 它最终会调用 testCoroutine(this) 开启协程状态机
        // 状态机相关代码就是后面的 when 语句
        // 协程的本质，可以说就是 CPS + 状态机
        override fun invokeSuspend(_result: Result<Any?>): Any? {
            result = _result
            label = label or Int.Companion.MIN_VALUE
            return testCoroutine(this)
        }
    }
}
```

- label 是用来代表协程状态机当中状态的；
- result 是用来存储当前挂起函数执行结果的；
- mUser、mFriendList 则是用来存储历史挂起函数执行结果的；
- invokeSuspend 这个函数，是整个状态机的入口，它会将执行流程转交给 testCoroutine() 进行再次调用。



2.判断 testCoroutine 是不是初次运行，如果是初次运行，我们就要创建一个 TestContinuation 的实例对象。

```kotlin
//                    ↓
fun testCoroutine(completion: Continuation<Any?>): Any? {
    ...
    val continuation = if (completion is TestContinuation) {
        completion
    } else {
        //                作为参数
        //                   ↓
        TestContinuation(completion)
    }
}
```

- invokeSuspend 最终会调用 testCoroutine，然后走到这个判断语句；
- 如果是初次运行，会创建一个 TestContinuation 对象，completion 作为参数；
- 这相当于用一个新的 Continuation 包装了旧的 Continuation；
- 如果不是初次运行，直接将 completion 赋值给 continuation；
- 这说明 continuation 在整个运行期间，只会产生一个实例，这能极大地节省内存开销（对比 CallBack）。



3.变量的定义：

```kotlin
// 三个变量，对应原函数的三个变量
lateinit var user: String
lateinit var friendList: String
lateinit var feedList: String

// result 接收协程的运行结果
var result = continuation.result

// suspendReturn 接收挂起函数的返回值
var suspendReturn: Any? = null

// CoroutineSingletons 是个枚举类
// COROUTINE_SUSPENDED 代表当前函数被挂起了
val sFlag = CoroutineSingletons.COROUTINE_SUSPENDED
```

分别代表了函数当中的临时变量、挂起函数执行结果，以及是否挂起的标志位。



4.核心逻辑:

```kotlin
when (continuation.label) {
    0 -> {
        // 检测异常
        throwOnFailure(result)

        log("start")
        // 将 label 置为 1，准备进入下一次状态
        continuation.label = 1

        // 执行 getUserInfo
        suspendReturn = getUserInfo(continuation)

        // 判断是否挂起
        if (suspendReturn == sFlag) {
            return suspendReturn
        } else {
            result = suspendReturn
            //go to next state
        }
    }

    1 -> {
        throwOnFailure(result)

        // 获取 user 值
        user = result as String
        log(user)
        // 将协程结果存到 continuation 里
        continuation.mUser = user
        // 准备进入下一个状态
        continuation.label = 2

        // 执行 getFriendList
        suspendReturn = getFriendList(user, continuation)

        // 判断是否挂起
        if (suspendReturn == sFlag) {
            return suspendReturn
        } else {
            result = suspendReturn
            //go to next state
        }
    }

    2 -> {
        throwOnFailure(result)

        user = continuation.mUser as String

        // 获取 friendList 的值
        friendList = result as String
        log(friendList)

        // 将协程结果存到 continuation 里
        continuation.mUser = user
        continuation.mFriendList = friendList

        // 准备进入下一个状态
        continuation.label = 3

        // 执行 getFeedList
        suspendReturn = getFeedList(user, friendList, continuation)

        // 判断是否挂起
        if (suspendReturn == sFlag) {
            return suspendReturn
        } else {
            result = suspendReturn
            //go to next state
        }
    }

    3 -> {
        throwOnFailure(result)

        user = continuation.mUser as String
        friendList = continuation.mFriendList as String
        feedList = continuation.result as String
        log(feedList)
        loop = false
    }
}
```

- when 表达式实现了协程状态机；
- continuation.label 是状态流转的关键，continuation.label 改变一次，就代表了挂起函数被调用了一次；
- 每次挂起函数执行完后，都会检查是否发生异常；
- testCoroutine 里的原本的代码，被拆分到状态机里各个状态中，分开执行；
- getUserInfo(continuation)、getFriendList(user, continuation)、getFeedList(friendList, continuation) 三个函数调用的是同一个 continuation 实例；
- 如果一个函数被挂起了，它的返回值会是 CoroutineSingletons.COROUTINE_SUSPENDED；
- 在挂起函数执行的过程中，状态机会把之前的结果以成员变量的方式保存在 continuation 中。



#### 协程未挂起的情况

```kotlin
// “伪”挂起函数
// 虽然它有 suspend 修饰，但执行的时候并不会真正挂起，因为它函数体里没有其他挂起函数
//  ↓
suspend fun noSuspendFriendList(user: String): String{
    return "Tom, Jack"
}

suspend fun testNoSuspend() {
    log("start")
    val user = getUserInfo()
    log(user)                  
    //                  变化在这里
    //                      ↓
    val friendList = noSuspendFriendList(user)
    log(friendList)
    val feedList = getFeedList(friendList)
    log(feedList)
}
```



Kotlin 编译器进行 CPS 转换。

```kotlin
when (continuation.label) {
    0 -> {
        ...
    }

    1 -> {
        ...
        //               变化在这里
        //                   ↓
        suspendReturn = noSuspendFriendList(user, continuation)

        // 判断是否挂起
        if (suspendReturn == sFlag) {
            return suspendReturn
        } else {
            result = suspendReturn // 未挂起直接将结果赋值
            //go to next state
        }
    }

    2 -> {
        ...
    }

    3 -> {
        ...
    }
}
```



#### go to next state具体实现？

协程状态机底层字节码，是通过 label 来实现这个 go to next state 的。



真实的字节码反编译出来的 Java 代码

```java
@Nullable
public static final Object testCoroutine(@NotNull Continuation $completion) {
    Object $continuation;
    label37: {
        if ($completion instanceof <TestSuspendKt$testCoroutine$1>) {
            $continuation = (<TestSuspendKt$testCoroutine$1>)$completion;
            if ((((<TestSuspendKt$testCoroutine$1>)$continuation).label & Integer.MIN_VALUE) != 0) {
                ((<TestSuspendKt$testCoroutine$1>)$continuation).label -= Integer.MIN_VALUE;
                break label37;
            }
        }

        $continuation = new ContinuationImpl($completion) {
            // $FF: synthetic field
            Object result;
            int label;
            Object L$0;
            Object L$1;

            @Nullable
            public final Object invokeSuspend(@NotNull Object $result) {
                this.result = $result;
                this.label |= Integer.MIN_VALUE;
                return TestSuspendKt.testCoroutine(this);
            }
        };
    }

    Object var10000;
    label31: {
        String user;
        String friendList;
        Object var6;
        label30: {
            Object $result = ((<TestSuspendKt$testCoroutine$1>)$continuation).result;
            var6 = IntrinsicsKt.getCOROUTINE_SUSPENDED();
            switch(((<TestSuspendKt$testCoroutine$1>)$continuation).label) {
                case 0:
                    ResultKt.throwOnFailure($result);
                    log("start");
                    ((<TestSuspendKt$testCoroutine$1>)$continuation).label = 1;
                    var10000 = getUserInfo((Continuation)$continuation);
                    if (var10000 == var6) {
                        return var6;
                    }
                    break;
                case 1:
                    ResultKt.throwOnFailure($result);
                    var10000 = $result;
                    break;
                case 2:
                    user = (String)((<TestSuspendKt$testCoroutine$1>)$continuation).L$0;
                    ResultKt.throwOnFailure($result);
                    var10000 = $result;
                    break label30;
                case 3:
                    friendList = (String)((<TestSuspendKt$testCoroutine$1>)$continuation).L$1;
                    user = (String)((<TestSuspendKt$testCoroutine$1>)$continuation).L$0;
                    ResultKt.throwOnFailure($result);
                    var10000 = $result;
                    break label31;
                default:
                    throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
            }

            user = (String)var10000;
            log(user);
            ((<TestSuspendKt$testCoroutine$1>)$continuation).L$0 = user;
            ((<TestSuspendKt$testCoroutine$1>)$continuation).label = 2;
            var10000 = getFriendList(user, (Continuation)$continuation);
            if (var10000 == var6) {
                return var6;
            }
        }

        friendList = (String)var10000;
        log(friendList);
        ((<TestSuspendKt$testCoroutine$1>)$continuation).L$0 = user;
        ((<TestSuspendKt$testCoroutine$1>)$continuation).L$1 = friendList;
        ((<TestSuspendKt$testCoroutine$1>)$continuation).label = 3;
        var10000 = getFeedList(friendList, (Continuation)$continuation);
        if (var10000 == var6) {
            return var6;
        }
    }

    String feedList = (String)var10000;
    log(feedList);
    return Unit.INSTANCE;
}
```



### 挂起函数为什么能直接访问协程上下文

挂起函数为什么能直接访问协程上下文

```kotlin
import kotlinx.coroutines.*
import kotlin.coroutines.coroutineContext

//                        挂起函数能可以访问协程上下文吗？
//                                 ↓                              
suspend fun testContext() = coroutineContext
```

反编译成 Java

```java
public static final Object testContext(Continuation $completion) {
  return $completion.getContext();
}
```



Continuation.kt

```kotlin
public interface Continuation<in T> {
    public val context: CoroutineContext

    public fun resumeWith(result: Result<T>)
}

@Suppress("WRONG_MODIFIER_TARGET")
public suspend inline val coroutineContext: CoroutineContext
    get() {
        throw NotImplementedError("Implemented as intrinsic")
    }

```

“suspend inline val coroutineContext”，本质上就是 Kotlin 官方提供的一种方便开发者在挂起函数当中，获取协程上下文的手段。它的具体实现，其实是 Kotlin 编译器来完成的。



我们在挂起函数当中无法直接访问 Continuation 对象，但可以访问到 Continuation 当中的 coroutineContext。要知道，正常情况下，我们想要访问 Continuation.coroutineContext，首先是要拿到 Continuation 对象的。但是，Kotlin 官方通过“suspend inline val coroutineContext”这个顶层变量，让我们开发者能直接拿到 coroutineContext，却对 Continuation 毫无感知。



### 总结

Kotlin 的挂起函数，本质上就是一个状态机。

Kotlin 协程就是通过 label 代码段嵌套，配合 switch 巧妙构造出一个状态机结构



## 二.协程基础元素

Continuation、SafeContinuation、CoroutineContext、CombinedContext、CancellationException、intrinsics。



### Continuation 到底该怎么用？

```kotlin
fun main() = runBlocking {
    val result = getLengthSuspend("Kotlin")
    println(result)
}

suspend fun getLengthSuspend(text: String): Int = suspendCoroutine { continuation->
    thread {
        // 模拟耗时
        Thread.sleep(1000L)
        continuation.resume(text.length)
    }
}

/*
输出结果：
等待1秒
6
*/
```

我们是使用 suspendCoroutine{}实现了挂起函数，然后在它的内部，我们使用 continuation.resume() 的方式，传出了挂起函数的返回值。



**为什么以 continuation.resume() 这样异步的方式传出结果以后，挂起函数就能接收到结果呢？**

把 getLengthSuspend() 这个函数强转成了带有 Continuation 的函数类型，然后通过匿名内部类的方式，创建了一个 Continuation 对象传了进去。

```kotlin
// 变化在这里
fun main()  {
    val func = ::getLengthSuspend as (String, Continuation<Int>) -> Any?

    func("Kotlin", object: Continuation<Int>{
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(result: Result<Int>) {
            println(result.getOrNull())
        }
    })

    // 防止程序提前结束
    Thread.sleep(2000L)
}

suspend fun getLengthSuspend(text: String): Int = suspendCoroutine { continuation->
    thread {
        // 模拟耗时
        Thread.sleep(1000L)
        continuation.resume(text.length)
    }
}
/*
输出结果：
等待1秒
6
*/
```

综上所述，Kotlin 协程当中的 Continuation，作用其实就相当于 Callback，它既可以用于实现挂起函数，往挂起函数的外部传递结果；也可以用于调用挂起函数，我们可以创建 Continuation 的匿名内部类，来接收挂起函数传递出来的结果。



**Java 代码中如何调用 Kotlin 的挂起函数？**

```kotlin
// 需要在Java中调用的Kotlin挂起函数
object SuspendFromJavaExample {
    // 在Java当中如何调用这个方法？
    suspend fun getUserInfo(id: Long):String {
        delay(1000L)
        return "Kotlin"
    }
}
```



```kotlin
public static void main(String[] args) throws InterruptedException {
    SuspendFromJavaExample.INSTANCE.getUserInfo(100L, new Continuation<String>() {
        @NotNull
        @Override
        public CoroutineContext getContext() {
            return EmptyCoroutineContext.INSTANCE;
        }

        @Override
        public void resumeWith(@NotNull Object o) {
            System.out.println(o+"");
        }
    });

    // 防止程序提前结束
    Thread.sleep(2000L);
}

/*
输出结果
Kotlin
*/
```



### suspendCoroutine{}

#### suspendCoroutineUninterceptedOrReturn

suspendCoroutineUninterceptedOrReturn{}。它其实就是实现 suspendCoroutine{}的关键。

```kotlin
public interface Continuation<in T> {
    public val context: CoroutineContext    
    public fun resumeWith(result: Result<T>)
}

public suspend inline fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T {

    // 注意这里
    return suspendCoroutineUninterceptedOrReturn { c: Continuation<T> ->
		// 把原本的 Continuation 包裹一遍。
        val safe = SafeContinuation(c.intercepted())
		// 调用 Lambda 当中的逻辑。
        block(safe)
		// 取出 block(safe) 的运行结果
        safe.getOrThrow()
    }
}
```



suspendCoroutineUninterceptedOrReturn源码:

```kotlin
public suspend inline fun <T> suspendCoroutineUninterceptedOrReturn(crossinline block: (Continuation<T>) -> Any?): T {
    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
    throw NotImplementedError("Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic")
}
```

suspendCoroutineUninterceptedOrReturn 是一个编译器内建函数，它是由 Kotlin 编译器来实现的。



**suspendCoroutineUninterceptedOrReturn 伪挂起函数解析**

```kotlin
fun main() = runBlocking {
    val result = testNoSuspendCoroutine()
    println(result)
}

private suspend fun testNoSuspendCoroutine() = suspendCoroutineUninterceptedOrReturn<String> {
        continuation ->
    return@suspendCoroutineUninterceptedOrReturn "Hello!"
}

/*
输出结果：
Hello!
*/
```

对应的java

```java

    private static final Object testNoSuspendCoroutine(Continuation $completion) {
      int var2 = false;
      if ("Hello!" == IntrinsicsKt.getCOROUTINE_SUSPENDED()) {
         DebugProbesKt.probeCoroutineSuspended($completion);
      }
    
      return "Hello!";
    }
```



**suspendCoroutineUninterceptedOrReturn 挂起函数解析**

```kotlin
fun main() = runBlocking {
    val result = testSuspendCoroutine()
    println(result)
}

private suspend fun testSuspendCoroutine() = suspendCoroutineUninterceptedOrReturn<String> {
    continuation ->
    thread {
        Thread.sleep(1000L)
        continuation.resume("Hello!")


    }
    return@suspendCoroutineUninterceptedOrReturn kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED
}

/*
输出结果：
等待1秒
Hello!
*/
```

对应的java

```java
private static final Object testSuspendCoroutine(Continuation $completion) {
    int var2 = false;
    // 1
    ThreadsKt.thread$default(false, false, (ClassLoader)null, (String)null, 0, (Function0)(new CoroutineBasicElementsKt$testSuspendCoroutine$2$1($completion)), 31, (Object)null);
    // 2
    Object var10000 = IntrinsicsKt.getCOROUTINE_SUSPENDED();
    if (var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED()) {
     DebugProbesKt.probeCoroutineSuspended($completion);
    }
    // 3
    return var10000;
}

final class CoroutineBasicElementsKt$testSuspendCoroutine$2$1 extends Lambda implements Function0 {

   final Continuation $it;

   public Object invoke() {
      this.invoke();
      return Unit.INSTANCE;
   }

   public final void invoke() {
      // 4
      Thread.sleep(1000L);
      Continuation var1 = this.$it;
      String var2 = "Hello!";
      Companion var3 = Result.Companion;
      var1.resumeWith(Result.constructor-impl(var2));
   }

   CoroutineBasicElementsKt$testSuspendCoroutine$2$1(Continuation var1) {
      super(0);
      this.$it = var1;
   }
}
```

- 注释 1、4，创建了一个新的线程，执行了 thread{}当中的代码。
- 注释 2，将 var10000 赋值为 COROUTINE_SUSPENDED 这个挂起标志位。
- 注释 3，返回挂起标志位，代表 testSuspendCoroutine() 这个函数会真正挂起。



**总结:**

suspendCoroutineUninterceptedOrReturn{}这个高阶函数的作用了：它可以将挂起函数当中的 Continuation 以参数的形式暴露出来，在它的 Lambda 当中，我们可以直接返回结果，这时候它就是一个“伪挂起函数”；或者，我们也可以返回 COROUTINE_SUSPENDED 这个挂起标志位，然后使用 continuation.resume() 传递结果。

相应的，suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数，只是对它的一种封装而已。





**suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数，它对比 suspendCoroutineUninterceptedOrReturn{}的优势在哪里？Kotlin 官方为什么要进行这样的封装呢？**

suspendCoroutine{} 或者 suspendCancellableCoroutine{} 在使用的时候，只需要知道 Continuation 接口，而接口中只有一个函数 resumeWith，相对让人比较容易和 Callback 回调关联起来，所以，使用这两个函数的成本较小，不需要对 coroutine 协程的原理有太多的理解。

 而 suspendCoroutineUninterceptedOrReturn{} 函数除了需要关心 Continuation 接口外，还需要关心对应的返回值，而这个返回值中有几种状态，每种状态代表什么意思，其实在对 coroutine 原理不太清楚的情况下，是完全不知道怎么调用的。 总的来说，suspendCoroutineUninterceptedOrReturn{} 使用的学习成本要高很多。





## 三.launch的背后到底发生了什么？

### 协程是如何启动的

Continuation.kt

```kotlin
public fun <T> (suspend () -> T).createCoroutine(
    completion: Continuation<T>
): Continuation<Unit> =
    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)

public fun <T> (suspend () -> T).startCoroutine(
    completion: Continuation<T>
) {
    createCoroutineUnintercepted(completion).intercepted().resume(Unit)
}
```

createCoroutine{}、startCoroutine{}这两个函数，就是 Kotlin 协程当中最基础的两个创建协程的 API。

启动协程有三种常见的方式：launch、runBlocking、async。它们其实属于协程中间层提供的 API，而它们的底层都在某种程度上调用了“基础层”的协程 API。



#### 用基础API来启动协程

**startCoroutine() 启动协程**

```kotlin
fun main() {
    testStartCoroutine()
    Thread.sleep(2000L)
}

// 它的类型就是 suspend () -> T
val block = suspend {
    println("Hello!")
    delay(1000L)
    println("World!")
    "Result"
}

private fun testStartCoroutine() {

    val continuation = object : Continuation<String> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(result: Result<String>) {
            println("Result is: ${result.getOrNull()}")
        }
    }

    block.startCoroutine(continuation)
}

/*
输出结果
Hello!
World!
Result is: Result
*/
```

startCoroutine() 的作用其实就是创建一个新的协程，并且执行 block 当中的逻辑，等协程执行完毕以后，将结果返回给 Continuation 对象。



**createCoroutine()**

```kotlin
private fun testCreateCoroutine() {

    val continuation = object : Continuation<String> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(result: Result<String>) {
            println("Result is: ${result.getOrNull()}")
        }
    }

    val coroutine = block.createCoroutine(continuation)

    coroutine.resume(Unit)
}

/*
输出结果
Hello!
World!
Result is: Result
*/
```

createCoroutine() 的作用其实就是创建一个协程，并暂时先不启动它。等我们想要启动它的时候，直接调用 resume() 即可。



**startCoroutine() 之所以可以创建并同时启动协程的原因就在于，它在源码中直接调用了 resume(Unit)**



### startCoroutine实现原理

反编译java

```kotlin
public final class LaunchUnderTheHoodKt {

    public static final void main() {
        testStartCoroutine();
        Thread.sleep(2000L);
    }

	// block 其实就是 SuspendLambda 的子类，而 SuspendLambda 则是 ContinuationImpl 的子类。
    private static final Function1<Continuation<? super String>, Object> block = new LaunchUnderTheHoodKt$block$1(null);


    public static final Function1<Continuation<? super String>, Object> getBlock() {
        return block;
    }

    /**
    1.block 具体的实现类
    2.继承自 SuspendLambda，而 SuspendLambda 是 ContinuationImpl 的子类，因此它也间接实现了 Continuation 接口。
    3.invokeSuspend()协程状态机逻辑
    4.create()方法
    */
    static final class LaunchUnderTheHoodKt$block$1 extends SuspendLambda implements Function1<Continuation<? super String>, Object> {
        int label;

        LaunchUnderTheHoodKt$block$1(Continuation $completion) {
          super(1, $completion);
        }

        @Nullable
        public final Object invokeSuspend(@NotNull Object $result) {
          Object object = IntrinsicsKt.getCOROUTINE_SUSPENDED();
          switch (this.label) {
            case 0:
              ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);
              System.out
                .println("Hello!");
              this.label = 1;
              if (DelayKt.delay(1000L, (Continuation)this) == object)
                return object; 
              DelayKt.delay(1000L, (Continuation)this);
              System.out
                .println("World!");
              return "Result";
            case 1:
              ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);
              System.out.println("World!");
              return "Result";
          } 
          throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
        }

        @NotNull
        public final Continuation<Unit> create(@NotNull Continuation<? super LaunchUnderTheHoodKt$block$1> $completion) {
          return (Continuation<Unit>)new LaunchUnderTheHoodKt$block$1($completion);
        }

        @Nullable
        public final Object invoke(@Nullable Continuation<?> p1) {
          return ((LaunchUnderTheHoodKt$block$1)create(p1)).invokeSuspend(Unit.INSTANCE);
        }
    }

    // block.startCoroutine(continuation) 变成了“ContinuationKt.startCoroutine(block, continuation)”，这其实就体现出了扩展函数的原理。
    private static final void testStartCoroutine() {
        LaunchUnderTheHoodKt$testStartCoroutine$continuation$1 continuation = new LaunchUnderTheHoodKt$testStartCoroutine$continuation$1();
        ContinuationKt.startCoroutine(block, continuation);
    }

    // continuation 变量对应的匿名内部类。
    public static final class LaunchUnderTheHoodKt$testStartCoroutine$continuation$1 implements Continuation<String> {
        @NotNull
        public CoroutineContext getContext() {
          return (CoroutineContext)EmptyCoroutineContext.INSTANCE;
        }

        public void resumeWith(@NotNull Object result) {
          System.out.println(Intrinsics.stringPlus("Result is: ", Result.isFailure-impl(result) ? null : result));
        }
    }
}

// SuspendLambda 则是 ContinuationImpl 的子类。
internal abstract class SuspendLambda(
    public override val arity: Int,
    completion: Continuation<Any?>?
) : ContinuationImpl(completion), FunctionBase<Any?>, SuspendFunction {}
```



#### 流程分析:

1.main() 函数会调用 testStartCoroutine() 函数，接着，就会调用 startCoroutine() 方法。

```kotlin
public fun <T> (suspend () -> T).startCoroutine(
    completion: Continuation<T>
) {
//        注意这里
//           ↓
createCoroutineUnintercepted(completion).intercepted().resume(Unit)
}
```

createCoroutineUnintercepted具体实现代码在Kotlin 的源代码， JVM 平台对应

```kotlin
//    1，注意这里, 这个 actual，代表了 createCoroutineUnintercepted() 在 JVM 平台的实现。
//       ↓
public actual fun <T> (suspend () -> T).createCoroutineUnintercepted(
    completion: Continuation<T>
): Continuation<Unit> {
    val probeCompletion = probeCoroutineCreated(completion)
    // 注意这里,this，其实就代表了前面 block 变量
    // block 其实就是 SuspendLambda 的子类，而 SuspendLambda 则是 ContinuationImpl 的子类。
    // (this is BaseContinuationImpl) 条件一定是为 true 的
    return if (this is BaseContinuationImpl)
        create(probeCompletion)
    else
        createCoroutineFromSuspendFunction(probeCompletion) {
            (this as Function1<Continuation<T>, Any?>).invoke(it)
        }
}
```

在默认情况下，这个 create() 方法是会抛出异常的，

```kotlin
public open fun create(completion: Continuation<*>): Continuation<Unit> {
    throw UnsupportedOperationException("create(Continuation) has not been overridden")
}
```

重写后

```kotlin
static final class LaunchUnderTheHoodKt$block$1 extends SuspendLambda implements Function1<Continuation<? super String>, Object> {
    // ...
    public final Continuation<Unit> create(@NotNull Continuation<? super LaunchUnderTheHoodKt$block$1> $completion) {
      // 最终会返回“LaunchUnderTheHoodKt$block$1”这个 block 实现类，对应的 Continuation 对象。
      // 这行代码，其实就对应着协程被创建的时刻。
      return (Continuation<Unit>)new LaunchUnderTheHoodKt$block$1($completion);
    }
    // ...
}
```



2.intercepted()

```kotlin
public actual fun <T> Continuation<T>.intercepted(): Continuation<T> = (this as? ContinuationImpl)?.intercepted() ?: this
```

将 Continuation 强转成了 ContinuationImpl，调用了它的 intercepted()。

由于 this 的类型是“LaunchUnderTheHoodKt$block$1”，它是 ContinuationImpl 的子类，所以这个类型转换一定可以成功。



ContinuationImpl:

```kotlin
internal abstract class ContinuationImpl(
    completion: Continuation<Any?>?,
    private val _context: CoroutineContext?
) : BaseContinuationImpl(completion) {

    @Transient
    private var intercepted: Continuation<Any?>? = null

    public fun intercepted(): Continuation<Any?> =
        intercepted
            ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)
                .also { intercepted = it }
}
```

这里其实就是通过 ContinuationInterceptor，对 Continuation 进行拦截，从而将程序的执行逻辑派发到特定的线程之上



3.resume(Unit)

resume(Unit)，作用其实就相当于启动了协程。



### launch 是如何启动协程的？

```kotlin
fun main() {
    testLaunch()
    Thread.sleep(2000L)
}

private fun testLaunch() {
    val scope = CoroutineScope(Job())
    scope.launch {
        println("Hello!")
        delay(1000L)
        println("World!")
    }
}

/*
输出结果：
Hello!
World!
*/
```

反编译java

```java
public final class LaunchUnderTheHoodKt {
  public static final void main() {
    testLaunch();
    Thread.sleep(2000L);
  }

  private static final void testLaunch() {
    CoroutineScope scope = CoroutineScopeKt.CoroutineScope((CoroutineContext)JobKt.Job$default(null, 1, null));
    BuildersKt.launch$default(scope, null, null, new LaunchUnderTheHoodKt$testLaunch$1(null), 3, null);
  }

    // “LaunchUnderTheHoodKt$testLaunch$1”这个类，它其实对应的就是我们 launch 当中的 Lambda。
  static final class LaunchUnderTheHoodKt$testLaunch$1 extends SuspendLambda implements Function2<CoroutineScope, Continuation<? super Unit>, Object> {
    int label;

    LaunchUnderTheHoodKt$testLaunch$1(Continuation $completion) {
      super(2, $completion);
    }

    @Nullable
    public final Object invokeSuspend(@NotNull Object $result) {
      Object object = IntrinsicsKt.getCOROUTINE_SUSPENDED();
      switch (this.label) {
        case 0:
          ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);
          System.out
            .println("Hello!");
          this.label = 1;
          if (DelayKt.delay(1000L, (Continuation)this) == object)
            return object; 
          DelayKt.delay(1000L, (Continuation)this);
          System.out
            .println("World!");
          return Unit.INSTANCE;
        case 1:
          ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);
          System.out.println("World!");
          return Unit.INSTANCE;
      } 
      throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
    }

    @NotNull
    public final Continuation<Unit> create(@Nullable Object value, @NotNull Continuation<? super LaunchUnderTheHoodKt$testLaunch$1> $completion) {
      return (Continuation<Unit>)new LaunchUnderTheHoodKt$testLaunch$1($completion);
    }

    @Nullable
    public final Object invoke(@NotNull CoroutineScope p1, @Nullable Continuation<?> p2) {
      return ((LaunchUnderTheHoodKt$testLaunch$1)create(p1, p2)).invokeSuspend(Unit.INSTANCE);
    }
  }
}
```





```kotlin
private fun testLaunch() {
    val scope = CoroutineScope(Job())
    val block: suspend CoroutineScope.() -> Unit = {
        println("Hello!")
        delay(1000L)
        println("World!")
    }
    scope.launch(block = block)
}
```

launch{} 的源代码

```kotlin
public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
): Job {
    // launch 会根据传入的 CoroutineContext 创建出新的 Context。
    val newContext = newCoroutineContext(context)
    // launch 会根据传入的启动模式来创建对应的协程对象。这里有两种，一种是标准的，一种是懒加载的。
    val coroutine = if (start.isLazy)
        LazyStandaloneCoroutine(newContext, block) else
        StandaloneCoroutine(newContext, active = true)
    // 尝试启动协程。
    coroutine.start(start, coroutine, block)
    return coroutine
}
```



coroutine.start() 这个方法，会进入 AbstractCoroutine 这个抽象类：

```kotlin
public abstract class AbstractCoroutine<in T>(
    parentContext: CoroutineContext,
    initParentJob: Boolean,
    active: Boolean
) : JobSupport(active), Job, Continuation<T>, CoroutineScope {

    // 省略

    public fun <R> start(start: CoroutineStart, receiver: R, block: suspend R.() -> T) {
        start(block, receiver, this)
    }
}
```

start(block, receiver, this)，就会进入 CoroutineStart.invoke()。

```kotlin
public enum class CoroutineStart {
    public operator fun <T> invoke(block: suspend () -> T, completion: Continuation<T>): Unit =
        when (this) {
            DEFAULT -> block.startCoroutineCancellable(completion) // 默认, 启动以后可以响应取消
            ATOMIC -> block.startCoroutine(completion) // startCoroutine() 这个协程基础 API。
            UNDISPATCHED -> block.startCoroutineUndispatched(completion) // 启动协程以后就不会被分发
            LAZY -> Unit // will start lazily
        }
}
```

startCoroutineCancellable

```kotlin
public fun <T> (suspend () -> T).startCoroutineCancellable(completion: Continuation<T>): Unit = runSafely(completion) {
    // 1
    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))
}

public actual fun <T> (suspend () -> T).createCoroutineUnintercepted(
    completion: Continuation<T>
): Continuation<Unit> {
    val probeCompletion = probeCoroutineCreated(completion)

    return if (this is BaseContinuationImpl)
        // 2
        create(probeCompletion)
    else
        createCoroutineFromSuspendFunction(probeCompletion) {
            (this as Function1<Continuation<T>, Any?>).invoke(it)
        }
}
```

此处流程和基础API流程一样





**使用挂起函数启动协程和suspend {} 启动的协程有什么不一样**

```kotlin
private suspend fun func(): String {
    println("Hello!")
    delay(1000L)
    println("World!")
    return "Result"
}

private fun testStartCoroutineForSuspend() {
    val block = ::func

    val continuation = object : Continuation<String> {
        override val context: CoroutineContext
            get() = EmptyCoroutineContext

        override fun resumeWith(result: Result<String>) {
            println("Result is: ${result.getOrNull()}")
        }
    }

    block.startCoroutine(continuation)
}
```

startCoroutine -> createCoroutineUnintercepted -> createCoroutineFromSuspendFunction,最终返回一个RestrictedContinuationImpl对象,然后调用其resume方法,从而调用block的invoke方法.最终调起协程.




## 四.Dispatchers

**Dispatchers、CoroutineDispatcher、ContinuationInterceptor、CoroutineContext 之间的关系**

Dispatchers 是一个单例对象，它当中的 Default、Main、Unconfined、IO，类型都是 CoroutineDispatcher，而它本身就是 CoroutineContext。

```kotlin
public actual object Dispatchers {

    public actual val Default: CoroutineDispatcher = DefaultScheduler

    public actual val Main: MainCoroutineDispatcher get() = MainDispatcherLoader.dispatcher

    public actual val Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined

    public val IO: CoroutineDispatcher = DefaultIoScheduler

    public fun shutdown() {    }
}

public abstract class CoroutineDispatcher :
    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {}

public interface ContinuationInterceptor : CoroutineContext.Element {}

public interface Element : CoroutineContext {}
```



### launch为什么运行在DefaultDispatcher上?

```kotlin
fun main() {
    testLaunch()
    Thread.sleep(2000L)
}

private fun testLaunch() {
    val scope = CoroutineScope(Job())
    scope.launch{
        logX("Hello!")
        delay(1000L)
        logX("World!")
    }
}

/**
 * 控制台输出带协程信息的log
 */
fun logX(any: Any?) {
    println(
        """
================================
$any
Thread:${Thread.currentThread().name}
================================""".trimIndent()
    )
}

/*
输出结果
================================
Hello!
Thread:DefaultDispatcher-worker-1 @coroutine#1
================================
================================
World!
Thread:DefaultDispatcher-worker-1 @coroutine#1
================================
*/
```



launch 的源代码

```kotlin
public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
): Job {
    // EmptyCoroutineContext相当于一个空的 Map, Kotlin 官方用 EmptyCoroutineContext 替代了 null。
    val newContext = newCoroutineContext(context)
    val coroutine = if (start.isLazy)
        LazyStandaloneCoroutine(newContext, block) else
        StandaloneCoroutine(newContext, active = true)
    coroutine.start(start, coroutine, block)
    return coroutine
}
```

newCoroutineContext

```kotlin
public actual fun CoroutineScope.newCoroutineContext(context: CoroutineContext): CoroutineContext {
    // newCoroutineContext() 是 CoroutineScope 的扩展函数，因此，我们可以直接访问 CoroutineScope 的 coroutineContext 对象
    // foldCopiesForChildCoroutine() 的作用，其实就是将 CoroutineScope 当中的所有上下文元素都拷贝出来，然后跟传入的 context 参数进行合并。这行代码，可以让子协程继承父协程的上下文元素。
    val combined = coroutineContext.foldCopiesForChildCoroutine() + context
    // 在调试模式下，为我们的协程对象增加唯一的 ID。
    val debug = if (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) else combined
    // 如果合并过后的 combined 当中没有 CoroutineDispatcher，那么，就会默认使用 Dispatchers.Default。
    return if (combined !== Dispatchers.Default && combined[ContinuationInterceptor] == null)
        debug + Dispatchers.Default else debug
}
```

由于我们定义的 scope 没有指定 Dispatcher，同时 launch 的参数也没有传入 Dispatcher，最终在 newCoroutineContext() 的时候，会被默认指定为 Default 线程池。



**为什么协程默认的线程池是 Dispatchers.Default，而不是 Main 呢？**

因为 Kotlin 协程是支持多平台的，Main 线程只在 UI 编程平台才有可用。



### CoroutineDispatcher 拦截器

#### intercepted流程

```kotlin
public fun <T> (suspend () -> T).startCoroutineCancellable(completion: Continuation<T>): Unit = runSafely(completion) {
    // intercepted() 方法，其实就是 Continuation 的扩展函数。
    //                                        注意这里
    //                                           ↓
    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))
}

// 最终会调用 BaseContinuationImpl 的 intercepted() 方法。
public actual fun <T> Continuation<T>.intercepted(): Continuation<T> =
    (this as? ContinuationImpl)?.intercepted() ?: this

internal abstract class ContinuationImpl(
    completion: Continuation<Any?>?,
    private val _context: CoroutineContext?
) : BaseContinuationImpl(completion) {
    constructor(completion: Continuation<Any?>?) : this(completion, completion?.context)

    @Transient
    private var intercepted: Continuation<Any?>? = null

    // intercepted 如果为空，就会调用 context[ContinuationInterceptor]，获取上下文当中的 Dispatcher 对象。
    // 上文sample的 Dispatcher 肯定是 Default 线程池。
    public fun intercepted(): Continuation<Any?> =
        intercepted
            ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)
                .also { intercepted = it }
}
```

interceptContinuation(this)

```kotlin
public abstract class CoroutineDispatcher :
    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {

    // interceptContinuation() 直接返回了一个 DispatchedContinuation 对象，并且将 this、continuation 作为参数传了进去。
    // 这里的 this，其实就是 Dispatchers.Default。
    public final override fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T> =
        DispatchedContinuation(this, continuation)
}
```



startCoroutineCancellable() 改写一下

```kotlin
public fun <T> (suspend () -> T).startCoroutineCancellable(completion: Continuation<T>): Unit = runSafely(completion) {
    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))
}

// 等价
//  ↓

public fun <T> (suspend () -> T).startCoroutineCancellable(completion: Continuation<T>): Unit = runSafely(completion) {
    // 1
    val continuation = createCoroutineUnintercepted(completion)
    // 2
    val dispatchedContinuation = continuation.intercepted()
    // 3
    dispatchedContinuation.resumeCancellableWith(Result.success(Unit))
}
```



#### resumeCancellableWith流程

```kotlin
// DispatchedContinuation 不仅是一个 Continuation，同时还是一个 Runnable。
internal class DispatchedContinuation<in T>(
    // dispatcher 对应的就是 Dispatcher.Default
    @JvmField val dispatcher: CoroutineDispatcher,
    // continuation 对应的则是 launch 当中传入的 SuspendLambda 实现类。
    @JvmField val continuation: Continuation<T>
) : DispatchedTask<T>(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation<T> by continuation {

    inline fun resumeCancellableWith(
        result: Result<T>,
        noinline onCancellation: ((cause: Throwable) -> Unit)?
    ) {
        val state = result.toState(onCancellation)
        // 除了 Unconfined 以外，其他的 Dispatcher 都会返回 true。
        if (dispatcher.isDispatchNeeded(context)) {
            _state = state
            resumeMode = MODE_CANCELLABLE
            // 将代码的执行流程分发到 Default 线程池
            // this 指的是 Runnable
            dispatcher.dispatch(context, this)
        } else {
            // executeUnconfined{}，它其实就对应着 Dispather 是 Unconfined 的情况，
            // 这时候，协程的执行不会被分发到别的线程，而是直接在当前线程执行。
            executeUnconfined(state, MODE_CANCELLABLE) {
                if (!resumeCancelled(state)) {
                    resumeUndispatchedWith(result)
                }
            }
        }
    }

}

public abstract class CoroutineDispatcher :
    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {
    // 默认是true
    public open fun isDispatchNeeded(context: CoroutineContext): Boolean = true

    public abstract fun dispatch(context: CoroutineContext, block: Runnable)
}

internal object Unconfined : CoroutineDispatcher() {
    // 只有Unconfined会重写成false
    override fun isDispatchNeeded(context: CoroutineContext): Boolean = false
}
```



##### DispatchedContinuation是什么?

DispatchedTask

```kotlin
internal abstract class DispatchedTask<in T>(
    @JvmField public var resumeMode: Int
) : SchedulerTask() {

}

internal actual typealias SchedulerTask = Task

internal abstract class Task(
    @JvmField var submissionTime: Long,
    @JvmField var taskContext: TaskContext
) : Runnable {
    constructor() : this(0, NonBlockingContext)
    inline val mode: Int get() = taskContext.taskMode // TASK_XXX
}
```

DispatchedContinuation 继承自 DispatchedTask，而它则是 SchedulerTask 的子类，SchedulerTask 是 Task 的类型别名，而 Task 实现了 Runnable 接口。

**因此，DispatchedContinuation 不仅是一个 Continuation，同时还是一个 Runnable。**





##### dispatcher.dispatch(context, this) 流程

相当于调用了Dispatchers.Default.dispatch()

```kotlin
public actual object Dispatchers {

    // Dispatchers.Default 本质上是一个单例对象 DefaultScheduler
    @JvmStatic
    public actual val Default: CoroutineDispatcher = DefaultScheduler
}

internal object DefaultScheduler : SchedulerCoroutineDispatcher(
    CORE_POOL_SIZE, MAX_POOL_SIZE,
    IDLE_WORKER_KEEP_ALIVE_NS, DEFAULT_SCHEDULER_NAME
) {}
```



SchedulerCoroutineDispatcher源码

```kotlin
internal open class SchedulerCoroutineDispatcher(
    private val corePoolSize: Int = CORE_POOL_SIZE,
    private val maxPoolSize: Int = MAX_POOL_SIZE,
    private val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS,
    private val schedulerName: String = "CoroutineScheduler",
) : ExecutorCoroutineDispatcher() {

    private var coroutineScheduler = createScheduler()
	// 调用的是 coroutineScheduler.dispatch()。
    override fun dispatch(context: CoroutineContext, block: Runnable): Unit = coroutineScheduler.dispatch(block)
}
```



CoroutineScheduler源码

```kotlin
internal class CoroutineScheduler(
    @JvmField val corePoolSize: Int,
    @JvmField val maxPoolSize: Int,
    @JvmField val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS,
    @JvmField val schedulerName: String = DEFAULT_SCHEDULER_NAME
) : Executor, Closeable {

    override fun execute(command: Runnable) = dispatch(command)

    fun dispatch(block: Runnable, taskContext: TaskContext = NonBlockingContext, tailDispatch: Boolean = false) {
        trackTask() 
        // 将传入的 Runnable 类型的 block（也就是 DispatchedContinuation），包装成 Task。
        val task = createTask(block, taskContext)
        // currentWorker()，拿到当前执行的线程。这里的 Worker 其实是一个内部类，它本质上仍然是 Java 的 Thread。
        val currentWorker = currentWorker()
        // currentWorker.submitToLocalQueue()，将当前的 Task 添加到 Worker 线程的本地队列，等待执行。
        val notAdded = currentWorker.submitToLocalQueue(task, tailDispatch)
        if (notAdded != null) {
            if (!addToGlobalQueue(notAdded)) {

                throw RejectedExecutionException("$schedulerName was terminated")
            }
        }
        val skipUnpark = tailDispatch && currentWorker != null

        if (task.mode == TASK_NON_BLOCKING) {
            if (skipUnpark) return
            signalCpuWork()
        } else {

            signalBlockingWork(skipUnpark = skipUnpark)
        }
    }

    private fun currentWorker(): Worker? = (Thread.currentThread() as? Worker)?.takeIf { it.scheduler == this }

    // 内部类 Worker
	internal inner class Worker private constructor() : Thread() {

        // 重写 Thread 的 run() 方法，然后把执行流程交给 runWorker()
        override fun run() = runWorker()

        @JvmField
        var mayHaveLocalTasks = false

        private fun runWorker() {
            var rescanned = false
            while (!isTerminated && state != WorkerState.TERMINATED) {
                // 在 while 循环当中，会一直尝试从 Worker 的本地队列取 Task 出来，如果存在需要执行的 Task，就会进入下一步。
                val task = findTask(mayHaveLocalTasks)

                if (task != null) {
                    rescanned = false
                    minDelayUntilStealableTaskNs = 0L
                    // executeTask(task)，其实就是执行对应的 Task。
                    // Task 本质上就是 Runnable，而 Runnable.run() 其实就代表了我们的协程任务真正执行了！
                    executeTask(task)
                    continue
                } else {
                    mayHaveLocalTasks = false
                }

                if (minDelayUntilStealableTaskNs != 0L) {
                    if (!rescanned) {
                        rescanned = true
                    } else {
                        rescanned = false
                        tryReleaseCpu(WorkerState.PARKING)
                        interrupted()
                        LockSupport.parkNanos(minDelayUntilStealableTaskNs)
                        minDelayUntilStealableTaskNs = 0L
                    }
                    continue
                }

                tryPark()
            }
            tryReleaseCpu(WorkerState.TERMINATED)
        }
    }
}
```



executeTask流程

```kotlin
internal inner class Worker private constructor() : Thread() {
    private fun executeTask(task: Task) {
        val taskMode = task.mode
        idleReset(taskMode)
        beforeTask(taskMode)
        // runSafely() 方法，最终会调用 task.run()。
        runSafely(task)
        afterTask(taskMode)
    }
}

fun runSafely(task: Task) {
    try {
        // 执行 DispatchedTask.run
        task.run()
    } catch (e: Throwable) {
        val thread = Thread.currentThread()
        thread.uncaughtExceptionHandler.uncaughtException(thread, e)
    } finally {
        unTrackTask()
    }
}

internal abstract class Task(
    @JvmField var submissionTime: Long,
    @JvmField var taskContext: TaskContext
) : Runnable {
    constructor() : this(0, NonBlockingContext)
    inline val mode: Int get() = taskContext.taskMode // TASK_XXX
}
```



DispatchedTask 实际上是 DispatchedContinuation 的父类

```kotlin
internal class DispatchedContinuation<in T>(
    @JvmField val dispatcher: CoroutineDispatcher,
    @JvmField val continuation: Continuation<T>
) : DispatchedTask<T>(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation<T> by continuation {

    public final override fun run() {

        val taskContext = this.taskContext
        var fatalException: Throwable? = null
        try {
            val delegate = delegate as DispatchedContinuation<T>
            val continuation = delegate.continuation
            withContinuationContext(continuation, delegate.countOrElement) {
                val context = continuation.context
                val state = takeState() 
                val exception = getExceptionalResult(state)

                val job = if (exception == null && resumeMode.isCancellableMode) context[Job] else null
                if (job != null && !job.isActive) {
                    // 在协程代码执行之前，它首先会判断当前协程是否已经取消。
                    // 如果已经取消的话，就会调用 continuation.resumeWithStackTrace(cause) 将具体的原因传出去。
                    val cause = job.getCancellationException()
                    cancelCompletedResult(state, cause)
                    continuation.resumeWithStackTrace(cause)
                } else {
                    if (exception != null) {
                        // 判断协程是否发生了异常，如果已经发生了异常，则需要调用 continuation.resumeWithException(exception) 将异常传递出去。
                        continuation.resumeWithException(exception)
                    } else {
                        // 如果一切正常，则会调用 continuation.resume(getSuccessfulResult(state))，
                        // 这时候，协程才会正式启动，并且执行 launch 当中传入的 Lambda 表达式。
                        continuation.resume(getSuccessfulResult(state))
                    }
                }
            }
        } catch (e: Throwable) {

            fatalException = e
        } finally {
            val result = runCatching { taskContext.afterTask() }
            handleFatalException(fatalException, result.exceptionOrNull())
        }
    }
}
```



## 五、CoroutineScope是如何管理协程的？

### 协程父子关系在哪里建立的？

```kotlin
private fun testScope() {
   // 父子关系建立流程
   val scope = CoroutineScope(Job())
    scope.launch{
        launch {
            delay(1000000L)
            logX("Inner")  // 不会执行
        }
        logX("Hello!")
        delay(1000000L)
        logX("World!")  // 不会执行
    }

    Thread.sleep(500L)
    // 取消流程
    scope.cancel()
}

public interface CoroutineScope {
    public val coroutineContext: CoroutineContext
}

public interface Job : CoroutineContext.Element {}
```



**CoroutineScope 是一个接口，为什么可以调用它的构造函数，来创建 CoroutineScope 对象呢？**

```kotlin
// 顶层函数
public fun CoroutineScope(context: CoroutineContext): CoroutineScope =
    // 1
    ContextScope(if (context[Job] != null) context else context + Job())

// 顶层函数
public fun Job(parent: Job? = null): CompletableJob = JobImpl(parent)
```

在 Kotlin 当中，当顶层函数作为构造函数使用的时候，它的首字母是要大写的。

注释 1：每一个 CoroutineScope 对象，它的 Context 当中必定存在一个 Job 对象。



**launch 的源代码**

```kotlin
public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
): Job {

    val newContext = newCoroutineContext(context)
    // 分析
    val coroutine = if (start.isLazy)
        LazyStandaloneCoroutine(newContext, block) else
        StandaloneCoroutine(newContext, active = true)

    coroutine.start(start, coroutine, block)
    return coroutine
}
```



**LazyStandaloneCoroutine/StandaloneCoroutine**

```kotlin
private open class StandaloneCoroutine(
    parentContext: CoroutineContext,
    active: Boolean
) : AbstractCoroutine<Unit>(parentContext, initParentJob = true, active = active) {
    override fun handleJobException(exception: Throwable): Boolean {
        handleCoroutineException(context, exception)
        return true
    }
}

private class LazyStandaloneCoroutine(
    parentContext: CoroutineContext,
    block: suspend CoroutineScope.() -> Unit
) : StandaloneCoroutine(parentContext, active = false) {
    private val continuation = block.createCoroutineUnintercepted(this, this)

    override fun onStart() {
        continuation.startCoroutineCancellable(this)
    }
}
```

AbstractCoroutine代表了协程的抽象类

initParentJob 代表了协程创建了以后，是否需要初始化协程的父子关系。

LazyStandaloneCoroutine的active参数是 false，代表了以懒加载的方式创建协程。



**AbstractCoroutine源码**

```kotlin
public abstract class AbstractCoroutine<in T>(
    parentContext: CoroutineContext,
    initParentJob: Boolean,
    active: Boolean
) : JobSupport(active), Job, Continuation<T>, CoroutineScope {

    init {
        // parentContext[Job]取出来的 Job，其实就是我们在 Scope 当中的 Job。
        if (initParentJob) initParentJob(parentContext[Job])
    }
}
```



**JobSupport.initParentJob()**

```kotlin
public open class JobSupport constructor(active: Boolean) : Job, ChildJob, ParentJob, SelectClause0 {
    final override val key: CoroutineContext.Key<*> get() = Job

    protected fun initParentJob(parent: Job?) {
        assert { parentHandle == null }
        // 如果 parent 为空，说明当前的协程不存在父 Job，这时候就谈不上创建协程父子关系了。
        // 按之前代码分析,此处的parent则是 scope 当中的 Job
        if (parent == null) {
            parentHandle = NonDisposableHandle
            return
        }
        // 确保 parent 对应的 Job 启动了
        parent.start()
        @Suppress("DEPRECATION")
        // 将当前的 Job，添加为 parent 的子 Job。这里其实就是建立协程父子关系的关键代码。
        val handle = parent.attachChild(this)
        parentHandle = handle

        if (isCompleted) {
            handle.dispose()
            parentHandle = NonDisposableHandle 
        }
    }
}

// Job源码
public interface Job : CoroutineContext.Element {
    public val children: Sequence<Job>   
    public fun attachChild(child: ChildJob): ChildHandle
}
```

我们可以将协程的结构当作一颗 N 叉树。每一个协程，都对应着一个 Job 的对象，而每一个 Job 可以有一个父 Job，也可以有多个子 Job。



### 协程是如何“结构化取消”的？

**scope.cancel() 流程**

```kotlin
public fun CoroutineScope.cancel(cause: CancellationException? = null) {
    val job = coroutineContext[Job] ?: error("Scope cannot be cancelled because it does not have a job: $this")
    job.cancel(cause)
}
```

CoroutineScope 的 cancel() 方法，本质上是调用了它当中的 Job.cancel()。

而这个方法的具体实现在 JobSupport 当中：

```kotlin
public override fun cancel(cause: CancellationException?) {
    cancelInternal(cause ?: defaultCancellationException())
}

public open fun cancelInternal(cause: Throwable) {
    cancelImpl(cause)
}

// 注意,此处会递归调用
internal fun cancelImpl(cause: Any?): Boolean {
    var finalState: Any? = COMPLETING_ALREADY
    // onCancelComplete 代表了当前的 Job，是否有协程体需要执行。
    // 由于 CoroutineScope 当中的 Job 是我们手动创建的，并不需要执行任何协程代码，所以，它会是 true。
    if (onCancelComplete) {
        // 1
        finalState = cancelMakeCompleting(cause)
        if (finalState === COMPLETING_WAITING_CHILDREN) return true
    }
    if (finalState === COMPLETING_ALREADY) {
        // 2
        finalState = makeCancelling(cause)
    }
    return when {
        finalState === COMPLETING_ALREADY -> true
        finalState === COMPLETING_WAITING_CHILDREN -> true
        finalState === TOO_LATE_TO_CANCEL -> false
        else -> {
            afterCompletion(finalState)
            true
        }
    }
}
```



**cancelMakeCompleting流程**

```kotlin
private fun cancelMakeCompleting(cause: Any?): Any? {
    loopOnState { state ->
        // 省略部分
        val finalState = tryMakeCompleting(state, proposedUpdate)
        if (finalState !== COMPLETING_RETRY) return finalState
    }
}

private fun tryMakeCompleting(state: Any?, proposedUpdate: Any?): Any? {
    if (state !is Incomplete)
        return COMPLETING_ALREADY

        // 省略部分
        return COMPLETING_RETRY
    }

    return tryMakeCompletingSlowPath(state, proposedUpdate)
}

private fun tryMakeCompletingSlowPath(state: Incomplete, proposedUpdate: Any?): Any? {
    // 省略部分
    notifyRootCause?.let { notifyCancelling(list, it) }

    return finalizeFinishingState(finishing, proposedUpdate)
}
```



**notifyCancelling流程**

```kotlin
private fun notifyCancelling(list: NodeList, cause: Throwable) {

    onCancelling(cause)
    // 1，通知子Job
    notifyHandlers<JobCancellingNode>(list, cause)
    // 2，通知父Job
    cancelParent(cause)
}
```



**通知子Job流程**

```kotlin
private inline fun <reified T: JobNode> notifyHandlers(list: NodeList, cause: Throwable?) {
    var exception: Throwable? = null
    list.forEach<T> { node ->
        try {
            node.invoke(cause)
        } catch (ex: Throwable) {
            exception?.apply { addSuppressedThrowable(ex) } ?: run {
                exception =  CompletionHandlerException("Exception in completion handler $node for $this", ex)
            }
        }
    }
    exception?.let { handleOnCompletionException(it) }
}
```

遍历当前 Job 的子 Job，并将取消的 cause 传递过去，这里的 invoke() 最终会调用 ChildHandleNode 的 invoke() 方法：

```kotlin
internal class ChildHandleNode(
    @JvmField val childJob: ChildJob
) : JobCancellingNode(), ChildHandle {
    override val parent: Job get() = job
    override fun invoke(cause: Throwable?) = childJob.parentCancelled(job)
    override fun childCancelled(cause: Throwable): Boolean = job.childCancelled(cause)
}

public final override fun parentCancelled(parentJob: ParentJob) {
    cancelImpl(parentJob)
}
```

ChildHandleNode 的 invoke() 方法会调用 parentCancelled() 方法，而它最终会调用 cancelImpl() 方法。

当中的 cancelImpl() 方法，也就是 Job 取消的入口函数。这实际上就相当于在做**递归调用**。



**通知父 Job 的流程**

```kotlin
private fun cancelParent(cause: Throwable): Boolean {
    if (isScopedCoroutine) return true

    val isCancellation = cause is CancellationException
    val parent = parentHandle

    if (parent === null || parent === NonDisposableHandle) {
        return isCancellation
    }
    // 返回 true 代表父协程处理了异常，而返回 false，代表父协程没有处理异常。
    // 类似责任链的设计模式
    return parent.childCancelled(cause) || isCancellation
}
```

```kotlin
public open fun childCancelled(cause: Throwable): Boolean {
    // 当异常是 CancellationException 的时候，协程是会进行特殊处理的。
    if (cause is CancellationException) return true
    // 如果是其他的异常，那么父协程就会响应子协程的取消了。
    // 代码又会继续递归调用 cancelImpl
    return  cancelImpl(cause) && handlesException
}
```





### SupervisorJob原理

SupervisorJob，它可以起到隔离异常传播的作用，原理是什么？

```kotlin
public fun SupervisorJob(parent: Job? = null) : CompletableJob = 
    SupervisorJobImpl(parent)

private class SupervisorJobImpl(parent: Job?) : JobImpl(parent) {
    override fun childCancelled(cause: Throwable): Boolean = false
}
```



SupervisorJob 重写了childCancelled方法，当异常发生，错误在整个树中传递，调用到cancelParent会调用parent.childCancelled，这个时候就会直接返回false而不是调用cancelImpl，错误传递就会终止，父协程不会被cancle掉。执行的路径其实和CancellationException异常类似，区别是cancelParent的返回值。



## 六、Channel

```kotlin
fun main()  {
    val scope = CoroutineScope(Job() + mySingleDispatcher)
    // 1，创建管道
    val channel = Channel<Int>()

    scope.launch {
        // 2，在一个单独的协程当中发送管道消息
        repeat(3)  {
            channel.send(it)
            println("Send: $it")
        }

        channel.close()
    }

    scope.launch {
        // 3，在一个单独的协程当中接收管道消息
        repeat(3) {
            val result = channel.receive()
            println("Receive ${result}")
        }
    }

    println("end")
    Thread.sleep(2000000L)
}

/*
输出结果：
end
Receive 0
Send: 0
Send: 1
Receive 1
Receive 2
Send: 2
*/
```



### Channel 创建流程

```kotlin
public interface Channel<E> : SendChannel<E>, ReceiveChannel<E> {

public fun <E> Channel(
    capacity: Int = RENDEZVOUS,
    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND,
    onUndeliveredElement: ((E) -> Unit)? = null
): Channel<E> =
    when (capacity) {
        RENDEZVOUS -> {
            if (onBufferOverflow == BufferOverflow.SUSPEND)
                RendezvousChannel(onUndeliveredElement) 
            else
                ArrayChannel(1, onBufferOverflow, onUndeliveredElement) 
        }
        CONFLATED -> {
            ConflatedChannel(onUndeliveredElement)
        }
        UNLIMITED -> LinkedListChannel(onUndeliveredElement) 
        BUFFERED -> ArrayChannel( 
            if (onBufferOverflow == BufferOverflow.SUSPEND) CHANNEL_DEFAULT_CAPACITY else 1,
            onBufferOverflow, onUndeliveredElement
        )
        else -> {
            if (capacity == 1 && onBufferOverflow == BufferOverflow.DROP_OLDEST)
                ConflatedChannel(onUndeliveredElement) 
            else
                ArrayChannel(capacity, onBufferOverflow, onUndeliveredElement)
        }
    }
```

RendezvousChannel、ArrayChannel、ConflatedChannel、LinkedListChannel。这些实现类都有一个共同的父类：AbstractChannel。



**AbstractChannel**

```kotlin
internal abstract class AbstractSendChannel<E>(
    @JvmField protected val onUndeliveredElement: OnUndeliveredElement<E>?
) : SendChannel<E> {

    protected val queue = LockFreeLinkedListHead()

    // 省略

    internal abstract class AbstractChannel<E>(
    onUndeliveredElement: OnUndeliveredElement<E>?
) : AbstractSendChannel<E>(onUndeliveredElement), Channel<E> {}
}
```

Channel 的核心逻辑，都是依靠 AbstractSendChannel 当中的 LockFreeLinkedListHead 实现的。



### Channel 的数据结构

**LockFreeLinkedListHead**

LockFreeLinkedListHead 继承自 LockFreeLinkedListNode

```kotlin
public actual open class LockFreeLinkedListHead : LockFreeLinkedListNode() {
    public actual val isEmpty: Boolean get() = next === this
}

public actual open class LockFreeLinkedListNode {
    private val _next = atomic<Any>(this)
    private val _prev = atomic(this)
    private val _removedRef = atomic<Removed?>(null)
}
```



**LockFreeLinkedListNode原理**

LockFreeLinkedListNode，即 LockFree 和 LinkedList。

LockFree：它是通过CAS（Compare And Swap）的思想来实现的

LinkedList：LockFreeLinkedList 是一个**循环双向链表**，而 LockFreeLinkedListHead 其实是一个哨兵节点(虚拟头结点)，这个节点本身不会用于存储任何数据，它的 next 指针会指向整个链表的头节点，而它的 prev 指针会指向整个链表的尾节点。

当链表为空的时候，LockFreeLinkedListHead 的 next 指针和 prev 指针，都是指向自身的。这也就意味着，这个 Head 节点是不会存储数据，同时，也是不会被删除的。

当链表有 2 个元素的时候，这时 LockFreeLinkedListHead 节点的 next 指针才是第一个节点，而 Head 的 prev 指针则是指向尾结点。

Channel 内部的这个数据结构只能在末尾添加，而它遍历的顺序则是从队首开始的。这样的设计，就让它的行为在变成了先进先出单向队列的同时，还实现了队尾添加操作，只需要 O(1) 的时间复杂度。

LockFreeLinkedList 这个数据结构，我们才能使用 Channel 实现 CSP 通信模型。(不要共享内存来通信；而是要用通信来共享内存)



### 发送流程

```kotlin
public final override suspend fun send(element: E) {
    // 两种情况
    // 1.当前的 LockFree 队列当中已经有被挂起的接收方，这时候，send() 会恢复 Receive 节点的执行
    // 2.前队列当中没有被挂起的接收方，这时候 send() 就会被挂起，而被发送的数据会被封装成 SendElement 对象插入到队列的末尾，等待被下次的 receive() 恢复执行。
    
    // 首次调用 send() 的时候，Channel 还不存在消费者，执行到suspendCancellableCoroutine
    // 如果有直接返回
    if (offerInternal(element) === OFFER_SUCCESS) return
    
    // 当中没有被挂起的接收方，这时候 send() 就会被挂起
    return sendSuspend(element)
}

protected open fun offerInternal(element: E): Any {
    while (true) {
        // 首次还没消费者
        val receive = takeFirstReceiveOrPeekClosed() ?: return OFFER_FAILE
        // 省略
    }
}

private suspend fun sendSuspend(element: E): Unit = suspendCancellableCoroutineReusable sc@ { cont ->
    loop@ while (true) {
        if (isFullImpl) {
            // 将发送的元素封装成 SendElement 对象
            val send = if (onUndeliveredElement == null)
                SendElement(element, cont) else
                SendElementWithUndeliveredHandler(element, cont, onUndeliveredElement)
            // 将其添加到 LockFreeLinkedList 这个队列的末尾
            val enqueueResult = enqueueSend(send)
            when {
                enqueueResult == null -> {
                    // enqueueSend() 执行成功,注册一个回调，用于将 SendElement 从队列中移除掉。
                    // 响应取消，真正挂起，等待被恢复
                    cont.removeOnCancellation(send)
                    return@sc
                }
                enqueueResult is Closed<*> -> {
                }
                enqueueResult === ENQUEUE_FAILED -> {} 
                enqueueResult is Receive<*> -> {} 
                else -> error("enqueueSend returned $enqueueResult")
            }
        }
        // 省略
    }
}
```



### 接收流程

```kotlin
public final override suspend fun receive(): E {
    // 两种情况
    // 1.当前的 LockFree 队列当中已经存在被挂起的发送方，这时候 receive() 会恢复 Send 节点的执行，并且取出 Send 节点当中带过来的数据。
    // 2.当前队列没有被挂起的发送方，这时候 receive() 就会被挂起，同时它也会被封装成一个 ReceiveElement 对象插入到队列的末尾，等待被下次的 send() 恢复执行。
    
    // 尝试从 LockFree 队列当中找出是否有正在被挂起的发送方。
    val result = pollInternal()
    
    // 返回取出的SendElement数据
    if (result !== POLL_FAILED && result !is Closed<*>) return result as E
    
    // 当 LockFree 队列当中没有正在挂起的发送方时， receive() 就会被挂起
    return receiveSuspend(RECEIVE_THROWS_ON_CLOSE)
}

protected open fun pollInternal(): Any? {
    while (true) {
        // 从队首开始遍历，寻找 Send 节点。
        val send = takeFirstSendOrPeekClosed() ?: return POLL_FAILED
        val token = send.tryResumeSend(null)
        if (token != null) {
            assert { token === RESUME_TOKEN }
            //最终会调用 dispatch(mode)
            send.completeResumeSend()
            // 返回SendElement当中的元素
            return send.pollResult
        }

        send.undeliveredElement()
    }
}

// CancellableContinuationImpl
private fun dispatchResume(mode: Int) {
    if (tryResume()) return 
    // dispatch(mode) 其实就是 DispatchedTask 的 dispatch()
    dispatch(mode)
}

internal fun <T> DispatchedTask<T>.dispatch(mode: Int) {
    // 省略
    if (!undispatched && delegate is DispatchedContinuation<*> && mode.isCancellableMode == resumeMode.isCancellableMode) {

        val dispatcher = delegate.dispatcher
        val context = delegate.context
        if (dispatcher.isDispatchNeeded(context)) {
            // dispatch() 就是协程体当中的代码在线程执行的时机。最终，它会执行在 Java 的 Executor 之上。
            // 至此，我们之前被挂起的 send() 方法，其实就算是恢复了。
            dispatcher.dispatch(context, this)
        } else {
            resumeUnconfined()
        }
    } else {
        // 省略
    }
}
```



**receiveSuspend**

```kotlin
private suspend fun <R> receiveSuspend(receiveMode: Int): R = suspendCancellableCoroutineReusable sc@ { cont ->
    // 封装一个 ReceiveElement 对象
    val receive = if (onUndeliveredElement == null)
        ReceiveElement(cont as CancellableContinuation<Any?>, receiveMode) else
        ReceiveElementWithUndeliveredHandler(cont as CancellableContinuation<Any?>, receiveMode, onUndeliveredElement)
    while (true) {
        // 将其添加到添加到 LockFree 队列的末尾，等待被下次的 send() 恢复执行。
        if (enqueueReceive(receive)) {
            removeReceiveOnCancel(cont, receive)
            return@sc
        }

        val result = pollInternal()
        if (result is Closed<*>) {
            receive.resumeReceiveClosed(result)
            return@sc
        }
        if (result !== POLL_FAILED) {
            cont.resume(receive.resumeValue(result as E), receive.resumeOnCancellationFun(result as E))
            return@sc
        }
    }
}
```



注意：CSP 场景下的并发模型，并非不可能发生死锁，在一些特殊场景下，它也是可能发生死锁的，比如：通信死锁（Communication Deadlock）。因此，CSP 也并不是解决所有并发问题的万能解药，我们还是要具体问题具体分析。





### LinkedListChannel 的原理

```kotlin

internal open class LinkedListChannel<E>(onUndeliveredElement: OnUndeliveredElement<E>?) : AbstractChannel<E>(onUndeliveredElement) {
    protected final override val isBufferAlwaysEmpty: Boolean get() = true
    protected final override val isBufferEmpty: Boolean get() = true
    protected final override val isBufferAlwaysFull: Boolean get() = false
    protected final override val isBufferFull: Boolean get() = false

    protected override fun offerInternal(element: E): Any {
        while (true) {
            val result = super.offerInternal(element)
            when {
                result === OFFER_SUCCESS -> return OFFER_SUCCESS
                result === OFFER_FAILED -> { // try to buffer
                    when (val sendResult = sendBuffered(element)) {
                        null -> return OFFER_SUCCESS
                        is Closed<*> -> return sendResult
                    }
                    // otherwise there was receiver in queue, retry super.offerInternal
                }
                result is Closed<*> -> return result
                else -> error("Invalid offerInternal result $result")
            }
        }
    }

    protected override fun offerSelectInternal(element: E, select: SelectInstance<*>): Any {
        while (true) {
            val result = if (hasReceiveOrClosed)
                super.offerSelectInternal(element, select) else
                (select.performAtomicTrySelect(describeSendBuffered(element)) ?: OFFER_SUCCESS)
            when {
                result === ALREADY_SELECTED -> return ALREADY_SELECTED
                result === OFFER_SUCCESS -> return OFFER_SUCCESS
                result === OFFER_FAILED -> {} // retry
                result === RETRY_ATOMIC -> {} // retry
                result is Closed<*> -> return result
                else -> error("Invalid result $result")
            }
        }
    }
}
```



LinkedListChannel.offerInternal调用AbstractSendChannel.offerInternal 失败的时候，会把发送的内容持续放到队列中，这样即使接受方没准备好或者不存在，发送方也不会等待，而持续进入可以接收数据并发送的状态。

LinkedListChannel.offerSelectInternal调用AbstractSendChannel.offerSelectInternal失败的时候，还是会继续尝试调用这个方法，因为LinkedListChannel只要内存允许，会时刻处于接受数据的状态。



## 七、Follow

```kotlin
fun main() {
    val scope = CoroutineScope(Job())
    scope.launch {
        testFlow()
    }

    Thread.sleep(1000L)

    logX("end")
}

private suspend fun testFlow() {
    // 1
    flow {
        emit(1)
        emit(2)
        emit(3)
        emit(4)
        emit(5)
    }.collect {      // 2
            logX(it)
        }
}

/**
 * 控制台输出带协程信息的log
 */
fun logX(any: Any?) {
    println(
        """
================================
$any
Thread:${Thread.currentThread().name}
================================""".trimIndent()
    )
}

/*
输出结果
================================
1
Thread:DefaultDispatcher-worker-1
================================
================================
2
Thread:DefaultDispatcher-worker-1
================================
================================
3
Thread:DefaultDispatcher-worker-1
================================
================================
4
Thread:DefaultDispatcher-worker-1
================================
================================
5
Thread:DefaultDispatcher-worker-1
================================
================================
end
Thread:main
================================
*/
```



### 创建流程

```kotlin
public fun <T> flow(block: suspend FlowCollector<T>.() -> Unit): Flow<T> = SafeFlow(block)

public interface Flow<out T> {
    public suspend fun collect(collector: FlowCollector<T>)
}
```



**SafeFlow源码**

```kotlin
private class SafeFlow<T>(private val block: suspend FlowCollector<T>.() -> Unit) : AbstractFlow<T>() {
    
    override suspend fun collectSafely(collector: FlowCollector<T>) {
        // 相当于触发了 flow{} 当中的 Lambda 逻辑
        collector.block()
    }
}

public abstract class AbstractFlow<T> : Flow<T>, CancellableFlow<T> {
    // 省略
}

internal interface CancellableFlow<out T> : Flow<T>
```

SafeFlow 是 AbstractFlow 的子类，而 AbstractFlow 则实现了 Flow 这个接口，所以 SafeFlow 算是间接实现了 Flow 接口。

而 AbstractFlow 是协程当中所有 Flow 的抽象类，所以，它当中应该会有许多 Flow 通用的逻辑。





collector.block()为什么是触发了 flow{} 当中的 Lambda 逻辑

flow{} 是一个高阶函数，它接收的参数类型是函数类型FlowCollector.() -> Unit，这个类型代表了：它是 FlowCollector 的扩展或成员方法，没有参数，也没有返回值。





### collect终止操作符

**AbstractFlow源码**

```kotlin
public abstract class AbstractFlow<T> : Flow<T>, CancellableFlow<T> {

    // 终止操作符 collect
    public final override suspend fun collect(collector: FlowCollector<T>) {
        // 封装成 SafeColletor对象。
        val safeCollector = SafeCollector(collector, coroutineContext)
        try {
            // 具体实现就在 SafeFlow 的 collectSafely() 方法，调用了 collector.block()
            collectSafely(safeCollector)
        } finally {
            safeCollector.releaseIntercepted()
        }
    }

    public abstract suspend fun collectSafely(collector: FlowCollector<T>)
}
```

FLow 之所以是冷的，是因为 Flow 的构造器，真的就只会构造一个 SafeFlow 对象，完全不会触发执行它内部的 Lambda 表达式的逻辑，

只有当 collect() 被调用之后，flow{} 当中的 Lambda 逻辑才会真正被触发执行。



### FlowCollector：上游与下游之间的桥梁

上面整个流程分析下来：下游的 collect() 会触发上游的 Lambda 执行，上游的 Lambda 当中的 emit() 会把数据传递给下游。

collect() 方法传入的 FlowCollector 参数，其实是被传入 SafeCollector 当中，被封装了起来。



```kotlin
private suspend fun testFlow() {

    flow {
        // 1
        emit(1)
        emit(2)
        emit(3)
        emit(4)
        emit(5)
    }
        // 变化在这里
        .collect(object : FlowCollector<Int>{ 
            // 2
            override suspend fun emit(value: Int) {
                logX(value)
            }
        })
}
```





**SafeCollector**

```kotlin
internal actual class SafeCollector<T> actual constructor(
    // collector，它是 SafeCollector 的参数, 对应的是 flow{} 当中的 Lambda
    @JvmField internal actual val collector: FlowCollector<T>,
    @JvmField internal actual val collectContext: CoroutineContext
) : FlowCollector<T>, ContinuationImpl(NoOpContinuation, EmptyCoroutineContext), CoroutineStackFrame {

    internal actual val collectContextSize = collectContext.fold(0) { count, _ -> count + 1 }
    private var lastEmissionContext: CoroutineContext? = null
    private var completion: Continuation<Unit>? = null

    // ContinuationImpl
    override val context: CoroutineContext
        get() = completion?.context ?: EmptyCoroutineContext

    // Flow 上游发送的数据，最终会传递到这个 emit() 方法当中来。我们可以将其看作上游的 emit()。
    override suspend fun emit(value: T) {
        return suspendCoroutineUninterceptedOrReturn sc@{ uCont ->
            try {
                // 这里的 suspendCoroutineUninterceptedOrReturn 这个高阶函数，是把挂起函数的 Continuation 暴露了出来，并且将其作为参数传递给了另一个 emit() 方法。
                // 这行代码被 try-catch 包裹了，而且把其中的异常捕获以后，会被重新包装成 DownstreamExceptionElement，意思就是“下游的异常”，这从侧面也能说明，这个方法即将执行下游的代码。
                emit(uCont, value)
            } catch (e: Throwable) {
                // DownstreamExceptionElement 会被存储在 lastEmissionContext 当中，它的作用是：在下游发送异常以后，可以让上游感知到。
                lastEmissionContext = DownstreamExceptionElement(e)
                throw e
            }
        }
    }

    private fun emit(uCont: Continuation<Unit>, value: T): Any? {
        val currentContext = uCont.context
        currentContext.ensureActive()

        // 这里会对当前的协程上下文与之前的协程上下文做对比检查，如果它们两者不一致，就会在 checkContext() 当中做进一步的判断和提示。
        val previousContext = lastEmissionContext
        if (previousContext !== currentContext) {
            checkContext(currentContext, previousContext, value)
        }
        completion = uCont
        // 这里其实就是在调用下游的 emit()，对应的 value 也是这时候传进去的。
        return emitFun(collector as FlowCollector<Any?>, value, this as Continuation<Unit>)
    }

}

// emitFun 定义，类型是Function3<FlowCollector<Any?>, Any?, Continuation<Unit>, Any?>
private val emitFun =
    FlowCollector<Any?>::emit as Function3<FlowCollector<Any?>, Any?, Continuation<Unit>, Any?>

public interface Function3<in P1, in P2, in P3, out R> : Function<R> {
    public operator fun invoke(p1: P1, p2: P2, p3: P3): R
}
```



### 推演：中间操作符

#### Flow 的思维模型

flow{} 这个高阶函数，代表了上游，它会创建一个 Flow 对象，提供给下游调用 Flow 的 collect 方法。

flow{} 实际上返回的是 SafeFlow 对象，在这个 SafeFlow 当中，会有一个 SafeCollector 对象。而整个 Flow 的调用过程，其实就是三个步骤：

第一步，上游的 flow{} 创建 SafeFlow 的对象，下游调用 Flow 的 collect() 方法，触发 flow{} 的 Lambda 对应的代码执行，也就是其中 emit() 被执行。

第二步，上游调用的 emit()，其实就是 SafeCollector 的 emit()，这时候，就相当于上游将数据传递给 SafeCollector。

第三步，SafeCollector 调用 emitFun()，这里的 emitFun() 其实就对应了下游的 emit() 方法。



#### Flow 中间操作符的源代码

```kotlin
// 1
inline fun <T> Flow<T>.filter(
    crossinline predicate: suspend (T) -> Boolean
): Flow<T> = transform { value ->
    // 8
	// if (predicate(value))，这其实就是我们 filter 的条件，只有符合这个条件的情况下，我们才会继续向下游传递数据，
	// 而传递的方式，就是调用 emit()，这里的 emit() 其实就代表了下游会接收到数据了。
    if (predicate(value)) return@transform emit(value)
}

// 2
internal inline fun <T, R> Flow<T>.unsafeTransform(
    crossinline transform: suspend FlowCollector<R>.(value: T) -> Unit
): Flow<R> = unsafeFlow { 
    
    // 6
    // collect{}，这里是在调用上游 Flow 的 collect{}，触发上游的 Lambda 执行了，也就是flow{}.filter{}.collect{}里的 flow{} 当中的 Lambda
    collect { value ->
        // 7
        // 这里 transform(value) 当中的 value，其实就是上游传递下来的数据
        // transform{} 当中具体的逻辑，就是注释 8。
        return@collect transform(value)
    }
}

// 3
internal inline fun <T> unsafeFlow(
    crossinline block: suspend FlowCollector<T>.() -> Unit
): Flow<T> {
    // 4
    return object : Flow<T> {
        // 5
        // 对于flow{}.filter{}.collect{}这样的代码，最终的 collect{} 调用的代码，其实对应的此处 collect() 方法
        override suspend fun collect(collector: FlowCollector<T>) {
            // collector.block()，这其实就代表了注释 6、7 会执行。
            collector.block()
        }
    }
}
```



### 上下文保护

Flow 当中直接使用 withContext{} 是很容易出现问题

```kotlin
fun main() = runBlocking {
    flow {
        withContext(Dispatchers.IO) {
            emit(1)
        }
    }.map { it * 2 }
        .collect()
}

/*
输出结果：

Exception in thread "main" java.lang.IllegalStateException: Flow invariant is violated:
        Flow was collected in [BlockingCoroutine{Active}@6e58a46, BlockingEventLoop@2cbfb24],
        but emission happened in [DispatchedCoroutine{Active}@500da3c0, Dispatchers.IO].
        Please refer to 'flow' documentation or use 'flowOn' instead
*/
```

Flow 构建器、Flow 中间操作符，它们两个是不需要协程作用域的，只有 Flow 终止操作符需要协程作用域。

在默认情况下，Flow 下游的“协程上下文”最终会成为上游的执行环境，也会变成中间操作符的执行环境。也正是这个原因，才让 Flow 可以天然支持协程的“结构化并发”的特性，比如说结构化取消。

如果 Kotlin 官方允许开发者在 flow{} 当中，调用 withContext{} 改变协程上下文的话，Flow 上游与下游的协程上下文就会不一致，它们整体的结构也会被破坏，从而导致“结构化并发”的特性也被破坏。



**Flow 源码中对于上下文的检测**

```kotlin
private fun emit(uCont: Continuation<Unit>, value: T): Any? {
    // 省略
    // This check is triggered once per flow on happy path.
    val previousContext = lastEmissionContext
    if (previousContext !== currentContext) {
        checkContext(currentContext, previousContext, value)
    }
}

private fun checkContext(
    currentContext: CoroutineContext,
    previousContext: CoroutineContext?,
    value: T
) {
    if (previousContext is DownstreamExceptionElement) {
        exceptionTransparencyViolated(previousContext, value)
    }
    checkContext(currentContext)
    lastEmissionContext = currentContext
}

internal fun SafeCollector<*>.checkContext(currentContext: CoroutineContext) {
    val result = currentContext.fold(0) fold@{ count, element ->
        val key = element.key
        val collectElement = collectContext[key]
        if (key !== Job) {
            return@fold if (element !== collectElement) Int.MIN_VALUE
            else count + 1
        }

        val collectJob = collectElement as Job?
        val emissionParentJob = (element as Job).transitiveCoroutineParent(collectJob)

        if (emissionParentJob !== collectJob) {
            error(
                "Flow invariant is violated:\n" +
                        "\t\tEmission from another coroutine is detected.\n" +
                        "\t\tChild of $emissionParentJob, expected child of $collectJob.\n" +
                        "\t\tFlowCollector is not thread-safe and concurrent emissions are prohibited.\n" +
                        "\t\tTo mitigate this restriction please use 'channelFlow' builder instead of 'flow'"
            )
        }


        if (collectJob == null) count else count + 1
    }

    // 判断上游、下游的Context
    if (result != collectContextSize) {
        error(
            "Flow invariant is violated:\n" +
                    "\t\tFlow was collected in $collectContext,\n" +
                    "\t\tbut emission happened in $currentContext.\n" +
                    "\t\tPlease refer to 'flow' documentation or use 'flowOn' instead"
        )
    }
}
```

所以，总的来说，Flow 不允许直接使用 withContext{} 的原因，是为了“结构化并发”，它并不是不允许切换线程，而是不允许随意破坏协程的上下文。Kotlin 提供的操作符 flowOn{}，官方已经帮我们处理好了上下文的问题，所以我们可以放心地切线程。





**Flow、FlowCollector 这两个抽象的接口之间的内在联系吗？**

Flow 接口引用了FlowCollector接口，并封装了一段调用逻辑，作为将来FlowCollector使用的来源。FlowCollector，带有emit函数的接口，统一了上游的发送方的数据输出和下游接收方的数据输入。FlowCollector的做法和通常扩展函数不太一样，通常的扩展函数是先有核心类，然后扩展函数扩充核心类的功能。FlowCollector是先在上游的构造器里构建了高阶的扩展函数，然后在下游collect里实现了带有emit的核心类。下游collect触发流程，然后上游的emit驱动下游的emit。这么设计原因应该是上游的构造器，相对复杂，而且是推迟执行的，需要给开发人员以足够的灵活性，所以采用了扩展函数的格式，下游接受数据相对固定，而且是同步执行的，采用固定的FlowCollector接口。
