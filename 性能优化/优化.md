# 优化

## 名词解释

- VSS - Virtual Set Size 虚拟耗用内存
- RSS - Resident Set Size 实际使用物理内存（USS + 共享库占用的内存 + 进程占用的共享内存 ）
- PSS - Proportional Set Size 实际使用的物理内存（USS + 进程占用的共享内存）
- USS - Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）

一般来说内存占用大小有如下规律：VSS >= RSS >= PSS >= USS



PV(访问量)：即Page View, 即页面浏览量或点击量，用户每次刷新即被计算一次。

UV(独立访客)：即Unique Visitor,访问您网站的一台电脑客户端为一个访客。00:00-24:00内相同的客户端只被计算一次。



utime：用户时间，反应用户代码执行的耗时

stime：系统时间，反应用户代码执行的耗时

majorFaults：需要硬盘拷贝的缺页次数 

minorFaults：无需硬盘拷贝的缺页次数

nicetime：nice 值越低，抢占 CPU 时间片的能力越强

irq：硬中断时间

softirq：软中断时间

任务状态：

- R:runnign,
- S:sleeping (`TASK_INTERRUPTIBLE`), 
- D:disk sleep (`TASK_UNINTERRUPTIBLE`),
- T: stopped, T:tracing stop, 
- Z:zombie, 
- X:dead。



iowait:系统因为io导致的进程wait。再深一点讲就是：这时候系统在做io，导致没有进程在干活，cpu在执行idle进程空转，所以说iowait的产生要满足两个条件，一是进程在等io，二是等io时没有进程可运行。



## 崩溃优化

### Native 崩溃的捕获流程

- 编译端。编译 C/C++ 代码时，需要将带符号信息的文件保留下来。
- 客户端。捕获到崩溃时候，将收集到尽可能多的有用信息写入日志文件，然后选择合适的时机上传到服务器。
- 服务端。读取客户端上报的日志文件，寻找适合的符号文件，生成可读的 C/C++ 调用栈。

### Native 崩溃捕获的难点

情况一：文件句柄泄漏，导致创建日志文件失败，怎么办？

应对方式：我们需要提前申请文件句柄 fd 预留，防止出现这种情况。

情况二：因为栈溢出了，导致日志生成失败，怎么办？

应对方式：为了防止栈溢出导致进程没有空间创建调用栈执行处理函数，我们通常会使用常见的 signalstack。在一些特殊情况，我们可能还需要直接替换当前栈，所以这里也需要在堆中预留部分空间。

情况三：整个堆的内存都耗尽了，导致日志生成失败，怎么办？

应对方式：这个时候我们无法安全地分配内存，也不敢使用 stl 或者 libc 的函数，因为它们内部实现会分配堆内存。这个时候如果继续分配内存，会导致出现堆破坏或者二次崩溃的情况。Breakpad 做的比较彻底，重新封装了[Linux Syscall Support](https://chromium.googlesource.com/linux-syscall-support/)，来避免直接调用 libc。

情况四：堆破坏或二次崩溃导致日志生成失败，怎么办？

应对方式：Breakpad 会从原进程 fork 出子进程去收集崩溃现场，此外涉及与 Java 相关的，一般也会用子进程去操作。这样即使出现二次崩溃，只是这部分的信息丢失，我们的父进程后面还可以继续获取其他的信息。在一些特殊的情况，我们还可能需要从子进程 fork 出孙进程。

### UV 崩溃率

```
UV 崩溃率 = 发生崩溃的 UV / 登录 UV
```



### 安全模式

指启动失败后自救

如何判断异常退出：

- APP启动时记录一个flag值

- 满足以下条件时，将flag值清空：

- - APP正常启动10秒
  - 用户正常退出应用
  - 用户主动从前台切换到后台

- 如果在启动阶段发生异常，则flag值不会清空，通过flag值就可以判断出客户端是否异常退出

- 每次异常退出，flag值都会+1

 

### 如何发现应用中的 ANR

1. 使用 FileObserver 监听 /data/anr/traces.txt 的变化

   (很多高版本的 ROM，已经没有读取这个文件的权限了)

2. 监控消息队列的运行时间

   这个方案无法准确地判断是否真正出现了 ANR 异常，也无法得到完整的 ANR 日志。

​	

应用退出的情形

- 主动自杀。Process.killProcess()、exit() 等。
- 崩溃。出现了 Java 或 Native 崩溃。
- 系统重启；系统出现异常、断电、用户主动重启等，我们可以通过比较应用开机运行时间是否比之前记录的值更小。
- 被系统杀死。被 low memory killer 杀掉、从系统的任务管理器中划掉等。
- ANR。



设置一个标注，用户自杀或崩溃后更新标志，下次启动检测标志，就能排除掉自杀或崩溃这两种场景。

PS：当然异常率会存在一些误报，比如用户从系统的任务管理器中划掉应用。





### 系统信息 

查询系统的 event logcat(会记录 App 运行的一些基本情况)

```
/system/etc/event-log-tags 
```

```
system logcat:
10-25 17:13:47.788 21430 21430 D dalvikvm: Trying to load lib ... 
event logcat:
10-25 17:13:47.788 21430 21430 I am_on_resume_called: 生命周期
10-25 17:13:47.788 21430 21430 I am_low_memory: 系统内存不足
10-25 17:13:47.788 21430 21430 I am_destroy_activity: 销毁 Activty
10-25 17:13:47.888 21430 21430 I am_anr: ANR 以及原因
10-25 17:13:47.888 21430 21430 I am_kill: APP 被杀以及原因
```

### 内存信息

#### 查询系统内存状态

```
/proc/meminfo


MemTotal:    2866492 kB
MemFree:      72192 kB
Buffers:      62708 kB      // Buffer Cache
Cached:      652904 kB      // Page Cache
```

#### 查询应用使用内存

```
/proc/self/smap
```

#### 查询虚拟内存

```
/proc/self/status
```

#### 查询虚拟内存具体分布情况

```
/proc/self/maps
```

```
Name:     com.sample.name   // 进程名
FDSize:   800               // 当前进程申请的文件句柄个数
VmPeak:   3004628 kB        // 当前进程的虚拟内存峰值大小
VmSize:   2997032 kB        // 当前进程的虚拟内存大小
Threads:  600               // 当前进程包含的线程个数
```

### 资源信息

#### 查询文件句柄的限制

单进程限制一般是1024，超过800就比较危险

```
/proc/self/limits
```

#### 查询线程数

一个线程可能就占 2MB,超过 400 个就比较危险。

```
/proc/self/status
```

#### 统计 JNI 的引用表

通过 DumpReferenceTables 统计 JNI 的引用表，分析是否出现了 JNI 泄漏等问题(引用失效、引用爆表等一些崩溃)



### 获取logcat

logcat日志流程是这样的，应用层 --> liblog.so --> logd，底层使用ring buffer来存储数据。 

获取的方式有以下三种：  

1. 通过logcat命令获取。  

   优点：非常简单，兼容性好。  

   缺点：整个链路比较长，可控性差，失败率高，特别是堆破坏或者堆内存不足时，基本会失败。  

2. hook liblog.so实现。通过hook liblog.so 中__android_log_buf_write 方法，将内容重定向到自己的buffer中。   

   优点：简单，兼容性相对还好。  

   缺点：要一直打开。   

3. 自定义获取代码。通过移植底层获取logcat的实现，通过socket直接跟logd交互。  

   优点：比较灵活，预先分配好资源，成功率也比较高。   

   缺点：实现非常复杂

### 获取Java 堆栈

native崩溃时，通过unwind只能拿到Native堆栈。我们希望可以拿到当时各个线程的Java堆栈   

1. Thread.getAllStackTraces()。    

   优点：简单，兼容性好。   

   缺点：        

   ​	a. 成功率不高，依靠系统接口在极端情况也会失败。       

   ​	b. 7.0之后这个接口是没有主线程堆栈。        

   ​	c. 使用Java层的接口需要暂停线程   

2. hook libart.so。通过hook ThreadList和Thread的函数，获得跟ANR一样的堆栈。为了稳定性，我们会在fork子进程执行。   

   优点：信息很全，基本跟ANR的日志一样，有native线程状态，锁信息等等。   

   缺点：黑科技的兼容性问题，失败时可以用Thread.getAllStackTraces()兜底





### 相关资料

[Android 平台 Native 代码的崩溃捕获机制及实现](https://mp.weixin.qq.com/s/g-WzYF3wWAljok1XjPoo7w)

[使用GDB调试](https://www.chromium.org/chromium-os/packages/crash-reporting/debugging-a-minidump/)

[安全模式](https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247488429&idx=1&sn=448b414a0424d06855359b3eb2ba8569&source=41#wechat_redirect)

[崩溃信号介绍](http://www.mkssoftware.com/docs/man5/siginfo_t.5.asp)

[滴滴出行安卓端 finalize time out 的解决方案](https://www.infoq.cn/article/NxlcJikbFaoTeACHxMQk)

[breakpad](https://github.com/google/breakpad)

[使用 GDB 来根据 Minidump 调试出问题的动态库](https://www.chromium.org/chromium-os/packages/crash-reporting/debugging-a-minidump/)



## 内存优化

### 内存造成的问题

1.异常(OOM)

2.卡顿(GC)

VSS、PSS、Java 堆内存不足都可能会引起异常和卡顿

当系统物理内存不足时，lmk 开始杀进程，从后台、桌面、服务、前台，直到手机重启。





### 如何将图片放到 Native 内存中。

步骤一：通过直接调用 libandroid_runtime.so 中 Bitmap 的构造函数，可以得到一张空的 Bitmap 对象，而它的内存是放到 Native 堆中。但是不同 Android 版本的实现有那么一点差异，这里都需要适配。

步骤二：通过系统的方法创建一张普通的 Java Bitmap。

步骤三：将 Java Bitmap 的内容绘制到之前申请的空的 Native Bitmap 中。

步骤四：将申请的 Java Bitmap 释放，实现图片内存的“偷龙转凤”。

```java
// 步骤一：申请一张空的 Native Bitmap
Bitmap nativeBitmap = nativeCreateBitmap(dstWidth, dstHeight, nativeConfig, 22);

// 步骤二：申请一张普通的 Java Bitmap
Bitmap srcBitmap = BitmapFactory.decodeResource(res, id);

// 步骤三：使用 Java Bitmap 将内容绘制到 Native Bitmap 中
mNativeCanvas.setBitmap(nativeBitmap);
mNativeCanvas.drawBitmap(srcBitmap, mSrcRect, mDstRect, mPaint);

// 步骤四：释放 Java Bitmap 内存
srcBitmap.recycle();
srcBitmap = null；
```

这个“黑科技”有两个主要问题，一个是兼容性问题，另外一个是频繁申请释放 Java Bitmap 容易导致内存抖动。





### 测量系统内存和应用内存的使用情况

```
adb shell dumpsys meminfo <package_name|pid> [-d]
```

https://developer.android.com/studio/profile/memory-profiler?hl=zh-cn



### Android profiler/Allocation Trakcer/TraceView 缺点

目前最新的是Android profiler，另外2个是旧版本的

缺点:

1. 获取的信息过于分散，中间夹杂着不少其他的信息，不完全是app申请的，可能需要进行不少查找才能定位到具体的问题
2. 跟TraceView一样，无法做到自动化分析，每次都需要开发者手工开始/结束，对于某些问题的分析可能会造成不便，而且对于批量分析来说也比较困难
3. 虽然在allocation tracking的时候，不会对手机本身的运行造成过多的性能影响，然而在停止allocation tracker的时候，直到把数据dump出来之前，会把手机完全卡死，时间过长甚至会直接ANR





### Allocation Tacker 的开启方式。

```
// dalvik
bool dvmEnableAllocTracker()
// art
void setAllocTrackingEnabled()
```



### 自定义的 Allocation Tracker

实现自动化的内存分析，有哪些对象占用了大量内存，以及它们是如何导致 GC 等。

#### hook

```java
//methods for art
//force dlopen 需要等待 env 构造完成
//static __attribute__((__constructor__))
void hookFunc() {
    LOGI("start hookFunc");
    void *handle = ndk_dlopen("libart.so", RTLD_LAZY | RTLD_GLOBAL);

    if (!handle) {
        LOGE("libart.so open fail");
        return;
    }
    void *hookRecordAllocation26 = ndk_dlsym(handle,"_ZN3art2gc20AllocRecordObjectMap16RecordAllocationEPNS_6ThreadEPNS_6ObjPtrINS_6mirror6ObjectEEEj");

    void *hookRecordAllocation24 = ndk_dlsym(handle,"_ZN3art2gc20AllocRecordObjectMap16RecordAllocationEPNS_6ThreadEPPNS_6mirror6ObjectEj");

    void *hookRecordAllocation23 = ndk_dlsym(handle, "_ZN3art3Dbg16RecordAllocationEPNS_6ThreadEPNS_6mirror5ClassEj");

    void *hookRecordAllocation22 = ndk_dlsym(handle, "_ZN3art3Dbg16RecordAllocationEPNS_6mirror5ClassEj");

    //此处说明一下26和24版本需要使用 hookzz 的原因。
    //hookzz 框架有个优势是可以获取方法进入时候的寄存器内容，而很多时候我们要根据r0来获取 this
    if (hookRecordAllocation26 != nullptr) {
        LOGI("Finish get symbol26");
//        ZzWrap((void *) hookRecordAllocation26, beforeRecordAllocation, nullptr);
        MSHookFunction(hookRecordAllocation26, (void *) &newArtRecordAllocation26,
                       (void **) &oldArtRecordAllocation26);

    } else if (hookRecordAllocation24 != nullptr) {
        LOGI("Finish get symbol24");
//        ZzWrap((void *) hookRecordAllocation24, beforeRecordAllocation, nullptr);
        MSHookFunction(hookRecordAllocation26, (void *) &newArtRecordAllocation26,
                       (void **) &oldArtRecordAllocation26);

    } else if (hookRecordAllocation23 != NULL) {
        LOGI("Finish get symbol23");
        MSHookFunction(hookRecordAllocation23, (void *) &newArtRecordAllocation23,
                       (void **) &oldArtRecordAllocation23);
    } else {
        LOGI("Finish get symbol22");
        if (hookRecordAllocation22 == NULL) {
            LOGI("error find hookRecordAllocation22");
            return;
        } else {
            MSHookFunction(hookRecordAllocation22, (void *) &newArtRecordAllocation22,
                           (void **) &oldArtRecordAllocation22);
        }
    }
    dlclose(handle);
}

```



```c++
static void (*oldArtRecordAllocation26)(void *_this, Thread *, void *obj, size_t);
static void newArtRecordAllocation26(void *_this, Thread *self, void *obj, size_t byte_count) {
    if (needStopRecord) {
        return;
    } else {
        int objptr = Read4(reinterpret_cast<uintptr_t>(obj));//此处获取的其实是一个 ref 对象
        int classRef = Read4(objptr);//根据 ref 获取真实的对象地址
        newArtRecordAllocationDoing24(_this, reinterpret_cast<Class *>(classRef), byte_count);
        oldArtRecordAllocation26(_this, self, obj, byte_count);
    }
}
```



```c++
/**
 * 24以上版本和以下版本上由于 alloc list 的结构不同导致调用方式也不同
 * @param _this
 * @param type
 * @param byte_count
 * @return
 */
static bool newArtRecordAllocationDoing24(void *_this, Class *type, size_t byte_count) {

    if (artAllocMapClear == nullptr) {//如果无法主动 clear 对象，那么下面的逻辑会导致 dump 下来的对象重复
        return false;
    }

    allocObjectCount++;

    char *typeName = GetDescriptor(type, &a);
//    LOGI("=====class name:%s,allocbyte:%d", typeName,byte_count);// 如果只关心分配的对象大小的话，可以不用做alloc dump 的操作
    //达到 max
    int randret = randomInt(0, 100);
    if (randret == LUCKY) {
        LOGI("====current alloc count %d=====", allocObjectCount.load());
        return false;
    }
//    int artAllocMax = getARTAllocRecordMax();
    if (allocObjectCount > setAllocRecordMax) {
        CMyLock lock(g_Lock);
        allocObjectCount = 0;

        //write alloc data to file
        jbyteArray allocData = getARTAllocationData();
        SaveAllocationData saveData{allocData};
        saveARTAllocationData(saveData);
        //TODO:clear alloc data
        if (artAllocMapClear != nullptr) {
            artAllocMapClear(_this);
            LOGI("===========CLEAR ALLOC MAPS=============");
        }

        lock.Unlock();
    }
    return true;
}
```



```c++
/**
 * 基本art 都适配 生成的 byte array 格式如下
 * Message header (all values big-endian):
 * (1b) message header len (to allow future expansion); includes itself
 * (1b) entry header len
 * (1b) stack frame len
 * (2b) number of entries
 * (4b) offset to string table from start of message
 * (2b) number of class name strings
 * (2b) number of method name strings
 * (2b) number of source file name strings
 * For each entry:
 *   (4b) total allocation size
 *   (2b) thread id
 *   (2b) allocated object's class name index
 *   (1b) stack depth
 *   For each stack frame:
 *     (2b) method's class name
 *     (2b) method name
 *     (2b) method source file
 *     (2b) line number, clipped to 32767; -2 if native; -1 if no source
 * (xb) class name strings
 * (xb) method name strings
 * (xb) source file strings
 */
jbyteArray getARTAllocationData() {
    if (artGetRecentAllocations != NULL) {

        jbyteArray data = artGetRecentAllocations();
        LOGI("artGetRecentAllocations finished");
        if (data != NULL) {
            LOGI("artGetRecentAllocations success");
            return data;
        } else {
            LOGI("artGetRecentAllocations failed");
        }
    }
    return NULL;
}
```

转储到本地文件夹

```cpp
bool saveARTAllocationData(SaveAllocationData saveData) {
    JNIEnv *env = facebook::jni::Environment::current();
    {
        snprintf(saveData.dataFileName, 1024, "%s/%d", storeDataDirectory,
                 static_cast<int>(time(0)));
        int fd = open(saveData.dataFileName, O_RDWR | O_CREAT | O_CLOEXEC, (mode_t) 0644);
        lseek(fd, 0, SEEK_SET);
        LOGI("saveARTAllocationData %s file, fd: %d", saveData.dataFileName, fd);
        size_t dataSize = env->GetArrayLength(saveData.data);
        jbyte *olddata = (jbyte *) env->GetByteArrayElements(saveData.data, 0);
        write(fd, olddata, dataSize);
        close(fd);
        LOGI("saveARTAllocationData write file to %s", saveData.dataFileName);
    }
    return true;
}
```



#### 初始化

initForArt

```c++
libHandle = ndk_dlopen("libart.so", RTLD_LOCAL);
artDbgDumpRecentAllocations = (void (*)()) (ndk_dlsym(libHandle,"_ZN3art3Dbg21DumpRecentAllocationsEv"));
//根据 class 获取类名
GetDescriptor = (char *(*)(Class *, std::string *)) ndk_dlsym(libHandle, "_ZN3art6mirror5Class13GetDescriptorEPNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEE");
    
//开启 alloc tracking 开启成功后才能执行后续操作
artSetAllocTrackingEnable = (void (*)(bool)) ndk_dlsym(libHandle, "_ZN3art3Dbg23SetAllocTrackingEnabledEb");

//重要方法，dump alloc 里的对象转换成 byte 数据
artGetRecentAllocations = (jbyteArray(*)()) ndk_dlsym(libHandle, "_ZN3art3Dbg20GetRecentAllocationsEv");

//清理 alloc 中已存在的对象
artAllocMapClear = (bool (*)(void *)) (ndk_dlsym(libHandle, "_ZN3art2gc20AllocRecordObjectMap5ClearEv"));
```

initForDvm

```c++
libHandle = ndk_dlopen("libdvm.so", RTLD_LAZY);
dvmEnableAllocTracker = (void (*)()) dlsym(libHandle, "_Z21dvmEnableAllocTrackerv");
dvmDisableAllocTracker = (void (*)()) dlsym(libHandle, "_Z22dvmDisableAllocTrackerv");
dvmGenerateTrackedAllocationReport = (bool (*)(u1 **, size_t *)) dlsym(libHandle,"_Z34dvmGenerateTrackedAllocationReportPPhPj");
dvmDumpTrackedAllocations = (void (*)(bool)) dlsym(libHandle, "_Z25dvmDumpTrackedAllocationsb");
```

#### 开始记录/停止记录

art

```c++
artSetAllocTrackingEnable(true);
artSetAllocTrackingEnable(false);
```

dvm

```c++
dvmEnableAllocTracker();
dvmDisableAllocTracker();
```

#### dump日志

art

```c++
artDbgDumpRecentAllocations();
```

dvm

```c++
dvmDumpTrackedAllocations(false);
```





### 内存泄漏

#### java 内存泄漏

生成的 Hprof 内存快照文件做一些优化，裁剪大部分图片对应的 byte 数组减少文件大小

比如一个 100MB 的文件裁剪后一般只剩下 30MB 左右，使用 7zip 压缩最后小于 10MB，增加了文件上传的成功率。

#### OOM 监控

美团内存泄露自动化链路分析组件Probe,在发生 OOM 的时候生成 Hprof 内存快照，然后通过单独进程对这个文件做进一步的分析

缺点：在崩溃的时候生成内存快照有可能会导致二次崩溃，而且部分手机生成 Hprof 快照可能会耗时几分钟，这对用户造成的体验影响会比较大。另外，部分 OOM 是因为虚拟内存不足导致，这块需要具体问题具体分析。

#### Native 内存泄漏监控

Malloc 调试和Malloc 钩子

**针对无法重编 so 的情况**，使用了 PLT Hook 拦截库的内存分配函数，其中 PLT Hook 是 Native Hook 的一种方案，后面我们还会讲到。然后重定向到我们自己的实现后记录分配的内存地址、大小、来源 so 库路径等信息，定期扫描分配与释放是否配对，对于不配对的分配输出我们记录的信息。

**针对可重编的 so 情况**，通过 GCC 的“-finstrument-functions”参数给所有函数插桩，桩中模拟调用栈入栈出栈操作；通过 ld 的“–wrap”参数拦截内存分配和释放函数，重定向到我们自己的实现后记录分配的内存地址、大小、来源 so 以及插桩记录的调用栈此刻的内容，定期扫描分配与释放是否配对，对于不配对的分配输出我们记录的信息。



### 内存监控

#### 采集方式

用户在前台的时候，可以每 5 分钟采集一次 PSS、Java 堆、图片总内存。

#### 计算指标

内存异常率：可以反映内存占用的异常情况，如果出现新的内存使用不当或内存泄漏的场景，这个指标会有所上涨。其中 PSS 的值可以通过 Debug.MemoryInfo 拿到。

```
内存 UV 异常率 = PSS 超过 400MB 的 UV / 采集 UV
```

触顶率：可以反映 Java 内存的使用情况，如果超过 85% 最大堆限制，GC 会变得更加频繁，容易造成 OOM 和卡顿。

```
内存 UV 触顶率 = Java 堆占用超过最大堆限制的 85% 的 UV / 采集 UV
```

其中是否触顶可以通过下面的方法计算得到。

```java
long javaMax = runtime.maxMemory();
long javaTotal = runtime.totalMemory();
long javaUsed = javaTotal - runtime.freeMemory();
// Java 内存使用超过最大限制的 85%
float proportion = (float) javaUsed / javaMax;
```



### GC监控

通过Debug.startAllocCounting 来监控 Java 内存分配和 GC 的情况

```java
// 内存分配的次数
long allocCount = Debug.getGlobalAllocCount();
// 内存分配大小
long allocSize = Debug.getGlobalAllocSize();
// GC 发起次数
long gcCount = Debug.getGlobalGcInvocationCount();

// 运行的GC次数
Debug.getRuntimeStat("art.gc.gc-count");
// GC使用的总耗时，单位是毫秒
Debug.getRuntimeStat("art.gc.gc-time");
// 阻塞式GC的次数
Debug.getRuntimeStat("art.gc.blocking-gc-count");
// 阻塞式GC的总耗时
Debug.getRuntimeStat("art.gc.blocking-gc-time");
```



### 内存重复图片检测

依赖 ：

```
api 'com.squareup.haha:haha:2.0.4'
```



创建3张一样的bitmap，然后dump hprof文件

```
Debug.dumpHprofData(file.getAbsolutePath());
```



```java
// 打开hprof文件
HprofBuffer bufferr = null;
try {
    bufferr = new MemoryMappedFileBuffer(mFile);
    HprofParser parser = new HprofParser(bufferr);
    //解析获取快照
    Snapshot snapshot = parser.parse();
    // 获得Bitmap Class
    final ClassObj bitmapClass = snapshot.findClass("android.graphics.Bitmap");
    // 获得heap, 只需要分析app和default heap即可
    Heap heap = snapshot.getHeap("app");
    // 从heap中获得所有的Bitmap实例
    final List<Instance> bitmapInstances = bitmapClass.getHeapInstances(heap.getId());
    // 从Bitmap实例中获得buffer数组
    if (bitmapInstances == null || bitmapInstances.size() == 0) {
        //不存在相同的bitmap
        return;
    }
    int[] buffers = new int[bitmapInstances.size()];
    for (int i = 0; i < bitmapInstances.size(); i++) {
        ArrayInstance arrayInstance = HahaHelper.fieldValue(((ClassInstance) bitmapInstances.get(i)).getValues(), "mBuffer");
        //计算hashcode存入buffers
        buffers[i] = Arrays.hashCode(arrayInstance.getValues());
    }
    HashMap<Integer, ArrayList<Instance>> map = new HashMap<>();
    for (int i = 0; i < buffers.length; i++) {
        if (!map.containsKey(buffers[i])) {
            ArrayList<Instance> list = new ArrayList<>();
            list.add(bitmapInstances.get(i));
            map.put(buffers[i], list);
        } else {
            continue;
        }
        for (int j = i + 1; j < buffers.length; j++) {
            //判断是否有重复图片
            if (buffers[i] == buffers[j]) {
                map.get(buffers[i]).add(bitmapInstances.get(j));
            }
        }
    }
    
    StringBuilder sb = new StringBuilder();
    for (Map.Entry<Integer, ArrayList<Instance>> entry : map.entrySet()) {
        //size > 1 表示存在相同图片
        if (entry.getValue().size() > 1) {
            sb.append("duplicateCount:" + entry.getValue().size() + "\n");
            List<Instance> instances = entry.getValue();
            sb.append("stacks:" + "\n");
            String[] infos = new String[instances.size()];
            for (int i = 0; i < instances.size(); i++) {
                infos[i] = getTraceString(getTraceFromInstance(instances.get(i)));
            }
            Instance instance = instances.get(0);
            sb.append(Arrays.toString(infos) + "\n");
            sb.append("bufferHashcode:" + entry.getKey() + "\n");
            int width = HahaHelper.fieldValue(((ClassInstance) instance).getValues(), "mWidth");
            int height = HahaHelper.fieldValue(((ClassInstance) instance).getValues(), "mHeight");
            sb.append("width:" + width + "\n");
            sb.append("height:" + height + "\n");
            ArrayInstance arrayInstance = HahaHelper.fieldValue(((ClassInstance) instance).getValues(), "mBuffer");
            sb.append("bufferSize:" + arrayInstance.getValues().length);
        }
    }
} catch (IOException e) {
    e.printStackTrace();
}
```





### 相关资料

[内存优化杂谈](https://mp.weixin.qq.com/s/Z7oMv0IgKWNkhLon_hFakg?)

[device-year-class](https://github.com/facebookarchive/device-year-class)

[调查 RAM 使用情况](https://developer.android.com/studio/profile/memory-profiler?hl=zh-cn)

[Android 内存申请分析](https://mp.weixin.qq.com/s/b_lFfL1mDrNVKj_VAcA2ZA?)

[AddressSanitize](https://source.android.com/docs/security/test/asan) 

[指南](https://github.com/google/sanitizers/wiki/AddressSanitizerOnAndroid)

[调试本地内存使用](https://source.android.com/docs/core/tests/debug/native-memory)

[Malloc 调试](https://android.googlesource.com/platform/bionic/+/master/libc/malloc_debug/README.md)

[wrap.sh](http://developer.android.com/ndk/guides/wrap-script.html)

[Malloc 钩子](http://android.googlesource.com/platform/bionic/+/master/libc/malloc_hooks/README.md)

[fbjni ](https://github.com/facebookincubator/profilo/tree/master/deps/fbjni)是从 Facebook 开源的一款jni工具类库，主要提供了工具类，ref utils ，Global JniEnv。

[ndk_dlopen](https://github.com/rrrfff/ndk_dlopen) 提供了force dlopen 机制,来绕过 Android Classloader-Namespace Restriction 机制，以及 C++ 里的线程同步等。

Inline Hook 方案（[Substrate](https://github.com/AndroidAdvanceWithGeektime/Chapter03/tree/master/alloctrackSample/src/main/cpp/Substrate)和[HookZz](https://github.com/jmpews/Dobby)）

PLT Hook 方案（[Facebook Hook](https://github.com/facebookincubator/profilo/tree/main/deps/linker)）

获取函数的地址可以通过[dlsym](https://linux.die.net/man/3/dlsym)函数来根据名字获取

动态库里的函数名称一般都会通过 [Name Mangling](http://www.int0x80.gr/papers/name_mangling.pdf) 技术来生成一个符号名称

Name Mangling通过[c++filt](https://linux.die.net/man/1/c++filt)工具来进行反解

Name Mangling[网页版解析工具](http://demangler.com/)

[Probe](https://static001.geekbang.org/con/19/pdf/593bc30c21689.pdf)

[微信 Android 终端内存优化实践](https://mp.weixin.qq.com/s/KtGfi5th-4YHOZsEmTOsjg?)



## 卡顿优化

### 常用命令

####  获取 CPU 核心数

```
cat /sys/devices/system/cpu/possible  
```

#### 获取某个 CPU 的频率

```
cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq
```

#### 查看整个系统的 CPU 使用情况

```
/proc/stat
```

#### 得到某个进程的 CPU 使用情况

```
proc/[pid]/stat:
  utime:       用户时间，反应用户代码执行的耗时  
  stime:       系统时间，反应系统调用执行的耗时
  majorFaults：需要硬盘拷贝的缺页次数
  minorFaults：无需硬盘拷贝的缺页次数

如果 CPU 使用率长期大于 60% ，表示系统处于繁忙状态，需要进一步分析用户时间和系统时间的比例。
对于普通应用程序，系统时间不会长期高于 30%，如果超过这个值，我们就应该进一步检查是 I/O 过多，还是其他的系统调用问题。
```

#### 进程下面各个线程的CPU使用情况

```
proc/[pid]/task/[tid]/stat
```

#### 查看哪个进程是 CPU 的消耗大户

```
top
```

#### 实时动态监视操作系统的虚拟内存和 CPU 活动

```
vmstat
```

#### 跟踪某个进程中所有的系统调用

```
strace
```

#### 查看 CPU 上下文切换次数

```
proc/[pid]/schedstat:
  nr_voluntary_switches：     
  主动上下文切换次数，因为线程无法获取所需资源导致上下文切换，最普遍的是IO。    
  nr_involuntary_switches：   
  被动上下文切换次数，线程被系统强制调度导致上下文切换，例如大量线程在抢占CPU。
  se.statistics.iowait_count：IO 等待的次数
  se.statistics.iowait_sum：  IO 等待的时间
```

#### 检查 CPU 在 1 分钟、5 分钟和 15 分钟内的平均负载。

```
uptime

00:02:39 up 7 days, 46 min,  0 users,  
load average: 13.91, 14.70, 14.32
一般平均负载建议控制在“0.7 × 核数”以内
```

#### 系统平均负载，uptime命令对应文件

```
/proc/loadavg
```





线程优先级由 nice 和 cgroup 类型共同决定。nice 值越低，抢占 CPU 时间片的能力越强。



### Android 卡顿排查工具

#### 流派:

##### instrument:

获取一段时间内所有函数的调用过程，可以通过分析这段时间内的函数调用流程，再进一步分析待优化的点。

##### sample:

有选择性或者采用抽样的方式观察某些函数调用过程，可以通过这些有限的信息推测出流程中的可疑点，然后再继续细化分析。



#### 工具:

#### Traceview(instrument)

利用 Android Runtime 函数调用的 event 事件，将函数运行的耗时和调用关系写入 trace 文件中。

缺点:性能开销过大，有时无法反映真实的情况。比如一个函数本身的耗时是 1 秒，开启 Traceview 后可能会变成 5 秒，而且这些函数的耗时变化并不是成比例放大。

在 Android 5.0 之后，新增了startMethodTracingSampling方法，可以使用基于样本的方式进行分析，以减少分析对运行时的性能影响。



#### Nanoscope(Uber开源,instrument)

原理是直接修改 Android 虚拟机源码，在ArtMethod执行入口和执行结束位置增加埋点代码，将所有的信息先写到内存，等到 trace 结束后才统一生成结果文件。

优点：不卡，支持分析任意一个应用，可用于做竞品分析。

缺点：

1.需要自己刷 ROM，并且当前只支持 Nexus 6P，或者采用其提供的 x86 架构的模拟器。

2.默认只支持主线程采集，其他线程需要代码[手动设置](https://github.com/uber/nanoscope/wiki/Architecture%3A-Nanoscope-ROM#java-api)。考虑到内存大小的限制，每个线程的内存数组只能支持大约 20 秒左右的时间段。



#### systrace(sample)

通常用来跟踪系统的 I/O 操作、CPU 负载、Surface 渲染、GC 等事件。

原理:利用了 Linux 的ftrace调试工具，相当于在系统各个关键位置都添加了一些性能探针，也就是在代码里加了一些性能监控的埋点。Android 在 ftrace 的基础上封装了atrace，并增加了更多特有的探针，例如 Graphics、Activity Manager、Dalvik VM、System Server 等。



可以通过Trace.beginSection和Trace.endSection来监听应用程序的调用耗时,编译时给每个函数插桩的方式来实现

好处：

- 可以看到整个流程系统和应用程序的调用流程。包括系统关键线程的函数调用，例如渲染耗时、线程锁，GC 耗时等。
- 性能损耗可以接受。由于过滤了大部分的短函数，而且没有放大 I/O，所以整个运行耗时不到原来的两倍，基本可以反映真实情况。



#### Simpleperf(sample)

利用 CPU 的性能监控单元（PMU）提供的硬件 perf 事件。使用 Simpleperf 可以看到所有的 Native 代码的耗时，有时候一些 Android 系统库的调用对分析问题有比较大的帮助，例如加载 dex、verify class 的耗时等。



#### 总结：

如果需要分析 Native 代码的耗时，可以选择 Simpleperf；

如果想分析系统调用，可以选择 systrace；

如果想分析整个程序执行流程的耗时，可以选择 Traceview 或者插桩版本的 systrace。





### 可视化方法

Android Studio 3.2 的 Profiler 中直接集成了几种性能分析工具:

Sample Java Methods 的功能类似于 Traceview 的 sample 类型。

Trace Java Methods 的功能类似于 Traceview 的 instrument 类型。

Trace System Calls 的功能类似于 systrace。

SampleNative (API Level 26+) 的功能类似于 Simpleperf。





### 统计一段时间内的CPU使用情况

获取应用进程ID

```
android.os.Process.myPid()
```

jiffies 是内核中的一个全局变量，用来记录系统启动以来产生的节拍数，在 Linux 中，一个节拍大致可以理解为操作系统进程调度的最小时间片，不同的 Linux 系统内核这个值可能不同，通常在 1ms 到 10ms 之间。

```
long jiffyHz = Sysconf.getScClkTck(); //100
mJiffyMillis = 1000 / jiffyHz; //10
```

 从开机到现在的毫秒数（不包括CPU休眠时间）

```
SystemClock.uptimeMillis()
```

 从开机到现在的毫秒数（包括CPU休眠时间）

```
SystemClock.elapsedRealtime()
```

获取当前时间

```
System.currentTimeMillis()
```

获取系统CPU信息 (只读第一行，cpu)

```
/proc/stat
```

输出信息:

```
	 user_time  nicetime  systime  idle_time  iowait_time  irq_time  soft_irq_time
cpu  26961      4602      32204    2493737    7838         0         672            0 0 0
cpu0 6181 1107 8848 617970 1658 0 524 0 0 0
cpu1 5700 1159 8228 625327 2554 0 45 0 0 0
cpu2 9425 1098 7600 621805 1395 0 53 0 0 0
cpu3 5655 1238 7528 628636 2231 0 50 0 0 0
intr 2074019 51 0 0 0 2 0 0 0 1 0 27163 24875 0 0 0 0 3 527 125227 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
ctxt 4084531
btime 1665763047
processes 7001
procs_running 1
procs_blocked 0
softirq 1190583 64140 252610 8448 79058 0 0 307359 230414 0 248554
```

用户时间 = (user_time + nicetime) * mJiffyMillis

系统时间 = systime * mJiffyMillis

空闲时间 = idle_time * mJiffyMillis

等待时间 = iowait_time * mJiffyMillis

硬中断时间 = irq_time * mJiffyMillis

软中断时间 = soft_irq_time * mJiffyMillis



获取进程CPU使用情况

```
/proc/[pid]/stat
```

输出信息(50条数据)

```
S 1776 1776 0 0 -1 1077952832 35309 0 111 0 265 532 0 0 10 -10 19 0 378551 1627402240 27826 18446744073709551615 1 1 0 0 0 0 4612 1 1073775864 0 0 0 17 2 0 0 139 0 0 0 0 0 0 0 0 0 0


STATUS 进程状态[0] = S
minor_faults 无需硬盘拷贝的缺页次数[7] = 35309
major_faults 需要硬盘拷贝的缺页次数[9] = 111
用户时间[11] * mJiffyMillis = 265 * mJiffyMillis
系统时间[12] * mJiffyMillis = 532 * mJiffyMillis
```



获取进程下面各个线程的CPU使用情况

```
/proc/5373/task/[tid]/stat
```

输出信息(同上)

```
S 1883 1883 0 0 -1 1077944640 2089 0 0 0 14 5 0 0 10 -10 15 0 43794 992772096 23854 4294967295 3614990336 3615004148 3755752016 3755735800 3614305472 0 4612 0 34040 0 0 0 17 2 0 0 0 0 0 3615010124 3615010816 3626156032 3755752496 3755752572 3755752572 3755753444 0
```



对收集到所有线程信息进行排序

```
用户时间 + 系统时间 进行比较
```



获取系统平均负载，uptime命令对应文件

```
/proc/loadavg
```

输出信息

```
1min  5min  15min
0.00  0.07  0.20    2/1324 6098
```



计算:

```
usage: CPU usage 5000ms(from 23:23:33.000 to 23:23:38.000):
5000ms = 当前时间 - 最后一次采样时间 (最后一次采样时间 to  当前采样时间)

[/proc/[pid]/stat]
当前进程占用比例 = (user + system) / totalTime   * 100
当前进程user比例   = user / totalTime * 100
当前进程kernel比例 = system / totalTime * 100
当前进程minor = 无需硬盘拷贝的缺页次数
当前进程major = 需要硬盘拷贝的缺页次数

[/proc/5373/task/[tid]/stat]
线程计算比例：计算方式同上

[/proc/stat]
系统CPU占用比例 = (user + system + iowait + irq + softIrq + idle) / totalTime   * 100
系统CPU user比例   = user / totalTime * 100
系统CPU kernel比例 = system / totalTime * 100
系统CPU iowait比例 = iowait / totalTime * 100
系统CPU irq比例 = irq / totalTime * 100
系统CPU softIrq比例 = softIrq / totalTime * 100
系统CPU idle比例 = idle / totalTime * 100

[/proc/loadavg]
输出系统平均负载 1min  5min  15min

```



正常情况

```
0% 3071/com.sample.processtracker(R): 0% user + 0% kernel / faults: 42 minor
thread stats:
0% 3104/RenderThread(S): 0% user + 0% kernel
0% 3071/.processtracker(R): 0% user + 0% kernel / faults: 24 minor
0% 3117/hwuiTask2(S): 0% user + 0% kernel / faults: 12 minor
0% 3084/HeapTaskDaemon(S): 0% user + 0% kernel
0% 3116/hwuiTask1(S): 0% user + 0% kernel / faults: 6 minor
0% 3076/Jit thread pool(S): 0% user + 0% kernel
0% 3077/Signal Catcher(S): 0% user + 0% kernel
0% 3080/JDWP(S): 0% user + 0% kernel
0% 3081/ReferenceQueueD(S): 0% user + 0% kernel
0% 3082/FinalizerDaemon(S): 0% user + 0% kernel
0% 3083/FinalizerWatchd(S): 0% user + 0% kernel
0% 3085/Binder:3071_1(S): 0% user + 0% kernel
0% 3087/Binder:3071_2(S): 0% user + 0% kernel
0% 3096/Profile Saver(S): 0% user + 0% kernel
0% 3172/Binder:3071_3(S): 0% user + 0% kernel
100% TOTAL(): 0.1% user + 0.1% kernel + 0% iowait + 99% idle
Load: 0.07 / 0.37 / 0.22
```



gc测试

```
private void testGc() {
    for (int i = 0; i < 10000; i++) {
        int[] test = new int[100000];
        System.gc();
    }
}


90% 3071/com.sample.processtracker(R): 21% user + 68% kernel / faults: 12125 minor
thread stats:
49% 3084/HeapTaskDaemon(R): 9.5% user + 40% kernel / faults: 1787 minor
40% 3071/.processtracker(R): 13% user + 26% kernel / faults: 10369 minor
100% TOTAL(): 5% user + 16% kernel + 78% idle
Load: 0.25 / 0.47 / 0.23
```



io测试

```
private void testIO() {
    Thread thread = new Thread(new Runnable() {
        @Override
        public void run() {
            writeSth();
            try {
                Thread.sleep(100000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    });
    thread.setName("SingleThread");
    thread.start();
}
private void writeSth() {
    try {
        File f = new File(getFilesDir(), "aee.txt");
        if (f.exists()) {
            f.delete();
        }
        FileOutputStream fos = new FileOutputStream(f);
        byte[] data = new byte[1024 * 4 * 3000];
        for (int i = 0; i < 30; i++) {
            Arrays.fill(data, (byte) i);
            fos.write(data);
            fos.flush();
        }
        fos.close();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}

第一次
48% 3071/com.sample.processtracker(R): 4.3% user + 43% kernel / faults: 3149 minor
thread stats:
46% 4071/SingleThread(S): 4.3% user + 41% kernel / faults: 3021 minor
1.5% 3104/RenderThread(S): 0.1% user + 1.3% kernel
0.5% 3071/.processtracker(R): 0.5% user + 0% kernel / faults: 34 minor
100% TOTAL(): 1.9% user + 15% kernel + 0% iowait + 0.9% softirq + 81% idle
Load: 0.04 / 0.33 / 0.21

第N次
12% 3071/com.sample.processtracker(R): 3.1% user + 9.3% kernel / faults: 3114 minor
thread stats:
9.9% 4075/SingleThread(S): 3.3% user + 6.5% kernel / faults: 3011 minor
2.1% 3104/RenderThread(S): 0% user + 2.1% kernel
100% TOTAL(): 1% user + 3.4% kernel + 0.4% iowait + 0.3% softirq + 94% idle
Load: 0.02 / 0.29 / 0.2
```





### 卡顿监控

#### 消息队列

1.通过替换 Looper 的 Printer 实现

缺点:大量字符串拼接导致性能损耗严重。



2.每隔 1 秒向主线程消息队列的头部插入一条空消息。假设 1 秒后这个消息并没有被主线程消费掉。

缺点：发送空消息的间隔时间不能太小，因为监控线程和主线程处理空消息都会带来一些性能损耗，但基本影响不大。



整体缺点：监控并不准确，正在运行的函数有可能并不是真正耗时的函数。



#### 插桩

在函数入口和出口加入耗时监控的代码

注意:

- 避免方法数暴增：在编译时提前给代码中每个方法分配一个独立的 ID 作为参数。
- 过滤简单的函数：过滤一些类似直接 return、i++ 这样的简单函数，并且支持黑名单配置。对一些调用非常频繁的函数，需要添加到黑名单中来降低整个方案对性能的损耗。



缺点：只能监控应用内自身的函数耗时，无法监控系统的函数调用



#### Profilo

- 集成 atrace 功能：trace 所有性能埋点数据都会通过 trace_marker 文件写入内核缓冲区，Profilo 通过 PLT Hook 拦截了写入操作，选择部分关心的事件做分析。这样所有 systrace 的探针我们都可以拿到

- 快速获取 Java 堆栈：正常情况获取堆栈的代价是巨大的，它要暂停主线程的运行。

  Profilo 的实现非常精妙，它实现类似 Native 崩溃捕捉的方式快速获取 Java 堆栈，通过间隔发送 SIGPROF 信号。

  Signal Handler 捕获到信号后，拿取到当前正在执行的 Thread，通过 Thread 对象可以获取当前线程的 ManagedStack，ManagedStack 是一个单链表，它保存了当前的 ShadowFrame 或者 QuickFrame 栈指针，先依次遍历 ManagedStack 链表，然后遍历其内部的 ShadowFrame 或者 QuickFrame 还原一个可读的调用栈，从而 unwind 出当前的 Java 堆栈。通过这种方式，可以实现线程一边继续跑步，我们还可以帮它做检查，而且耗时基本忽略不计。

  （参考的是 JVM 的 AsyncGetCallTrace 思路，然后适配 Android Runtime 的实现。）

缺点：

内部实现有大量函数的 Hook，unwind 也需要强依赖 Android Runtime 实现。

目前 Profilo 快速获取堆栈功能依然不支持 Android 8.0 和 Android 9.0。



### 其他监控

#### 帧率

使用 Choreographer 来监控应用的帧率

如何监听界面是否存在绘制行为?

```
getWindow().getDecorView().getViewTreeObserver().addOnDrawListener
```

冻帧率：计算发生冻帧时间在所有时间的占比



#### 生命周期监控

插桩技术的实现



#### 线程监控

线程数量：通过 got hook 线程的 nativeCreate() 函数。主要用于进行线程收敛，也就是减少线程数量。

线程时间：监控线程的用户时间 utime、系统时间 stime 和优先级。主要是看哪些线程 utime+stime 时间比较多，占用了过多的 CPU。





### 使用 PLTHook 技术来获取 Atrace 的日志

初始化hook

```c++
std::string lib_name("libcutils.so");
std::string enabled_tags_sym("atrace_enabled_tags");
std::string fd_sym("atrace_marker_fd");

if (sdk < 18) {
    lib_name = "libutils.so";
    // android::Tracer::sEnabledTags
    enabled_tags_sym = "_ZN7android6Tracer12sEnabledTagsE";
    // android::Tracer::sTraceFD
    fd_sym = "_ZN7android6Tracer8sTraceFDE";
}

void *handle;
if (sdk < 21) {
    handle = dlopen(lib_name.c_str(), RTLD_LOCAL);
} else {
    handle = dlopen(nullptr, RTLD_GLOBAL);
}

atrace_enabled_tags = reinterpret_cast<std::atomic<uint64_t> *>(dlsym(handle, enabled_tags_sym.c_str()));
atrace_marker_fd = reinterpret_cast<int *>(dlsym(handle, fd_sym.c_str()));
```

plt hook libc 的 write 方法

```c++
void hookLoadedLibs() {
    hook_plt_method("libc.so", "write", (hook_func) &write_hook);
    hook_plt_method("libc.so", "__write_chk", (hook_func) &__write_chk_hook);
}
```

hook 自定义的write

```c++
ssize_t write_hook(int fd, const void *buf, size_t count) {
    if (should_log_systrace(fd, count)) {
        log_systrace(buf, count);
        return count;
    }
    return CALL_PREV(write_hook, fd, buf, count);
}

ssize_t __write_chk_hook(int fd, const void *buf, size_t count, size_t buf_size) {
    if (should_log_systrace(fd, count)) {
        log_systrace(buf, count);
        return count;
    }
    return CALL_PREV(__write_chk_hook, fd, buf, count, buf_size);
}

/**
* 只针对特定的fd，降低性能影响
*/
bool should_log_systrace(int fd, size_t count) {
    return systrace_installed && fd == *atrace_marker_fd && count > 0;
}

```

日志输出

```c++
void log_systrace(const void *buf, size_t count) {
    const char *msg = reinterpret_cast<const char *>(buf);
    switch (msg[0]) {

        case 'B': { // begin synchronous event. format: "B|<pid>|<name>"
            ALOG("========= %s", msg);
            break;
        }
        case 'E': { // end synchronous event. format: "E"
            ALOG("========= E");

            break;
        }
            // the following events we don't currently log.
        case 'S': // start async event. format: "S|<pid>|<name>|<cookie>"
        case 'F': // finish async event. format: "F|<pid>|<name>|<cookie>"
        case 'C': // counter. format: "C|<pid>|<name>|<value>"
        default:
            return;
    }
}
```

开启Systrace

修改native层

```c++
auto prev = atrace_enabled_tags->exchange(UINT64_MAX);
```

修改java层

```java
static {
    Method m;
    try {
        m = Trace.class.getDeclaredMethod("nativeGetEnabledTags");
        m.setAccessible(true);
    } catch (NoSuchMethodException e) {
        m = null;
    }
    sTrace_nativeGetEnabledTags = m;
    Field f;
    try {
        f = Trace.class.getDeclaredField("sEnabledTags");
        f.setAccessible(true);
    } catch (NoSuchFieldException e) {
        f = null;
    }
    sTrace_sEnabledTags = f;
}
```

```java
sTrace_sEnabledTags.set(null, sTrace_nativeGetEnabledTags.invoke(null));
```



### 卡顿现场

#### 1.Java 实现

##### 获得 Java 线程状态

```
Thread.getState
```

BLOCKED 是指线程正在等待获取锁，对应的是下面代码中的情况一；

WAITING 是指线程正在等待其他线程的“唤醒动作”，对应的是代码中的情况二。

```
synchronized (object)  {     // 情况一：在这里卡住 --> BLOCKED
    object.wait();           // 情况二：在这里卡住 --> WAITING
}  
```

WAITING 状态时，会释放 CPU 资源，还会将持有的 object 锁也同时释放。



##### 获得所有线程堆栈

```
Thread.getAllStackTraces()
```

注意: Android 7.0，getAllStackTraces 是不会返回主线程的堆栈的。



#### 2.SIGQUIT 信号实现

ANR日志

```
// 线程名称; 优先级; 线程id; 线程状态
"main" prio=5 tid=1 Suspended
  // 线程组;  线程suspend计数; 线程debug suspend计数; 
  | group="main" sCount=1 dsCount=0 obj=0x74746000 self=0xf4827400
  // 线程native id; 进程优先级; 调度者优先级;
  | sysTid=28661 nice=-4 cgrp=default sched=0/0 handle=0xf72cbbec
  // native线程状态; 调度者状态; 用户时间utime; 系统时间stime; 调度的CPU
  | state=D schedstat=( 3137222937 94427228 5819 ) utm=218 stm=95 core=2 HZ=100
  // stack相关信息
  | stack=0xff717000-0xff719000 stackSize=8MB
```



Native 线程状态

...

![](![img](https://static001.geekbang.org/resource/image/af/4b/af6485856d47626b13433f96ec48d44b.png?wh=1284*936))



获得 ANR 日志

第一步：当监控到主线程卡顿时，主动向系统发送 SIGQUIT 信号。

第二步：等待 /data/anr/traces.txt 文件生成。

第三步：文件生成以后进行上报。

```
// 堆栈相关信息
at android.content.res.AssetManager.open(AssetManager.java:311)
- waiting to lock <0x41ddc798> (android.content.res.AssetManager) held by tid=66 (BackgroundHandler)
at android.content.res.AssetManager.open(AssetManager.java:289)
```

相比java，锁是哪个线程持有的更加直观



#### 3.Hook 实现

通过libart.so、dlsym调用ThreadList::ForEach方法，拿到所有的 Native 线程对象。

遍历线程对象列表，调用Thread::DumpState方法。

为了兼容性考虑，我们会通过 fork 子进程方式实现，这样即使子进程崩溃了也不会影响我们主进程的运行。这样还可以带来另外一个非常大的好处，获取所有线程堆栈这个过程可以做到完全不卡我们主进程。

注：fork 进程会导致进程号改变，例如 state、schedstat、utm、stm、core这些信息可以通过指定 /proc/[父进程 id]的方式重新获取。

为了降低上报数据量，只有主线程的 Java 线程状态是 WAITING、TIME_WAITING 或者 BLOCKED 的时候，才会进一步使用这个hook。



### 使用 PLTHook来获取线程创建的堆栈

hook

```c++
hook_plt_method("libart.so", "pthread_create", (hook_func) &pthread_create_hook);

int pthread_create_hook(pthread_t* thread, const pthread_attr_t* attr, void* (*start_routine) (void *), void* arg) {
    printJavaStack();
    return CALL_PREV(pthread_create_hook, thread, attr, *start_routine, arg);
}
```



如何查找Hook的So

Thread_nativeCreate、CreateNativeThread和pthread_create函数分别编译在哪个library中呢？

查编译脚本[Android.bp](http://androidxref.com/9.0.0_r3/xref/art/runtime/Android.bp)



### 相关资料

[Linux 环境下进程的 CPU 占用率](http://www.samirchen.com/linux-cpu-performance/)

[Linux 文档](https://man7.org/linux/man-pages/man5/proc.5.html)

[Traceview](http://developer.android.com/studio/profile/generate-trace-logs)

[Nanoscope](http://github.com/uber/nanoscope)

[systrace](https://source.android.com/docs/core/tests/debug/systrace?hl=zh-cn)

[ftrace](http://source.android.com/devices/tech/debug/ftrace)

[atrace](https://android.googlesource.com/platform/frameworks/native/+/master/cmds/atrace/atrace.cpp)

[Simpleperf](https://android.googlesource.com/platform/system/extras/+/master/simpleperf/doc/README.md)

Android 系统会打印 CPU 相关的信息到日志中，使用的是[ProcessCpuTracker.java](http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/com/android/internal/os/ProcessCpuTracker.java)



[Profilo](https://github.com/facebookincubator/profilo)

[Profilo::unwind](https://github.com/facebookincubator/profilo/blob/main/cpp/profiler/unwindc/android_712/arm/unwinder.h)

[StackVisitor::WalkStack](http://androidxref.com/7.1.1_r6/xref/art/runtime/stack.cc#772)

[ftrace Documentation](https://www.kernel.org/doc/Documentation/trace/ftrace.txt)

[Demangle](http://bramante.github.io/blog/2015/08/20/demangle-c-plus-plus-symbols/) 



Lottie 动画中[openNonAsset](http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/content/res/AssetManager.java#852)函数耗时竟然将近 2 秒

[AssetManager.list](http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/content/res/AssetManager.java#788)

[Thread.State](https://developer.android.com/reference/java/lang/Thread.State)

[Java 线程 Dump 分析](https://juejin.cn/post/6844903625228025864)

[ANR日志](https://developer.android.com/topic/performance/vitals/anr)

[thread_state.h](http://androidxref.com/9.0.0_r3/xref/art/runtime/thread_state.h#24)

[Thread_nativeGetStatus](http://androidxref.com/9.0.0_r3/xref/art/runtime/native/java_lang_Thread.cc#64)

[手 Q Android 线程死锁监控与自动化分析实践](https://cloud.tencent.com/developer/article/1064396)

[ThreadList::ForEach](http://androidxref.com/9.0.0_r3/xref/art/runtime/thread_list.cc#1501)

[Thread::DumpState](http://androidxref.com/9.0.0_r3/xref/art/runtime/thread.cc#1615)

JVMTI机制

[Android 线程的创建过程](https://www.jianshu.com/p/a26d11502ec8)

[java_lang_Thread.cc](http://androidxref.com/9.0.0_r3/xref/art/runtime/native/java_lang_Thread.cc#43)

[thread.cc](http://androidxref.com/9.0.0_r3/xref/art/runtime/thread.cc)

[编译脚本 Android.bp](http://androidxref.com/9.0.0_r3/xref/art/runtime/Android.bp)





## 启动优化

### 查看线程切换数据

```
proc/[pid]/sched:
  nr_voluntary_switches：     
  主动上下文切换次数，因为线程无法获取所需资源导致上下文切换，最普遍的是IO。    
  nr_involuntary_switches：   
  被动上下文切换次数，线程被系统强制调度导致上下文切换，例如大量线程在抢占CPU。
```

### 查看GC耗时情况

```
// GC使用的总耗时，单位是毫秒
Debug.getRuntimeStat("art.gc.gc-time");
// 阻塞式GC的总耗时
Debug.getRuntimeStat("art.gc.blocking-gc-time");
```

### 实现systrace + 函数插桩

通过插桩，代码加入Trace Tag，然后利用systrace查看结果

### IO优化

启动过程适合使用随机读写的数据结构，可以将 ArrayMap 改造成支持随机读写、延时解析的数据存储方式。

### 数据重排

Linux 文件系统从磁盘读文件时，会以 block 为单位去磁盘读取，一般 block 大小是 4KB。然后会把 4KB 数据放到页缓存 Page Cache 中。

如果下次读取文件数据已经在页缓存中，那就不会发生真实的磁盘 I/O，而是直接从页缓存中读取，大大提升了读的速度。

例:读1KB数据,每次读1 byte，总共要读取 1000 次。但事实上只会发生一次磁盘 I/O，其他的数据都会在页缓存中得到。



优化：在读取资源时,可以按读取顺序重新排列，减少真实的磁盘 I/O 次数。

#### 类重排

启动过程类加载顺序可以通过复写 ClassLoader 得到。

```
class GetClassLoader extends PathClassLoader {
    public Class<?> findClass(String name) {
        // 将 name 记录到文件
        writeToFile(name，"coldstart_classes.txt");
        return super.findClass(name);
    }
}
```

通过 ReDex 的Interdex调整类在 Dex 中的排列顺序，最后可以利用 010 Editor 查看修改后的效果。

#### 资源文件重排

1.修改 Kernel 源码，单独编译了一个特殊的 ROM

目的:

- 统计：统计应用启动过程加载了安装包中哪些资源文件，得到一个资源加载的顺序列表。
- 度量：在完成资源顺序重排后，我们需要确定是否真正生效。比如有哪些资源文件加载了，它是发生真实的磁盘 I/O，还是命中了 Page Cache。
- 自动化：通过定制 ROM 的一些埋点和配合的工具，我们可以将它们放到自动化流程当中。



利用 Frida 实现获得 Android 资源加载顺序的方法

```
resourceImpl.loadXmlResourceParser.implementation=function(a,b,c,d){
   send('file:'+a)
   return this.loadXmlResourceParser(a,b,c,d)
}


resourceImpl.loadDrawableForCookie.implementation=function(a,b,c,d,e){
   send("file:"+a)
   return this.loadDrawableForCookie(a,b,c,d,e)
}
```



2.修改 7zip 源码实现支持传入文件列表顺序。



### 类的加载

加载类的过程有一个 verify class 的步骤，它需要校验方法的每一个指令，是一个比较耗时的操作。

通过 Hook 来去掉 verify 这个步骤。

```
// Dalvik Globals.h
gDvm.classVerifyMode = VERIFY_MODE_NONE;
// Art runtime.cc
verify_ = verifier::VerifyMode::kNone;
```

Atlas 中的dalvik_hack-3.0.0.5.jar可以通过下面的方法去掉 verify，但是当前没有支持 ART 平台。

```
AndroidRuntime runtime = AndroidRuntime.getInstance();
runtime.init(context);
runtime.setVerificationEnabled(false);
```







### 相关资料

[mmkernel](https://mp.weixin.qq.com/s/6Q818XA5FaHd7jJMFBG60w?)

[Alpha](https://github.com/alibaba/alpha)

[调查 RAM 使用情况](http://developer.android.com/studio/profile/investigate-ram?hl=zh-cn)

[redex](https://github.com/facebook/redex)

[通过安装包重排布优化 Android 端启动性能](https://mp.weixin.qq.com/s/79tAFx6zi3JRG-ewoapIVQ)

[atlas](https://github.com/alibaba/atlas)

[frida](https://github.com/frida/frida)

[微信 Android 热补丁实践演进之路](https://mp.weixin.qq.com/s/-NmkSwZu83HAmzKPawdTqQ)

[Hyper Boost](https://www.geekpark.net/news/233791)

[GC 抑制](https://mp.weixin.qq.com/s/ePjxcyF3N1vLYvD5dPIjUw)

[Android Vitals](https://developer.android.google.cn/topic/performance/vitals/launch-time)



## I/O优化

### 文件系统

- APFS：iOS 10.3 系统以后，使用 APFS（Apple File System）替代之前旧的文件系统 HFS+。
- ext4 ：Android:普遍使用的是 Linux 常用的 ext4 文件系统。
- F2FS ：华为在 EMUI 5.0 以后就使用 F2FS 取代 ext4

F2FS 文件系统在小文件的随机读写方面比 ext4 更快，例如随机写可以优化 60%，但在连续读取大文件上并没有优势，而且会占用更大的空间。只是对一般应用程序来说，随机 I/O 会更加频繁，特别是在启动的场景。可以在 /proc/filesystems 看到系统可以识别的所有文件系统的列表。



应用程序调用 read() 方法，系统会通过中断从用户空间进入内核处理流程，然后经过 VFS（Virtual File System，虚拟文件系统）、具体文件系统、页缓存 Page Cache。

- 虚拟文件系统（VFS）:主要用于实现屏蔽具体的文件系统
- 文件系统（File System）:ext4、F2FS 都是具体文件系统实现（文件元数据如何组织、目录和索引结构如何设计、怎么分配和清理数据）
- 文件系统（File System）:在读文件的时，先看它是不是已经在 Page Cache 中，如果命中就不会去读取磁盘。



总结：Page Cache 就像是我们经常使用的数据缓存，是文件系统对数据的缓存，目的是提升内存命中率。Buffer Cache 就像我们经常使用的 BufferInputStream，是磁盘对数据的缓存，目的是合并部分文件系统的 I/O 请求、降低磁盘 I/O 的次数。



### 磁盘

应用程序调用read() 的数据没有在页缓存中，向磁盘发起 I/O 请求。这个过程要先经过内核的通用块层、I/O 调度层、设备驱动层，最后才会交给具体的硬件设备处理。

通用块层：接收上层发出的磁盘请求，并最终发出 I/O 请求

I/O 调度层：根据设置的调度算法对请求合并和排序。关键的参数有两个，一个是队列长度，一个是具体的调度算法。

```
下面的文件可以查看对应块设备的队列长度和使用的调度算法。
/sys/block/[disk]/queue/nr_requests      // 队列长度，一般是 128。
/sys/block/[disk]/queue/scheduler        // 调度算法
```

块设备驱动层：根据具体的物理设备，选择对应的驱动程序通过操控硬件设备完成最终的 I/O 请求。例如光盘是靠激光在表面烧录存储、闪存是靠电子擦写存储数据。



### 文件为什么会损坏

什么是文件损坏：一个文件的格式或者内容，如果没有按照应用程序写入时的结果都属于文件损坏。它不只是文件格式错误，文件内容丢失可能才是最常出现的，SharedPreference 跨进程读写就非常容易出现数据丢失的情况。



应用程序：大部分的 I/O 方法都不是原子操作，文件的跨进程或者多线程写入、使用一个已经关闭的文件描述符 fd 来操作文件，它们都有可能导致数据被覆盖或者删除。

文件系统：内核崩溃或者系统突然断电都有可能导致文件系统损坏，不过文件系统也做了很多的保护措施。例如 system 分区保证只读不可写，增加异常检查和恢复机制，ext4 的 fsck、f2fs 的 fsck.f2fs 和 checkpoint 机制等。

磁盘：资料传输过程可能会发生电子遗失等现象导致数据错误

### I/O 有时候为什么会突然很慢

内存不足：当手机内存不足的时候，系统会回收 Page Cache 和 Buffer Cache 的内存，大部分的写操作会直接落盘，导致性能低下。

写入放大：闪存重复写入需要先进行擦除操作，但这个擦除操作的基本单元是 block 块，一个 page 页的写入操作将会引起整个块数据的迁移，这就是典型的写入放大现象。



### I/O 的性能评估

#### 性能指标

I/O 吞吐量：例：“连续读取不超过 550MB/s，连续写入不超过 520MB/s”

IOPS：每秒可以读写的次数。

#### I/O 测量

**使用 proc**

```
proc/self/schedstat:
  se.statistics.iowait_count：IO 等待的次数
  se.statistics.iowait_sum：  IO 等待的时间
```

root 的机器，我们可以开启内核的 I/O 监控，将所有 block 读写 dump 到日志文件中，这样可以通过 dmesg 命令来查看。

```
echo 1 > /proc/sys/vm/block_dump
dmesg -c grep pid

.sample.io.test(7540): READ block 29262592 on dm-1 (256 sectors)
.sample.io.test(7540): READ block 29262848 on dm-1 (256 sectors)
```



**使用 strace**

跟踪 I/O 相关的系统调用次数和耗时。

```
strace -ttT -f -p [pid]
//读取文件操作符为 53 的文件,每次读取 1024 个字节,第一次读取花了 447us
read(53, "*****************"\.\.\., 1024) = 1024       <0.000447>
//后面两次都使用了 100us 不到。这跟启动优化提到的“数据重排”是一个原因，文件系统每次读取以 block 为单位，而 block 的大小一般是 4KB，后面两次的读取是从页缓存得到。
read(53, "*****************"\.\.\., 1024) = 1024       <0.000084>
read(53, "*****************"\.\.\., 1024) = 1024       <0.000059>
```

strace 统计一段时间内所有系统调用的耗时概况。不过 strace 本身也会消耗不少资源，对执行时间也会产生影响。

```
strace -c -f -p [pid]

% time     seconds  usecs/call     calls    errors  syscall
------ ----------- ----------- --------- --------- ----------------
 97.56    0.041002          21      1987             read
  1.44    0.000605          55        11             write
```

读占了 97.56% 的时间，一共调用了 1987 次，耗时 0.04s，平均每次系统调用 21us。



**使用 vmstat**

IO相关字段:

Memory 中的 buff 和 cache

I/O 中的 bi 和 bo

System 中的 cs

CPU 中的 sy 和 wa



配合dd 命令来配合测试，观察 vmstat 的输出数据变化。不过需要注意的是 Android 里面的 dd 命令似乎并不支持 conv 和 flag 参数。

```
//清除Buffer和Cache内存缓存
echo 3 > /proc/sys/vm/drop_caches
//每隔1秒输出1组vmstat数据
vmstat 1

//测试写入速度，写入文件/data/data/test，buffer大小为4K，次数为1000次
dd if=/dev/zero of=/data/data/test bs=4k count=1000
```

[《vmstat 监视内存使用情况》](https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/vmstat.html)和 [dd 命令](https://www.cnblogs.com/kongzhongqijing/articles/9049336.html)



### I/O 的三种方式

#### 标准 I/O

应用程序平时用到 read/write 操作都属于标准 I/O，也就是缓存 I/O（Buffered I/O）。

特性

读：当应用程序读取某块数据的时候，如果这块数据已经存放在页缓存中，那么这块数据就可以立即返回给应用程序，而不需要经过实际的物理读盘操作。

写：应用程序会将数据先写到页缓存中去，数据是否被立即写到磁盘上去取决于应用程序所采用写操作的机制。默认系统采用的是延迟写机制，应用程序只需要将数据写到页缓存中去就可以了，完全不需要等数据全部被写回到磁盘，系统会负责定期地将放在页缓存中的数据刷到磁盘上。



**在什么时机真正把页缓存的数据写入磁盘呢？**

Page Cache 中被修改的内存称为“脏页”，内核通过 flush 线程定期将数据写入磁盘。具体写入的条件可以通过 /proc/sys/vm 文件或者 sysctl -a | grep vm 命令得到。

```
// flush每隔5秒执行一次
vm.dirty_writeback_centisecs = 500  
// 内存中驻留30秒以上的脏数据将由flush在下一次执行时写入磁盘
vm.dirty_expire_centisecs = 3000 
// 指示若脏页占总物理内存10％以上，则触发flush把脏数据写回磁盘
vm.dirty_background_ratio = 10
// 系统所能拥有的最大脏页缓存的总大小
vm.dirty_ratio = 20
```



**在实际应用中，如果某些数据我们觉得非常重要，是完全不允许有丢失风险的，这个时候我们应该采用同步写机制。**

在应用程序中使用 sync、fsync、msync 等系统调用时，内核都会立刻将相应的数据写回到磁盘。



**以read() 操作为例:**

数据先从磁盘拷贝到 Page Cache 中，然后再从 Page Cache 拷贝到应用程序的用户空间，

这样就会多一次内存拷贝。系统这样设计主要是因为内存相对磁盘是高速设备，即使多拷贝 100 次，内存也比真正读一次硬盘要快。



#### 直接 I/O

直接 I/O 有时候也会对性能产生负面影响。

对于读操作来说，读数据操作会造成磁盘的同步读，导致进程需要较长的时间才能执行完。

对于写操作来说，使用直接 I/O 也需要同步执行，也会导致应用程序等待。



Android 并没有提供 Java 的 DirectByteBuffer，直接 I/O 需要在 open() 文件的时候需要指定 O_DIRECT 参数



#### mmap

使用 mmap 来保证性能和可靠性。

mmap通过把文件映射到进程的地址空间，最终映射的物理内存在页缓存中。

好处：

减少系统调用。我们只需要一次 mmap() 系统调用，后续所有的调用像操作内存一样，而不会出现大量的 read/write 系统调用。

减少数据拷贝。普通的 read() 调用，数据需要经过两次拷贝；而 mmap 只需要从磁盘拷贝一次就可以了，并且由于做过内存映射，也不需要再拷贝回用户空间。

可靠性高。mmap 把数据写入页缓存后，跟缓存 I/O 的延迟写机制一样，可以依靠内核线程定期写回磁盘。但是需要提的是，mmap 在内核崩溃、突然断电的情况下也一样有可能引起内容丢失，当然我们也可以使用 msync 来强制同步写。

缺点：

虚拟内存增大。mmap 会导致虚拟内存增大，我们的 APK、Dex、so 都是通过 mmap 读取。而目前大部分的应用还没支持 64 位，除去内核使用的地址空间，一般我们可以使用的虚拟内存空间只有 3GB 左右。如果 mmap 一个 1GB 的文件，应用很容易会出现虚拟内存不足所导致的 OOM。

磁盘延迟。mmap 通过缺页中断向磁盘发起真正的磁盘 I/O，所以如果我们当前的问题是在于磁盘 I/O 的高延迟，那么用 mmap() 消除小小的系统调用开销是杯水车薪的。启动优化中的类重排技术，就是将 Dex 中的类按照启动顺序重新排列，主要为了减少缺页中断造成的磁盘 I/O 延迟。



### 多线程阻塞 I/O

文件读写受到 I/O 性能瓶颈的影响，在到达一定速度后整体性能就会受到明显的影响，过多的线程反而会导致应用整体性能的明显下降。

iowait 高，I/O 一定有问题。但 iowait 低，I/O 不一定没有问题。这个时候我们还要看 CPU 的 idle 比例。

（线程阻塞会导致线程切换频繁，增大系统上下文切换的开销）



### NIO

当线程遇到 I/O 操作时，不再以阻塞的方式等待 I/O 操作的完成，而是将 I/O 请求发送给系统后，继续往下执行。

非阻塞的 NIO 将 I/O 以事件的方式通知，可以减少线程切换的开销。

使用 NIO 的最大作用不是减少读取文件的耗时，而是最大化提升应用整体的 CPU 利用率。



### 小文件系统

文件的读取需要先找到存储的位置，在文件系统上面我们使用 inode 来存储目录。读取一个文件的耗时可以拆分成下面两个部分。

```
文件读取的时间 = 找到文件的 inode 的时间 + 根据 inode 读取文件数据的时间
```

大量的小文件合并为大文件后，我们还可以将能连续访问的小文件合并存储，将原本小文件间的随机访问变为了顺序访问，可以大大提高性能。同时合并存储能够有效减少小文件存储时所产生的磁盘碎片问题，提高磁盘的利用率。



微信的SFS、 Google 的 GFS、淘宝开源的TFS、Facebook 的 Haystack 都是专门为海量小文件的存储和检索设计的文件系统。





### I/O 跟踪

Facebook 的 Profilo 为了拿到 ftrace 的信息，使用了 PLT Hook 技术监听了“atrace_marker_fd”文件的写入。



#### Java Hook

Android 6.0 ，FileInputStream 的整个调用流程:

```
java : FileInputStream -> IoBridge.open -> Libcore.os.open 
-> BlockGuardOs.open -> Posix.open
```

在[Libcore.java](http://androidxref.com/6.0.1_r10/xref/libcore/luni/src/main/java/libcore/io/Libcore.java)中可以找到  , [BlockGuardOs](http://androidxref.com/6.0.1_r10/xref/libcore/luni/src/main/java/libcore/io/BlockGuardOs.java)这一个静态变量，来HOOK

```
public static Os os = new BlockGuardOs(new Posix());
// 反射获得静态变量
Class<?> clibcore = Class.forName("libcore.io.Libcore");
Field fos = clibcore.getDeclaredField("os");
```

通过动态代理的方式，在所有 I/O 相关方法前后加入插桩代码，统计 I/O 操作相关的信息。

```
// 动态代理对象
Proxy.newProxyInstance(cPosix.getClassLoader(), getAllInterfaces(cPosix), this);

beforeInvoke(method, args, throwable);
result = method.invoke(mPosixOs, args);
afterInvoke(method, args, result);
```

缺点:

性能极差。I/O 操作调用非常频繁，因为使用动态代理和 Java 的大量字符串操作，导致性能比较差，无法达到线上使用的标准。

无法监控 Native 代码。例如微信中有大量的 I/O 操作是在 Native 代码中，使用 Java Hook 方案无法监控到。

兼容性差。Java Hook 需要每个 Android 版本去兼容，特别是 Android P 增加对非公开 API 限制。



#### Native Hook

从 libc.so 中的这几个函数中选定 Hook 的目标函数。

```
int open(const char *pathname, int flags, mode_t mode);
ssize_t read(int fd, void *buf, size_t size);
ssize_t write(int fd, const void *buf, size_t size); write_cuk
int close(int fd);
```

因为使用的是 GOT Hook，需要选择一些有调用上面几个方法的 library。

微信 Matrix 中选择的是libjavacore.so、libopenjdkjvm.so、libopenjdkjvm.so，可以覆盖到所有的 Java 层的 I/O 调用，具体可以参考[io_canary_jni.cc](https://github.com/Tencent/matrix/blob/master/matrix/matrix-android/matrix-io-canary/src/main/cpp/io_canary_jni.cc#L161)。

更推荐 Profilo 中[atrace.cpp](https://github.com/facebookincubator/profilo/blob/main/cpp/atrace/Atrace.cpp#L172)的做法，它直接遍历所有已经加载的 library，一并替换。

```
void hookLoadedLibs() {
  auto& functionHooks = getFunctionHooks();
  auto& seenLibs = getSeenLibs();
  facebook::profilo::hooks::hookLoadedLibs(functionHooks, seenLibs);
}
```

在 Android 7.0 之后，我们还需要替换下面这三个方法。

```
open64
__read_chk
__write_chk
```

#### 监控内容

```
open: 文件名、fd、文件原始大小、堆栈、线程
read、write：类型、读写次数、读写总大小、使用buffer大小、读写总耗时
close：打开文件总耗时、最大连续读写时间
```

连读读写时间和打开文件的总时间相同，我们可以判断出这次 read() 操作是一气呵成的，中间没有间断。



#### 线上监控

##### 主线程 I/O：

尽量不要再主线程IO，

如果所有的主线程 I/O数据会非常大，所以增加"连续读写时间超过 100 毫秒"条件，之所以使用连续读写时间，是因为发现有不少案例是打开了文件句柄，但不是一次读写完的。



##### 读写 Buffer 过小：

Buffer 太小，会导致多次无用的系统调用和内存拷贝，导致 read/write 的次数增多，从而影响了性能。

选用多大的 Buffer?

跟据文件保存所挂载的目录的 block size 来确认 Buffer 大小，数据库中的[pagesize](http://androidxref.com/6.0.1_r10/xref/frameworks/base/core/java/android/database/sqlite/SQLiteGlobal.java#61)就是这样确定的。

```
new StatFs("/data").getBlockSize()
```

最终选择的判断条件为：

buffer size 小于 block size，这里一般为 4KB。

read/write 的次数超过一定的阈值，例如 5 次，这主要是为了减少上报量。



Buffer 的大小一般推荐使用 4KB 以上



查看磁盘内部预读大小

```
/sys/block/[disk]/queue/read_ahead_kb
```

查看磁盘读写次数

/proc/sys/vm/block_dump 或者[/proc/diskstats](/proc/diskstats)

```
/proc/diskstats
块设备名字|读请求次数|读请求扇区数|读请求耗时总和\.\.\.\.
dm-0 23525 0 1901752 45366 0 0 0 0 0 33160 57393
dm-1 212077 0 6618604 430813 1123292 0 55006889 3373820 0 921023 3805823
```



##### 重复读：

加一层内存 cache 是最直接有效的办法



##### 资源泄漏:

资源泄漏是指打开资源包括文件、Cursor 等没有及时 close，从而引起泄露。

利用了 Android 框架中的 StrictMode监控资源泄露

StrictMode 利用[CloseGuard.java](http://androidxref.com/8.1.0_r33/xref/libcore/dalvik/src/main/java/dalvik/system/CloseGuard.java)类在很多系统代码已经预置了埋点。

Hook点：

- 利用反射，把 CloseGuard 中的 ENABLED 值设为 true。
- 利用动态代理，把CloseGuard中的REPORTER 替换成我们定义的 proxy。



在程序中写了一个 MyCloseGuard 类，对希望增加监控的资源，可以手动增加埋点代码。



### I/O 与启动优化

主线程 I/O、读写 Buffer、重复读以及资源泄漏是首先需要解决的，特别是重复读，比如 cpuinfo、手机内存这些信息都应该缓存起来。

I/O 操作的进一步的优化：

- 对大文件使用 mmap 或者 NIO 方式。[MappedByteBuffer](https://developer.android.com/reference/java/nio/MappedByteBuffer)就是 Java NIO 中的 mmap 封装，对于大文件的频繁读写会有比较大的优化。
- 安装包不压缩。对启动过程需要的文件，我们可以指定在安装包中不压缩，这样也会加快启动速度，但带来的影响是安装包体积增大。事实上 Google Play 非常希望我们不要去压缩 library、resource、resource.arsc 这些文件，这样对启动的内存和速度都会有很大帮助。而且不压缩文件带来只是安装包体积的增大，对于用户来说，Download size 并没有增大。
- Buffer 复用。我们可以利用Okio开源库，它内部的 ByteString 和 Buffer 通过重用等技巧，很大程度上减少 CPU 和内存的消耗。
- 存储结构和算法的优化。是否可以通过算法或者数据结构的优化，让我们可以尽量的少 I/O 甚至完全没有 I/O。比如一些配置文件从启动完全解析，改成读取时才解析对应的项；替换掉 XML、JSON 这些格式比较冗余、性能比较较差的数据结构。



### 相关资料

[《vmstat 监视内存使用情况》](https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/vmstat.html)

 [dd 命令](https://www.cnblogs.com/kongzhongqijing/articles/9049336.html)

[磁盘 I/O 那些事](https://tech.meituan.com/2017/05/19/about-desk-io.html)

Linux 内核的文件 Cache 管理机制介绍

[The Linux Kernel/Storage](https://en.wikibooks.org/wiki/The_Linux_Kernel/Storage)

[选 eMMC、UFS 还是 NVMe？ 手机 ROM 存储传输协议解析](https://www.sohu.com/a/196510603_616364)

[聊聊 Linux IO](http://0xffffff.org/2017/05/01/41-linux-io/)

[采用 NAND Flash 设计存储设备的挑战在哪里?](http://blog.51cto.com/alanwu/1425566)

Linux 中直接 I/O 机制的介绍

[高性能日志 xlog](https://mp.weixin.qq.com/s/cnhuEodJGIbdodh0IxNeXQ)

[Okio](https://github.com/square/okio)

[Tinker 的资源合成](https://github.com/Tencent/tinker/tree/master/third-party/tinker-ziputils)



## 存储优化

### Android 分区

通过 /proc/partitions 或者 df 命令来查看的各个分区情况

/system 分区：它是存放所有 Google 提供的 Android 组件的地方。这个分区只能以只读方式 mount。这样主要基于稳定性和安全性考虑，即使发生用户突然断电的情况，也依然需要保证 /system 分区的内容不会受到破坏和篡改。

/data 分区：它是所有用户数据存放的地方。主要为了实现数据隔离，即系统升级和恢复的时候会擦除整个 /system 分区，但是却不会影响 /data 的用户数据。而恢复出厂设置，只会擦除 /data 的数据。

/vendor 分区：它是存放厂商特殊系统修改的地方。特别是在 Android 8.0 以后，隆重推出了“Treble”项目。厂商 OTA 时可以只更新自己的 /vendor 分区即可，让厂商能够以更低的成本，更轻松、更快速地将设备更新到新版 Android 系统。



### Android 存储安全

#### 权限控制

每个应用都在自己的应用沙盒内运行，在 Android 4.3 之前的版本中，这些沙盒使用了标准 Linux 的保护机制，通过为每个应用创建独一无二的 Linux UID 来定义。

在 Android 4.3 引入了SELinux（Security Enhanced Linux）机制进一步定义 Android 应用沙盒的边界。它的作用是即使我们进程有 root 权限也不能为所欲为，如果想在 SELinux 系统中干任何事情，都必须先在专门的安全策略配置文件中赋予权限。



#### 数据加密

Android 有两种设备加密方法：全盘加密和文件级加密。

全盘加密是在 Android 4.4 中引入的，并在 Android 5.0 中默认打开。它会将 /data 分区的用户数据操作加密 / 解密，对性能会有一定的影响，但是新版本的芯片都会在硬件中提供直接支持。

基于文件系统的加密，如果设备被解锁了，加密也就没有用了。所以 Android 7.0 增加了基于文件的加密。在这种加密模式下，将会给每个文件都分配一个必须用用户的 passcode 推导出来的密钥。特定的文件被屏幕锁屏之后，直到用户下一次解锁屏幕期间都不能访问。

对于应用程序特别敏感的数据，我们也需要采用 RSA、AES、chacha20 等常用方式做进一步的存储加密。



### 常见的数据存储方法

#### SharedPreferences

是用来存储一些非常简单、轻量的数据。

问题:

- 跨进程不安全。由于没有使用跨进程的锁，就算使用MODE_MULTI_PROCESS，SharedPreferences 在跨进程频繁读写有可能导致数据全部丢失。根据线上统计，SP 大约会有万分之一的损坏率。
- 加载缓慢。SharedPreferences 文件的加载使用了异步线程，而且加载线程并没有设置线程优先级，如果这个时候主线程读取数据就需要等待文件加载线程的结束。这就导致出现主线程等待低优先级线程锁的问题，比如一个 100KB 的 SP 文件读取等待时间大约需要 50~100ms，建议提前用异步线程预加载启动过程用到的 SP 文件。
- 全量写入。无论是调用 commit() 还是 apply()，即使我们只改动其中的一个条目，都会把整个内容全部写到文件。而且即使我们多次写入同一个文件，SP 也没有将多次修改合并为一次，这也是性能差的重要原因之一。
- 卡顿。由于提供了异步落盘的 apply 机制，在崩溃或者其他一些异常情况可能会导致数据丢失。所以当应用收到系统广播，或者被调用 onPause 等一些时机，系统会强制把所有的 SharedPreferences 对象数据落地到磁盘。如果没有落地完成，这时候主线程会被一直阻塞。这样非常容易造成卡顿，甚至是 ANR，从线上数据来看 SP 卡顿占比一般会超过 5%。



#### ContentProvider

提供了不同进程甚至是不同应用程序之间共享数据的机制。



启动性能:

ContentProvider 的生命周期默认在 Application onCreate() 之前，而且都是在主线程创建的。我们自定义的 ContentProvider 类的构造函数、静态代码块、onCreate 函数都尽量不要做耗时的操作，会拖慢启动速度。

ContentProvider 还有一个多进程模式，它可以和 AndroidManifest 中的 multiprocess 属性结合使用。这样调用进程会直接在自己进程里创建一个 push 进程的 Provider 实例，就不需要跨进程调用了。需要注意的是，这样也会带来 Provider 的多实例问题。



稳定性:

ContentProvider 在进行跨进程数据传递时，利用了 Android 的 Binder 和匿名共享内存机制。

通过 Binder 传递 CursorWindow 对象内部的匿名共享内存的文件描述符。这样在跨进程传输中，结果数据并不需要跨进程传输，而是在不同进程中通过传输的匿名共享内存文件描述符来操作同一块匿名内存，这样来实现不同进程访问相同数据的目的。



基于 mmap 的匿名共享内存机制也是有代价的。当传输的数据量非常小的时候，可能不一定划算。所以 ContentProvider 提供了一种 call 函数，它会直接通过 Binder 来传输数据。

Android 的 Binder 传输是有大小限制的，一般来说限制是 1~2MB。ContentProvider 的接口调用参数和 call 函数调用并没有使用匿名共享机制，比如要批量插入很多数据，那么就会出现一个插入数据的数组，如果这个数组太大了，那么这个操作就可能会出现数据超大异常。



安全性:

如果 ContentProvider 是 exported，当支持执行 SQL 语句时就需要注意 SQL 注入的问题。另外如果我们传入的参数是一个文件路径，然后返回文件的内容，这个时候也要校验合法性，不然整个应用的私有数据都有可能被别人拿到，在 intent 传递参数的时候可能经常会犯这个错误。





### 替换系统SharedPreferences的实现

通过复写 Application 的getSharedPreferences替换系统SharedPreferences的实现，核心的优化在于修改了 Apply 的实现，将多个 Apply 方法在内存中合并，而不是多次提交。

```java
public void apply() {
	// 先调用commitToMemory()
    final MemoryCommitResult mcr = commitToMemory();

    boolean hasDiskWritesInFlight = false;
    synchronized (SharedPreferencesImpl.this) {
      // mDiskWritesInFlight大于0说明之前已经有调用过commitToMemory()了
        hasDiskWritesInFlight = mDiskWritesInFlight > 0;
    }
    // 源码没有这层判断，直接提交。
    if (!hasDiskWritesInFlight) {
        final Runnable awaitCommit = new Runnable() {
            public void run() {
                try {
                    mcr.writtenToDiskLatch.await();
                } catch (InterruptedException ignored) {
                }
            }
        };

        QueuedWork.add(awaitCommit);


        Runnable postWriteRunnable = new Runnable() {
            public void run() {
                awaitCommit.run();

                QueuedWork.remove(awaitCommit);
            }
        };

        SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);
    }

    // Okay to notify the listeners before it's hit disk
    // because the listeners should always get the same
    // SharedPreferences instance back, which has the
    // changes reflected in memory.
    notifyListeners(mcr);
```



### 对象序列化







### 相关资料

["Treble”项目](https://source.android.com/devices/architecture)

[应用沙盒](https://source.android.google.cn/docs/security/app-sandbox)

[SELinux](https://source.android.google.cn/security/selinux)

[设备加密方法](https://source.android.google.cn/docs/security/features/encryption)

[全盘加密](https://source.android.google.cn/security/encryption/full-disk)

[基于文件的加密](https://source.android.google.cn/security/encryption/file-based)

[存储选项](https://developer.android.com/guide/topics/data/data-storage)

《彻底搞懂 SharedPreferences》

[MMKV](https://github.com/Tencent/MMKV)









## 网络优化





## 耗电优化



## UI优化



## 包体积优化
